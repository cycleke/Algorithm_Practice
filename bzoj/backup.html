<html>
<body>
<title>Export All AC Source</title>
<h2>Problem1000</h2><pre>#include &lt;cstdio&gt;
int main() {int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);printf(&quot;%d\n&quot;,a+b);return 0;}<pre><h2>Problem1001</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int M=1000*1000*6+20,N=1000*1000+10;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
int to[M],nxt[M],C[M],head[N],tote;
inline void adde(int a,int b,int c) {
	to[tote]=b,nxt[tote]=head[a],C[tote]=c;
	head[a]=tote++;
}
inline int min(int a,int b){return a&lt;b?a:b;}
int S,T,d[N],dt[N];
int dfs(int u,int flow) {
	if(u==T||!flow) return flow;
	int r=0,t,v;
	for(int i=head[u];~i;i=nxt[i])
		if(d[v=to[i]]+1==d[u]&amp;&amp;C[i]) {
			t=dfs(v,min(C[i],flow));
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(!flow||d[S]&gt;T) return r;
		}
	if(!(--dt[d[u]])) d[S]=T+1;
	++dt[++d[u]]; return r;
}
inline int SAP() {
	int *l=dt,*r=dt;
	register int ans=0,i;
	*r++=T; d[T]=1;
	while(l&lt;r) {
		for(i=head[*l];~i;i=nxt[i])
			if(!d[to[i]]) d[*r++=to[i]]=d[*l]+1;
		++l;
	}
	memset(dt,0,sizeof dt);
	for(i=S;i&lt;=T;++i)
		++dt[d[i]];
	while(d[S]&lt;T+1) ans+=dfs(S,0x7f7f7f7f);
	return ans;
}
int main() {
	register int n=geti(),m=geti(),i,j,k;
	memset(head,-1,sizeof head);
	for(i=1;i&lt;=n;++i)
		for(j=1;j&lt;m;++j) {
			k=geti();
			adde((i-1)*m+j,(i-1)*m+j+1,k);
			adde((i-1)*m+j+1,(i-1)*m+j,k);
		}
	for(i=1;i&lt;n;++i)
		for(j=1;j&lt;=m;++j) {
			k=geti();
			adde((i-1)*m+j,i*m+j,k);
			adde(i*m+j,(i-1)*m+j,k);
		}
	for(i=1;i&lt;n;++i)
		for(j=1;j&lt;m;++j) {
			k=geti();
			adde((i-1)*m+j,i*m+j+1,k);
			adde(i*m+j+1,(i-1)*m+j,k);
		}
	S=1,T=n*m;
	printf(&quot;%d\n&quot;,SAP());
	return 0;
}
<pre><h2>Problem1001</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int M=1000*1000*6+20,N=1000*1000+10;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
	while(c=getc(),c&lt;'0');a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int to[M],nxt[M],C[M],head[N],tote;
#define adde(a,b,c) {\
	to[tote]=b,nxt[tote]=head[a],C[tote]=c;\
	head[a]=tote++;\
}
#define min(a,b) (a&lt;b?a:b)
int S,T,d[N],dt[N];
int dfs(int u,int flow) {
	if(u==T||!flow) return flow;
	int r=0,t,v;
	for(int i=head[u];~i;i=nxt[i])
		if(d[v=to[i]]+1==d[u]&amp;&amp;C[i]) {
			t=dfs(v,min(C[i],flow));
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(!flow||d[S]&gt;T) return r;
		}
	if(!(--dt[d[u]])) d[S]=T+1;
	++dt[++d[u]]; return r;
}
inline int SAP() {
	int *l=dt,*r=dt;
	register int ans=0,i;
	*r++=T; d[T]=1;
	while(l&lt;r) {
		for(i=head[*l];~i;i=nxt[i])
			if(!d[to[i]]) d[*r++=to[i]]=d[*l]+1;
		++l;
	}
	memset(dt,0,T+2&lt;&lt;2);
	for(i=S;i&lt;=T;++i)
		++dt[d[i]];
	while(d[S]&lt;T+1) ans+=dfs(S,0x7f7f7f7f);
	return ans;
}
int main() {
	register int n=geti(),m=geti(),i,j,k;
	S=1,T=n*m;
	memset(head,-1,T+1&lt;&lt;2);
	for(i=1;i&lt;=n;++i)
		for(j=1;j^m;++j) {
			k=geti();
			adde((i-1)*m+j,(i-1)*m+j+1,k);
			adde((i-1)*m+j+1,(i-1)*m+j,k);
		}
	for(i=1;i^n;++i)
		for(j=1;j&lt;=m;++j) {
			k=geti();
			adde((i-1)*m+j,i*m+j,k);
			adde(i*m+j,(i-1)*m+j,k);
		}
	for(i=1;i^n;++i)
		for(j=1;j^m;++j) {
			k=geti();
			adde((i-1)*m+j,i*m+j+1,k);
			adde(i*m+j+1,(i-1)*m+j,k);
		}
	printf(&quot;%d\n&quot;,SAP());
	return 0;
}
<pre><h2>Problem1001</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
	while(c=getc(),c&lt;'0');a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 2000000
struct E{int to,v;E*nxt;}CD[N*5],*cd=CD,*head[N];
#define adde(a,b,c) (cd-&gt;v=c,cd-&gt;to=b,cd-&gt;nxt=head[a],head[a]=cd++)
int d[N];
#define pr pair&lt;int,int&gt;
priority_queue&lt; pr, vector&lt; pr &gt;,greater &lt; pr &gt; &gt;heap;
int main() {
	int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	register int S=0,T=(n-1)*(m-1)*2+1;
	if(n==1|m==1) {
		register int ans=1&lt;&lt;30,a;
		while(scanf(&quot;%d&quot;,&amp;a)==1) if(a&lt;ans) ans=a;
		printf(&quot;%d\n&quot;,ans);
		return 0;
	}
	register int e=1,f=2,i,j,a,b,c;
	for(i=0;i^n;++i)
		for(j=1;j^m;++j) {
			c=geti();
			if(!i) a=T,b=f,f+=2;
			else if(i==n-1) a=e,b=0,e+=2;
			else a=e,b=f,e+=2,f+=2;
			adde(a,b,c);adde(b,a,c);
		}
	e=1,f=2;
	for(i=1;i^n;++i)
		for(j=0;j^m;++j) {
			c=geti();
			if(!j) a=0,b=e,e+=2;
			else if(j==m-1) a=f,b=T,f+=2;
			else a=e,b=f,e+=2,f+=2;
			adde(a,b,c);adde(b,a,c);
		}
	e=1,f=2;
	for(i=1;i^n;++i)
		for(j=1;j^m;++j) {
			c=geti();
			adde(e,f,c);adde(f,e,c);
			e+=2,f+=2;
		}
	memset(d,127,sizeof d);
	while(!heap.empty()) heap.pop();
	heap.push(make_pair(*d=0,0));
	E*it;
	while(!heap.empty()) {
		a=heap.top().second,c=heap.top().first; heap.pop();
		if(c^d[a]) continue;
		for(it=head[a];it;it=it-&gt;nxt)
			if(c+it-&gt;v&lt;d[b=it-&gt;to]) heap.push(make_pair(d[b]=c+it-&gt;v,b));
	}
	printf(&quot;%d\n&quot;,d[T]);
	return 0;
}
<pre><h2>Problem1001</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int M=1000*1000*6+20,N=1000*1000+10;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
	while(c=getc(),c&lt;'0');a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int to[M],nxt[M],C[M],head[N],tote;
#define adde(a,b,c) {							\
		to[tote]=b,nxt[tote]=head[a],C[tote]=c;	\
		head[a]=tote++;							\
	}
#define min(a,b) (a&lt;b?a:b)
int S,T,d[N],dt[N],last[N];
int dfs(int u,int flow) {
	if(u==T||!flow) return flow;
	int r=0,t,v;
	for(int i=last[u];~i;i=nxt[i])
		if(d[v=to[i]]+1==d[u]&amp;&amp;C[i]) {
			last[u]=i;
			t=dfs(v,min(C[i],flow));
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(!flow||d[S]&gt;T) return r;
		}
	last[u]=head[u];
	if(!(--dt[d[u]])) d[S]=T+1;
	++dt[++d[u]]; return r;
}
inline int SAP() {
	int *l=dt,*r=dt;
	register int ans=0,i;
	*r++=T; d[T]=1;
	while(l&lt;r) {
		for(i=head[*l];~i;i=nxt[i])
			if(!d[to[i]]) d[*r++=to[i]]=d[*l]+1;
		++l;
	}
	memset(dt,0,T+2&lt;&lt;2);
	for(i=S;i&lt;=T;++i)
		++dt[d[i]],last[i]=head[i];
	while(d[S]&lt;T+1) ans+=dfs(S,0x7f7f7f7f);
	return ans;
}
int main() {
	register int n=geti(),m=geti(),i,j,k;
	S=1,T=n*m;
	memset(head,-1,T+1&lt;&lt;2);
	for(i=1;i&lt;=n;++i)
		for(j=1;j^m;++j) {
			k=geti();
			adde((i-1)*m+j,(i-1)*m+j+1,k);
			adde((i-1)*m+j+1,(i-1)*m+j,k);
		}
	for(i=1;i^n;++i)
		for(j=1;j&lt;=m;++j) {
			k=geti();
			adde((i-1)*m+j,i*m+j,k);
			adde(i*m+j,(i-1)*m+j,k);
		}
	for(i=1;i^n;++i)
		for(j=1;j^m;++j) {
			k=geti();
			adde((i-1)*m+j,i*m+j+1,k);
			adde(i*m+j+1,(i-1)*m+j,k);
		}
	printf(&quot;%d\n&quot;,SAP());
	return 0;
}
<pre><h2>Problem1002</h2><pre>#include &lt;cstdio&gt;
int a[100],b[100],c[100],n;
#define ba 1000000
int main() {
    scanf(&quot;%d&quot;,&amp;n);
    if(n&lt;3) return puts(n&lt;2?&quot;1&quot;:&quot;5&quot;),0;
    register int i,la=1,lb=1,lc=1;
    *a=1,*b=5; n-=2;
    while(n--) {
        //c=3*b-a+2
        for(i=0;i&lt;lb;++i) c[i]=b[i]*3;
        for(i=0;i&lt;lb;++i) c[i+1]+=c[i]/ba,c[i]%=ba;
        for(lc=lb;c[lc];++lc); *c+=2;
        for(i=0;i&lt;lc;++i) {
            c[i]-=a[i];
            if(c[i]&lt;0) --c[i+1],c[i]+=ba;
        }
        while(!c[lc-1]) --lc;
        for(i=0;i&lt;lb;++i)a[i]=b[i];la=lb;
        for(i=0;i&lt;lc;++i)b[i]=c[i];lb=lc;
    }
    printf(&quot;%d&quot;,c[lc-1]);
    for(i=lc-2;~i;--i) printf(&quot;%06d&quot;,c[i]);
    return 0;
}
<pre><h2>Problem1002</h2><pre>#include &lt;cstdio&gt;
int a[20],b[20],c[20],n;
#define ba 1000000
int main() {
    scanf(&quot;%d&quot;,&amp;n);
    if(n&lt;3) return puts(n&lt;2?&quot;1&quot;:&quot;5&quot;),0;
    register int i,la=1,lb=1,lc=1;
    *a=1,*b=5; n-=2;
    while(n--) {
        //c=3*b-a+2
        for(i=0;i&lt;lb;++i) c[i]=b[i]*3;
        for(i=0;i&lt;lb;++i) c[i+1]+=c[i]/ba,c[i]%=ba;
        for(lc=lb;c[lc];++lc); *c+=2;
        for(i=0;i&lt;lc;++i) {
            c[i]-=a[i];
            if(c[i]&lt;0) --c[i+1],c[i]+=ba;
        }
        while(!c[lc-1]) --lc;
        for(i=0;i&lt;lb;++i)a[i]=b[i];la=lb;
        for(i=0;i&lt;lc;++i)b[i]=c[i];lb=lc;
    }
    printf(&quot;%d&quot;,c[lc-1]);
    for(i=lc-2;~i;--i) printf(&quot;%06d&quot;,c[i]);
    return 0;
}
<pre><h2>Problem1002</h2><pre>#include &lt;cstdio&gt;
int a[99],b[99],c[99];
int main() {
register int n; register char ch;
while(ch=getchar(),ch&lt;'0');n=ch-'0';
while(ch=getchar(),'-'&lt;ch)n=(n&lt;&lt;3)+(n&lt;&lt;1)+ch-'0';
if(n&lt;3) return puts(n&lt;2?&quot;1&quot;:&quot;5&quot;),0;
register int i,la=1,lb=1,lc=1;
*a=1,*b=5; n-=2;
while(n--) {
//c=3*b-a+2
for(i=0;i&lt;lb;++i) c[i]=b[i]*3;
for(i=0;i&lt;lb;++i) c[i+1]+=c[i]/10,c[i]%=10;
for(lc=lb;c[lc];++lc); *c+=2;
for(i=0;i&lt;lc;++i) {
c[i]-=a[i];
if(c[i]&lt;0) --c[i+1],c[i]+=10;
}
while(!c[lc-1]) --lc;
for(i=0;i&lt;lb;++i)a[i]=b[i];la=lb;
for(i=0;i&lt;lc;++i)b[i]=c[i];lb=lc;
}
for(i=lc-1;~i;--i) putchar(c[i]+'0');
return 0;
}
<pre><h2>Problem1003</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int dp[102],c[102][102],vis[102],d[21];
struct E{int to,v;E*nxt;}CD[100*100+2],*cd=CD,*head[102];
inline void cmin(int&amp;a,int b){b&lt;a?a=b:1;}
#define pr pair&lt;int,int&gt;
priority_queue&lt; pr, vector&lt; pr &gt;,greater &lt; pr &gt; &gt;heap;
inline int dijstra(int sta,int t) {
	memset(d,127,sizeof d);
	while(!heap.empty()) heap.pop();
	heap.push(make_pair(*d=0,0));
	int s,dis; E*it;
	while(!heap.empty()) {
		s=heap.top().second,dis=heap.top().first; heap.pop();
		if(dis^d[s]) continue;
		for(it=head[s];it;it=it-&gt;nxt)
			if(!(sta&amp;(1&lt;&lt;it-&gt;to))&amp;&amp;dis+it-&gt;v&lt;d[it-&gt;to])
				heap.push(make_pair(d[it-&gt;to]=dis+it-&gt;v,it-&gt;to));
	}
	return (d[t]^0x7f7f7f7f)?d[t]:-1;
}
int main() {
	register int n=geti(),m=geti(),k=geti(),e=geti(),i,j,x;
	while(e--) {
		i=geti()-1,j=geti()-1,x=geti();
		cd-&gt;v=x,cd-&gt;to=j,cd-&gt;nxt=head[i],head[i]=cd++;
		cd-&gt;v=x,cd-&gt;to=i,cd-&gt;nxt=head[j],head[j]=cd++;
	}
	for(e=geti();e;--e) {
		x=geti()-1,i=geti(),j=geti();
		for(;i&lt;=j;++i)vis[i]|=1&lt;&lt;x;
	}
	memset(c,-1,sizeof c);
	for(i=1;i&lt;=n;++i) {
		x=0;
		for(j=i;j&lt;=n;++j) {
			x|=vis[j];
			if((c[i][j]=dijstra(x,m-1))&lt;0) break;
		}
	}
	dp[0]=0,dp[1]=c[1][1];
	for(i=2;i&lt;=n;++i) {
		dp[i]=(~c[1][i])?(c[1][i]*i):0x7f7f7f7f;
		for(j=i;j;--j)
			if(~c[j][i]) cmin(dp[i],dp[j-1]+k+(i-j+1)*c[j][i]);
			else break;
	}
	printf(&quot;%d\n&quot;,dp[n]);
	return 0;
}
<pre><h2>Problem1003</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int dp[102],c[102][102],vis[102],d[21];
struct E{int to,v;E*nxt;}CD[100*100+2],*cd=CD,*head[102];
inline void cmin(int&amp;a,int b){b&lt;a?a=b:1;}
#define pr pair&lt;int,int&gt;
priority_queue&lt; pr, vector&lt; pr &gt;,greater &lt; pr &gt; &gt;heap;
inline int dijstra(int sta,int t) {
	memset(d,127,sizeof d);
	while(!heap.empty()) heap.pop();
	heap.push(make_pair(*d=0,0));
	int s,dis; E*it;
	while(!heap.empty()) {
		s=heap.top().second,dis=heap.top().first; heap.pop();
		if(dis^d[s]) continue;
		for(it=head[s];it;it=it-&gt;nxt)
			if(!(sta&amp;(1&lt;&lt;it-&gt;to))&amp;&amp;dis+it-&gt;v&lt;d[it-&gt;to])
				heap.push(make_pair(d[it-&gt;to]=dis+it-&gt;v,it-&gt;to));
	}
	return (d[t]^0x7f7f7f7f)?d[t]:-1;
}
int main() {
	register int n=geti(),m=geti(),k=geti(),e=geti(),i,j,x;
	while(e--) {
		i=geti()-1,j=geti()-1,x=geti();
		cd-&gt;v=x,cd-&gt;to=j,cd-&gt;nxt=head[i],head[i]=cd++;
		cd-&gt;v=x,cd-&gt;to=i,cd-&gt;nxt=head[j],head[j]=cd++;
	}
	for(e=geti();e;--e) {
		x=geti()-1,i=geti(),j=geti();
		for(;i&lt;=j;++i)vis[i]|=1&lt;&lt;x;
	}
	memset(c,-1,sizeof c);
	for(i=1;i&lt;=n;++i) {
		x=vis[i];
		c[i][i]=dijstra(x,m-1);
		for(j=i+1;j&lt;=n;++j) {
			if((x|vis[j])==x){c[i][j]=c[i][j-1];continue;}
			x|=vis[j];
			if((c[i][j]=dijstra(x,m-1))&lt;0) break;
		}
	}
	dp[0]=0,dp[1]=c[1][1];
	for(i=2;i&lt;=n;++i) {
		dp[i]=(~c[1][i])?(c[1][i]*i):0x7f7f7f7f;
		for(j=i;j;--j)
			if(~c[j][i]) cmin(dp[i],dp[j-1]+k+(i-j+1)*c[j][i]);
			else break;
	}
	printf(&quot;%d\n&quot;,dp[n]);
	return 0;
}
<pre><h2>Problem1003</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int dp[102],c[102][102],vis[102],d[21];
struct E{int to,v;E*nxt;}CD[100*100+2],*cd=CD,*head[102];
inline void cmin(int&amp;a,int b){b&lt;a?a=b:1;}
#define pr pair&lt;int,int&gt;
priority_queue&lt; pr, vector&lt; pr &gt;,greater &lt; pr &gt; &gt;heap;
inline int dijstra(int sta,int t) {
	memset(d,127,sizeof d);
	while(!heap.empty()) heap.pop();
	heap.push(make_pair(*d=0,0));
	register int s,dis; E*it;
	while(!heap.empty()) {
		s=heap.top().second,dis=heap.top().first; heap.pop();
		if(dis^d[s]) continue;
		for(it=head[s];it;it=it-&gt;nxt)
			if(!((sta&gt;&gt;it-&gt;to)&amp;1)&amp;&amp;dis+it-&gt;v&lt;d[it-&gt;to])
				heap.push(make_pair(d[it-&gt;to]=dis+it-&gt;v,it-&gt;to));
	}
	return (d[t]^0x7f7f7f7f)?d[t]:-1;
}
int main() {
	register int n=geti(),m=geti(),k=geti(),e=geti(),i,j,x;
	while(e--) {
		i=geti()-1,j=geti()-1,x=geti();
		cd-&gt;v=x,cd-&gt;to=j,cd-&gt;nxt=head[i],head[i]=cd++;
		cd-&gt;v=x,cd-&gt;to=i,cd-&gt;nxt=head[j],head[j]=cd++;
	}
	for(e=geti();e;--e) {
		x=geti()-1,i=geti(),j=geti();
		for(;i&lt;=j;++i)vis[i]|=1&lt;&lt;x;
	}
	memset(c,-1,sizeof c);
	for(i=1;i&lt;=n;++i) {
		x=vis[i];
		c[i][i]=dijstra(x,m-1);
		for(j=i+1;j&lt;=n;++j) {
			if((x|vis[j])==x){c[i][j]=c[i][j-1];continue;}
			if((c[i][j]=dijstra(x|=vis[j],m-1))&lt;0) break;
		}
	}
	dp[0]=0,dp[1]=c[1][1];
	for(i=2;i&lt;=n;++i) {
		dp[i]=(~c[1][i])?(c[1][i]*i):0x7f7f7f7f;
		for(j=i;j;--j)
			if(~c[j][i]) cmin(dp[i],dp[j-1]+k+(i-j+1)*c[j][i]);
			else break;
	}
	printf(&quot;%d\n&quot;,dp[n]);
	return 0;
}
<pre><h2>Problem1004</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int dp[22][22][22],change[100][61],vis[61],vis_clock,d[61];
int sr,sb,sg,n,p;
#define inc(a,b) for((a)+=(b);(a)&gt;=p;(a)-=p)
inline int Cal(int*a) {
	memset(dp,0,sizeof dp);
	register int s=0,i,j,k,t;
	++vis_clock;
	for(i=1;i&lt;=n;++i)
		if(vis[i]^vis_clock) {
			d[s]=0;
			for(j=i;vis[j]^vis_clock;j=a[j])
				vis[j]=vis_clock,++d[s];
			++s;
		}
	dp[0][0][0]=1;
	for(--s;~s;--s)
		for(t=d[s],i=sr;~i;--i)
			for(j=sb;~j;--j)
				for(k=sg;~k;--k) {
					if(i&gt;=t) inc(dp[i][j][k],dp[i-t][j][k]);
					if(j&gt;=t) inc(dp[i][j][k],dp[i][j-t][k]);
					if(k&gt;=t) inc(dp[i][j][k],dp[i][j][k-t]);
				}
	return dp[sr][sb][sg];
}
int main() {
	sr=geti(),sb=geti(),sg=geti();
	register int m=geti(),i,j; p=geti();
	n=sr+sb+sg;
	for(i=0;i&lt;m;++i) for(j=1;j&lt;=n;++j) change[i][j]=geti();
	for(i=1;i&lt;=n;++i) change[m][i]=i;
	++m;
	int ans=0;
	for(i=0;i&lt;m;++i)
		for(ans+=Cal(change[i]);ans&gt;=p;ans-=p);
	for(i=m,j=p-2;j;j&gt;&gt;=1,i=i*i%p)if(j&amp;1)ans=ans*i%p;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1005</h2><pre>#include &lt;cstdio&gt;
#define SIZE 169
#define ba 10000
const int p[SIZE] = {
	0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,  
	79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,  
	193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,  
	313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,  
	443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,  
	587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,  
	719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,
	859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997
};
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
int e[SIZE],Ans[10000];
inline void Fac(const int &amp;n,int k) {
	register int i,j;
	for(i=1;i^SIZE;++i)
		for(j=p[i];j&lt;=n;j*=p[i])
			e[i]+=k*(n/j);
}
int main() {
	register int n=geti(),i,len=n-2,m=0,t;
	for(i=0;i&lt;n;++i) {
		t=geti();
		if(!t||len&lt;t-1) return puts(&quot;0&quot;),0;
		if(t&lt;0) {++m;continue;}--t;
		Fac(len,1); Fac(t,-1); Fac(len-t,-1);
		len-=t;
	}
	if(len) {
		for(i=1;i^SIZE;++i)
			while(!(m%p[i])) m/=p[i],e[i]+=len;
	}
	Ans[1]=1; len=1;
	for(i=1;i^SIZE;++i)
		while(e[i]--) {
			for(t=1;t&lt;=len;++t) Ans[t]*=p[i];
			for(t=1;t&lt;=len;++t) if(Ans[t]&gt;=ba) Ans[t+1]+=Ans[t]/ba,Ans[t]%=ba;
			while(Ans[len+1]) {
				if(Ans[len]&gt;=ba) Ans[len+1]+=Ans[len]/ba,Ans[len]%ba;
				++len;
			}
			
		}
	for(printf(&quot;%d&quot;,Ans[len]),i=len-1;i;--i) printf(&quot;%04d&quot;,Ans[i]);
	return 0;
}
<pre><h2>Problem1005</h2><pre>#include &lt;cstdio&gt;
#define SIZE 169
#define ba 10000
const int p[SIZE] = {
    0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,  
    79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,  
    193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,  
    313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,  
    443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,  
    587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,  
    719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,
    859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997
};
inline int geti() {
    register int a; register char c,f=0;
    while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
    while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return f?-a:a;
}
int e[SIZE],Ans[3000],te;
inline void Fac(const int &amp;n,int k) {
    register int i,j;
    for(i=1;i^SIZE;++i)
        for(j=p[i];j&lt;=n;j*=p[i])
            e[i]+=k*(n/j),te+=k*(n/j);
}
int main() {
    register int n=geti(),i,len=n-2,m=0,t;
    for(i=0;i&lt;n;++i) {
        t=geti();
        if(!t||len&lt;t-1) return puts(&quot;0&quot;),0;
        if(t&lt;0) {++m;continue;}--t;
        Fac(len,1); Fac(t,-1); Fac(len-t,-1);
        len-=t;
    }
    if(len) {
        for(i=1;(i^SIZE)&amp;&amp;1&lt;m;++i)
            while(!(m%p[i])) m/=p[i],e[i]+=len,te+=len;
    }
    Ans[1]=len=1;
    for(i=1;(i^SIZE)&amp;&amp;te;++i)
        while(e[i]--) {
			--te;
            for(t=1;t&lt;=len;++t) Ans[t]*=p[i];
            for(t=1;t&lt;=len;++t) if(Ans[t]&gt;=ba) Ans[t+1]+=Ans[t]/ba,Ans[t]%=ba;
            while(Ans[len+1]) {
                if(Ans[len]&gt;=ba) Ans[len+1]+=Ans[len]/ba,Ans[len]%=ba;
                ++len;
            }
        }
    for(printf(&quot;%d&quot;,Ans[len]),i=len-1;i;--i) printf(&quot;%04d&quot;,Ans[i]);
    return 0;
}
<pre><h2>Problem1005</h2><pre>#include &lt;cstdio&gt;
#define SIZE 169
#define ba 10000
const int p[SIZE] = {
	0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,
    79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
    193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,
    313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,
    443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,
    587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,
    719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,
    859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997
};
inline int geti() {
    register int a; register char c,f=0;
    while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
    while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return f?-a:a;
}
int e[SIZE],Ans[3000];
inline void Fac(const int &amp;n,bool k) {
    register int i,j;
    for(i=1;i^SIZE;++i)
        for(j=p[i];j&lt;=n;j*=p[i])
            k?(e[i]+=n/j):(e[i]-=n/j);
}
int main() {
    register int n=geti(),i,len=n-2,m=0,t;
    for(i=0;i&lt;n;++i) {
        t=geti();
        if(!t||len&lt;t-1) return puts(&quot;0&quot;),0;
        if(t&lt;0) {++m;continue;}--t;
        Fac(len,1); Fac(t,0); Fac(len-t,0);
        len-=t;
    }
    if(len) {
        for(i=1;(i^SIZE)&amp;&amp;1&lt;m;++i)
            while(!(m%p[i])) m/=p[i],e[i]+=len;
    }
    Ans[1]=len=1;
    for(i=1;i^SIZE;++i)
        while(e[i]--) {
            for(t=1;t&lt;=len;++t) Ans[t]*=p[i];
            for(t=1;t&lt;=len;++t) if(Ans[t]&gt;=ba) Ans[t+1]+=Ans[t]/ba,Ans[t]%=ba;
            while(Ans[len+1]) {
                if(Ans[len]&gt;=ba) Ans[len+1]+=Ans[len]/ba,Ans[len]%=ba;
                ++len;
            }
        }
    for(printf(&quot;%d&quot;,Ans[len]),i=len-1;i;--i) printf(&quot;%04d&quot;,Ans[i]);
    return 0;
}
<pre><h2>Problem1005</h2><pre>#include &lt;cstdio&gt;
#define SIZE 169
#define ba 10000
const int p[SIZE] = {
	0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,
    79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
    193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,
    313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,
    443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,
    587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,
    719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,
    859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997
};
inline int geti() {
    register int a; register char c,f=0;
    while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
    while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return f?-a:a;
}
int e[SIZE],Ans[3000];
inline void Fac(const int &amp;n,const bool&amp;k) {
    register int i,j;
    for(i=1;i^SIZE;++i)
        for(j=p[i];j&lt;=n;j*=p[i])
            k?(e[i]+=n/j):(e[i]-=n/j);
}
int main() {
    register int n=geti(),i,len=n-2,m=0,t;
    for(i=0;i&lt;n;++i) {
        t=geti();
        if(!t||len&lt;t-1) return puts(&quot;0&quot;),0;
        if(t&lt;0) {++m;continue;}--t;
        Fac(len,1); Fac(t,0); Fac(len-t,0);
        len-=t;
    }
    if(len) {
        for(i=1;(i^SIZE)&amp;&amp;1&lt;m;++i)
            while(!(m%p[i])) m/=p[i],e[i]+=len;
    }
    Ans[1]=len=1;
    for(i=1;i^SIZE;++i)
        while(e[i]--) {
            for(t=1;t&lt;=len;++t) Ans[t]*=p[i];
            for(t=1;t&lt;=len;++t) if(Ans[t]&gt;=ba) Ans[t+1]+=Ans[t]/ba,Ans[t]%=ba;
            while(Ans[len+1]) {
                if(Ans[len]&gt;=ba) Ans[len+1]+=Ans[len]/ba,Ans[len]%=ba;
                ++len;
            }
        }
    for(printf(&quot;%d&quot;,Ans[len]),i=len-1;i;--i) printf(&quot;%04d&quot;,Ans[i]);
    return 0;
}
<pre><h2>Problem1006</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 10005
#define M 3010005
struct E{int to;E*nxt;}CD[M],*cd=CD,*head[N],*st[N];
inline void adde(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=head[a],head[a]=cd++;}
inline void ins(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=st[a],st[a]=cd++;}
int d[N],col[N],q[N],vis[N];
int main() {
	register int n=geti(),m=geti(),i,j,mx,v; E*it;
	while(m--) adde(i=geti(),j=geti()),adde(j,i);
	mx=m=0;
	for(i=1;i&lt;=n;++i) ins(0,i);
	while(m&lt;n) {
		if(!st[mx]) {--mx; continue;}
		if(vis[st[mx]-&gt;to]) {st[mx]=st[mx]-&gt;nxt; continue;}
		v=st[mx]-&gt;to;
		vis[v]=1; q[m++]=v;
		st[mx]=st[mx]-&gt;nxt;
		for(it=head[v];it;it=it-&gt;nxt)
			if(!vis[j=it-&gt;to]) {
				(++d[j]&gt;mx)?mx=d[j]:1;
				ins(d[j],j);
			}
	}
	memset(vis,0,sizeof vis);
	for(mx=0,i=0;i&lt;n;++i) {
		v=q[i];
		for(it=head[v];it;it=it-&gt;nxt)
			vis[col[it-&gt;to]]=v;
		for(j=1;;++j)if(vis[j]^v)break;
		if((col[v]=j)&gt;mx) mx=j;
	}
	printf(&quot;%d\n&quot;,mx);
	return 0;
}
<pre><h2>Problem1006</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 10005
#define M 3000005
struct E{int to;E*nxt;}CD[M],*cd=CD,*head[N],*st[N];
inline void adde(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=head[a],head[a]=cd++;}
inline void ins(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=st[a],st[a]=cd++;}
int d[N],col[N],q[N],vis[N];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1006.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1006.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n=geti(),m=geti(),i,j,mx,v; E*it;
	while(m--) adde(i=geti(),j=geti()),adde(j,i);
	mx=m=0;
	for(i=1;i&lt;=n;++i) ins(0,i);
	while(m&lt;n) {
		if(!st[mx]) {--mx; continue;}
		if(vis[st[mx]-&gt;to]) {st[mx]=st[mx]-&gt;nxt; continue;}
		v=st[mx]-&gt;to;
		vis[v]=1; q[m++]=v;
		st[mx]=st[mx]-&gt;nxt;
		for(it=head[v];it;it=it-&gt;nxt)
			if(!vis[j=it-&gt;to]) {
				(++d[j]&gt;mx)?mx=d[j]:1;
				ins(d[j],j);
			}
	}
	memset(vis,0,sizeof vis);
	for(mx=0,i=0;i&lt;n;++i) {
		v=q[i];
		for(it=head[v];it;it=it-&gt;nxt)
			vis[col[it-&gt;to]]=v;
		for(j=1;;++j)if(vis[j]^v)break;
		if((col[v]=j)&gt;mx) mx=j;
	}
	printf(&quot;%d\n&quot;,mx);
	return 0;
}
<pre><h2>Problem1006</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 10005
#define M 3000005
struct E{int to;E*nxt;}CD[M],*cd=CD,*head[N],*st[N];
inline void adde(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=head[a],head[a]=cd++;}
inline void ins(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=st[a],st[a]=cd++;}
int d[N],col[N],q[N],vis[N];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1006.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1006.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n=geti(),m=geti(),i,j,mx,v; E*it;
	while(m--) adde(i=geti(),j=geti()),adde(j,i);
	mx=m=0;
	for(i=1;i&lt;=n;++i) ins(0,i);
	while(m^n) {
		if(!st[mx]) {--mx; continue;}
		if(vis[st[mx]-&gt;to]) {st[mx]=st[mx]-&gt;nxt; continue;}
		v=st[mx]-&gt;to;
		vis[v]=-1; q[m++]=v;
		st[mx]=st[mx]-&gt;nxt;
		for(it=head[v];it;it=it-&gt;nxt)
			if(~vis[j=it-&gt;to]) {
				(++d[j]&gt;mx)?mx=d[j]:1;
				ins(d[j],j);
			}
	}
	for(mx=0,i=0;i^n;++i) {
		v=q[i];
		for(it=head[v];it;it=it-&gt;nxt)
			vis[col[it-&gt;to]]=v;
		for(j=1;;++j)if(vis[j]^v)break;
		if((col[v]=j)&gt;mx) mx=j;
	}
	printf(&quot;%d\n&quot;,mx);
	return 0;
}
<pre><h2>Problem1006</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 10005
#define M 3000005
struct E{int to;E*nxt;}CD[M],*cd=CD,*head[N],*st[N];
inline void adde(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=head[a],head[a]=cd++;}
inline void ins(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=st[a],st[a]=cd++;}
int d[N],col[N],q[N],vis[N];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1006.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1006.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n=geti(),m=geti(),i,j,mx,v; E*it;
	while(m--) adde(i=geti(),j=geti()),adde(j,i);
	mx=m=0;
	for(i=1;i&lt;=n;++i) ins(0,i);
	while(m^n) {
		if(!st[mx]) {--mx; continue;}
		if(vis[st[mx]-&gt;to]) {st[mx]=st[mx]-&gt;nxt; continue;}
		v=st[mx]-&gt;to;
		vis[v]=-1; q[m++]=v;
		st[mx]=st[mx]-&gt;nxt;
		for(it=head[v];it;it=it-&gt;nxt)
			if(!vis[j=it-&gt;to]) {
				(++d[j]&gt;mx)?mx=d[j]:1;
				ins(d[j],j);
			}
	}
	for(mx=0,i=0;i^n;++i) {
		v=q[i];
		for(it=head[v];it;it=it-&gt;nxt)
			vis[col[it-&gt;to]]=v;
		for(j=1;;++j)if(vis[j]^v)break;
		if((col[v]=j)&gt;mx) mx=j;
	}
	printf(&quot;%d\n&quot;,mx);
	return 0;
}
<pre><h2>Problem1006</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 10005
#define M 3000005
struct E{int to;E*nxt;}CD[M],*cd=CD,*head[N],*st[N];
inline void adde(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=head[a],head[a]=cd++;}
inline void ins(int a,int b) {cd-&gt;to=b,cd-&gt;nxt=st[a],st[a]=cd++;}
int d[N],col[N],q[N],vis[N];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1006.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1006.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n=geti(),m=geti(),i,j,mx,v; E*it;
	while(m--) adde(i=geti(),j=geti()),adde(j,i);
	mx=m=0;
	for(i=1;i&lt;=n;++i) ins(0,i);
	while(m&lt;n) {
		if(!st[mx]) {--mx; continue;}
		if(vis[st[mx]-&gt;to]) {st[mx]=st[mx]-&gt;nxt; continue;}
		v=st[mx]-&gt;to;
		vis[v]=-1; q[m++]=v;
		st[mx]=st[mx]-&gt;nxt;
		for(it=head[v];it;it=it-&gt;nxt)
			if(!vis[j=it-&gt;to]) {
				if(++d[j]&gt;mx)mx=d[j];
				ins(d[j],j);
			}
	}
	for(mx=0,i=0;i&lt;n;++i) {
		v=q[i];
		for(it=head[v];it;it=it-&gt;nxt)
			vis[col[it-&gt;to]]=v;
		for(j=1;;++j)if(vis[j]^v)break;
		if((col[v]=j)&gt;mx) mx=j;
	}
	printf(&quot;%d\n&quot;,mx);
	return 0;
}
<pre><h2>Problem1006</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 10005
#define M 3000005
struct E{int to;E*nxt;}CD[M],*cd=CD,*head[N],*st[N];
inline void adde(int a,int b){cd-&gt;to=b,cd-&gt;nxt=head[a],head[a]=cd++;}
inline void ins(int a,int b){cd-&gt;to=b,cd-&gt;nxt=st[a],st[a]=cd++;}
int d[N],col[N],q[N],vis[N];
int main() {
	register int n=geti(),m=geti(),i,j,mx,v; E*it;
	while(m--) adde(i=geti(),j=geti()),adde(j,i);
	mx=m=0;
	for(i=1;i&lt;=n;++i) ins(0,i);
	while(m&lt;n) {
		if(!st[mx]) {--mx; continue;}
		if(vis[st[mx]-&gt;to]) {st[mx]=st[mx]-&gt;nxt; continue;}
		v=st[mx]-&gt;to;
		vis[v]=-1; q[m++]=v;
		st[mx]=st[mx]-&gt;nxt;
		for(it=head[v];it;it=it-&gt;nxt)
			if(!vis[j=it-&gt;to]) {
				if(++d[j]&gt;mx)mx=d[j];
				ins(d[j],j);
			}
	}
	for(mx=0,i=0;i&lt;n;++i) {
		v=q[i];
		for(it=head[v];it;it=it-&gt;nxt)
			vis[col[it-&gt;to]]=v;
		for(j=1;vis[j]==v;++j);
		if((col[v]=j)&gt;mx) mx=j;
	}
	printf(&quot;%d\n&quot;,mx);
	return 0;
}
<pre><h2>Problem1007</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0'||'9'&lt;c)f|=c=='-';a=c-'0';
	while(c=getc(),!(c&lt;'0'||'9'&lt;c))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 50005
struct D{int a,b,id;}p[N],sta[N];
inline bool cmp(const D&amp;x,const D&amp;y){return (x.a^y.a)?x.a&lt;y.a:x.b&lt;y.b;}
bool ans[N];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1007.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1007.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n=geti(),i,tp;
	register D x;
	for(i=1;i&lt;=n;++i){
		p[i].a=geti();
		p[i].b=geti();
		p[i].id=i;
	}
	std::sort(p+1,p+n+1,cmp);
	sta[tp=0].a=0x7f7f7f7f;
	for(i=1;i&lt;=n;++i) {
		for(x=p[i];tp;) {
			if(sta[tp].a==x.a) --tp;
			if(1&lt;tp&amp;&amp;(sta[tp-1].b-x.b+0LL)*(sta[tp].a-sta[tp-1].a+0LL)&lt;=(sta[tp-1].b-sta[tp].b+0LL)*(x.a-sta[tp-1].a+0LL))--tp;
			else break;
		}
		sta[++tp]=x;
	}
	for(i=1;i&lt;=tp;++i)ans[sta[i].id]=1;
	for(i=1;i&lt;=n;++i)if(ans[i])printf(&quot;%d &quot;,i);
	return 0;
}
<pre><h2>Problem1007</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins&gt;=ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins&gt;=ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 50005
struct D{int a,b,id;}p[N],sta[N];
inline bool cmp(const D&amp;x,const D&amp;y){return (x.a^y.a)?x.a&lt;y.a:x.b&lt;y.b;}
bool ans[N];
int main() {
	register int n=geti(),i,tp;
	register D x;
	for(i=0;i&lt;n;++i){
		p[i].a=geti();
		p[i].b=geti();
		p[i].id=i+1;
	}
	std::sort(p,p+n,cmp);
	sta[tp=0].a=0x7f7f7f7f;
	for(i=0;i&lt;n;++i) {
		for(x=p[i];tp;) {
			if(sta[tp].a==x.a) --tp;
			if(1&lt;tp&amp;&amp;(sta[tp-1].b-x.b+0LL)*(sta[tp].a-sta[tp-1].a+0LL)&lt;=(sta[tp-1].b-sta[tp].b+0LL)*(x.a-sta[tp-1].a+0LL))--tp;
			else break;
		}
		sta[++tp]=x;
	}
	for(i=1;i&lt;=tp;++i)ans[sta[i].id]=1;
	for(i=1;i&lt;=n;++i)if(ans[i])printf(&quot;%d &quot;,i);
	return 0;
}
<pre><h2>Problem1007</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins&gt;=ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins&gt;=ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 50005
struct D{int a,b,id;}p[N],sta[N];
inline bool operator &lt; (const D&amp;x,const D&amp;y){return (x.a^y.a)?x.a&lt;y.a:x.b&lt;y.b;}
bool ans[N];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1007.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1007.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n=geti(),i,tp;
	register D x;
	for(i=1;i&lt;=n;++i){
		p[i].a=geti();
		p[i].b=geti();
		p[i].id=i;
	}
	std::sort(p+1,p+n+1);
	sta[tp=0].a=0x7f7f7f7f;
	for(i=1;i&lt;=n;++i) {
		for(x=p[i];tp;) {
			if(sta[tp].a==x.a) --tp;
			if(1&lt;tp&amp;&amp;(sta[tp-1].b-x.b+0LL)*(sta[tp].a-sta[tp-1].a+0LL)&lt;=(sta[tp-1].b-sta[tp].b+0LL)*(x.a-sta[tp-1].a+0LL))--tp;
			else break;
		}
		sta[++tp]=x;
	}
	for(i=1;i&lt;=tp;++i)ans[sta[i].id]=1;
	for(i=1;i&lt;=n;++i)if(ans[i])printf(&quot;%d &quot;,i);
	return 0;
}
<pre><h2>Problem1007</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins&gt;=ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins&gt;=ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 50005
struct D{int a,b,id;}p[N],sta[N];
inline bool operator &lt; (const D&amp;x,const D&amp;y){return (x.a^y.a)?x.a&lt;y.a:x.b&lt;y.b;}
bool ans[N]; char oub[N&lt;&lt;3],ous[10],*oue=oub;
inline void outi(int x) {
	register char tp=0;
	while(x)ous[++tp]=x%10,x/=10;
	for(;tp;--tp)*oue++=ous[tp]+'0';
	*oue++=' ';
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1007.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1007.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n=geti(),i,tp;
	register D x;
	for(i=1;i&lt;=n;++i){
		p[i].a=geti();
		p[i].b=geti();
		p[i].id=i;
	}
	std::sort(p+1,p+n+1);
	sta[tp=0].a=0x7f7f7f7f;
	for(i=1;i&lt;=n;++i) {
		for(x=p[i];tp;) {
			if(sta[tp].a==x.a) --tp;
			if(1&lt;tp&amp;&amp;(sta[tp-1].b-x.b+0LL)*(sta[tp].a-sta[tp-1].a+0LL)&lt;=(sta[tp-1].b-sta[tp].b+0LL)*(x.a-sta[tp-1].a+0LL))--tp;
			else break;
		}
		sta[++tp]=x;
	}
	for(i=1;i&lt;=tp;++i)ans[sta[i].id]=1;
	for(i=1;i&lt;=n;++i)if(ans[i])outi(i);
	puts(oub);
	return 0;
}
<pre><h2>Problem1007</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins&gt;=ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins&gt;=ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 50005
struct D{int a,b,id;}p[N],sta[N];
inline bool operator &lt; (const D&amp;x,const D&amp;y){return (x.a^y.a)?x.a&lt;y.a:x.b&lt;y.b;}
bool ans[N]; char oub[N&lt;&lt;3],ous[10],*oue=oub;
inline void outi(int x) {
	register char tp=0;
	while(x)ous[++tp]=x%10,x/=10;
	for(;tp;--tp)*oue++=ous[tp]+'0';
	*oue++=' ';
}
int main() {
	register int n=geti(),i,tp;
	register D x;
	for(i=1;i&lt;=n;++i){
		p[i].a=geti();
		p[i].b=geti();
		p[i].id=i;
	}
	std::sort(p+1,p+n+1);
	sta[tp=0].a=0x7f7f7f7f;
	for(i=1;i&lt;=n;++i) {
		for(x=p[i];tp;) {
			if(sta[tp].a==x.a) --tp;
			if(1&lt;tp&amp;&amp;(sta[tp-1].b-x.b+0LL)*(sta[tp].a-sta[tp-1].a+0LL)&lt;=(sta[tp-1].b-sta[tp].b+0LL)*(x.a-sta[tp-1].a+0LL))--tp;
			else break;
		}
		sta[++tp]=x;
	}
	for(i=1;i&lt;=tp;++i)ans[sta[i].id]=1;
	for(i=1;i&lt;=n;++i)if(ans[i])outi(i);
	fwrite(oub,1,oue-oub,stdout);
	return 0;
}
<pre><h2>Problem1008</h2><pre>#include &lt;cstdio&gt;
const long long mo=100003;
inline long long pow(long long b,long long n) {
	register long long r=1LL;
	for(;n;n&gt;&gt;=1,b=b*b%mo) if(n&amp;1) r=r*b%mo;
	return r;
}
int main() {
	long long n,m,ans;
	scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);
	m%=mo;
	ans=pow(m,n);
	ans-=m*pow(m-1,n-1);
	ans%=mo;
	if(ans&lt;0) ans+=mo;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1009</h2><pre>#include &lt;cstdio&gt;
int n,m,mo,a[25][25],b[25][25],c[25][25],nxt[25];
char s[25];
#define inc(a,b) for(a+=b;a&gt;=mo;a-=mo)
inline void mul(int (&amp;x)[25][25],int (&amp;y)[25][25]) {
	register int i,j,k;
	for(i=0;i&lt;m;++i)
		for(j=0;j&lt;m;++j) {
			c[i][j]=0;
			for(k=0;k&lt;m;++k)
				c[i][j]=(c[i][j]+x[i][k]*y[k][j])%mo;
		}
	for(i=0;i&lt;m;++i)
		for(j=0;j&lt;m;++j)
			x[i][j]=c[i][j];
}
int main() {
	register int i,j=0,t;
	for(scanf(&quot;%d%d%d%s&quot;,&amp;n,&amp;m,&amp;mo,s+1),i=2;i&lt;=m;++i) {
		while(j&amp;&amp;(s[j+1]^s[i]))j=nxt[j];
		nxt[i]=(s[i]==s[j+1])?(++j):j;
	}
	for(i=0;i&lt;m;++i)
		for(j=0;j&lt;10;++j) {
			for(t=i;t&amp;&amp;(s[t+1]^j+'0');t=nxt[t]);
			if(((s[t+1]==j+'0')?++t:t)^m)++b[t][i]&lt;mo?1:b[t][i]=0;
		}
	for(i=0;i&lt;m;++i)a[i][i]=1;
	for(;n;n&gt;&gt;=1,mul(b,b))if(n&amp;1)mul(a,b);
	for(t=0,i=0;i&lt;m;++i)inc(t,a[i][0]);
	return printf(&quot;%d\n&quot;,t),0;
}
<pre><h2>Problem1010</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 50005
long long g[N],dp[N],C; int q[N];
inline long long S(int i,int j){return (g[i]-g[j])&lt;&lt;1;}
inline long long G(int i,int j){return dp[i]-dp[j]+(g[i]-g[j])*(g[i]+g[j]+(C&lt;&lt;1));}
int main() {
	register int n=geti(),i,j,l=1,r=1;
	C=geti()+1;
	register long long s=0;
	q[1]=0;
	for(i=1;i&lt;=n;++i) {
		s+=geti(); g[i]=s+i;
		while(l&lt;r&amp;&amp;G(q[l+1],q[l])&lt;=S(q[l+1],q[l])*g[i])++l;
		j=q[l];
		dp[i]=dp[j]+(g[i]-g[j]-C)*(g[i]-g[j]-C);
		while(l&lt;r&amp;&amp;G(i,q[r])*S(q[r],q[r-1])&lt;=G(q[r],q[r-1])*S(i,q[r]))--r;
		q[++r]=i;
	}
	printf(&quot;%lld\n&quot;,dp[n]);
	return 0;
}
<pre><h2>Problem1011</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 100002
#define t 30
int m[N]; double f[N];
int main() {
	register int i,j,l,r,n=geti();
	double a; scanf(&quot;%lf&quot;,&amp;a);
	for(i=1;i&lt;=n;++i)m[i]=geti(),f[i]=0.0;
	for(i=1;i&lt;=t;++i)
		for(j=1,r=floor(a*i);j&lt;=r;++j)
			f[i]+=1.0*m[i]*m[j]/(i-j);
	for(i=t+1;i&lt;=n;++i) {
		l=floor(a*(i-t)),r=floor(a*i);
		for(j=l+1;j&lt;=r;++j) f[i]+=1.0*m[i]*m[j]/(i-j);
		f[i]+=m[i]*f[i-t]/m[i-t]*(i-t-1.0*l/2)/(i-1.0*l/2);
	}
	for(i=1;i&lt;=n;++i) printf(&quot;%.6lf\n&quot;,f[i]);
	return 0;
}
<pre><h2>Problem1011</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 100002
#define t 20
int m[N]; double f[N];
int main() {
	register int i,j,l,r,n=geti();
	double a; scanf(&quot;%lf&quot;,&amp;a);
	for(i=1;i&lt;=n;++i)m[i]=geti(),f[i]=0.0;
	for(i=1;i&lt;=t;++i)
		for(j=1,r=floor(a*i);j&lt;=r;++j)
			f[i]+=1.0*m[i]*m[j]/(i-j);
	for(i=t+1;i&lt;=n;++i) {
		l=floor(a*(i-t)),r=floor(a*i);
		for(j=l+1;j&lt;=r;++j) f[i]+=1.0*m[i]*m[j]/(i-j);
		f[i]+=m[i]*f[i-t]/m[i-t]*(i-t-1.0*l/2)/(i-1.0*l/2);
	}
	for(i=1;i&lt;=n;++i) printf(&quot;%.6lf\n&quot;,f[i]);
	return 0;
}
<pre><h2>Problem1012</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int q[200001],v[200001];
int main() {
	register int m=geti(),d=geti(),t=0,x,len=0,tp=0;
	register char c;
	while(m--) {
		while(c=getchar(),c&lt;'A'); x=geti();
		if(c^'A')
printf(&quot;%d\n&quot;,t=v[*std::lower_bound(q+1,q+tp+1,len-x+1)]);
		else {
			x=(x+t)%d; v[++len]=x;
			while(tp&amp;&amp;v[q[tp]]&lt;=x)--tp;
			q[++tp]=len;
		}
	}
	return 0;
}
<pre><h2>Problem1013</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
int n; double a[11][11],p[11];
inline void guass() {
	register int i,j,k,id; register double mx,t;
	for(i=0;i&lt;n;++i) {
		mx=-1;
		for(j=i;j&lt;n;++j) if(mx&lt;fabs(a[j][i]))mx=a[id=j][i];
		if(i^id)for(j=i;j&lt;=n;++j)std::swap(a[i][j],a[id][j]);
		t=a[i][i];
		for(j=i+1;j&lt;=n;++j) a[i][j]/=t;
		for(j=0;j&lt;n;++j)
			if(i^j) for(t=a[j][i],k=1;k&lt;=n;++k)
						a[j][k]-=t*a[i][k];
	}
}
int main() {
	register int i,j;
	double t;
	scanf(&quot;%d&quot;,&amp;n);
	for(i=0;i&lt;n;++i)scanf(&quot;%lf&quot;,p+i);
	for(i=0;i&lt;n;++i)
	for(j=0;j&lt;n;++j) {
		scanf(&quot;%lf&quot;,&amp;t);
		a[i][j]=2*(t-p[j]);
		a[i][n]+=t*t-p[j]*p[j];
	}
	guass();
	for(i=0;i&lt;n;++i)printf(&quot;%.3lf%c&quot;,a[i][n],&quot;\n &quot;[i+1&lt;n]);
	return 0;
}
<pre><h2>Problem1013</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
int n; double a[11][11],p[11];
inline void guass() {
	register int i,j,k,id; register double mx,t;
	for(i=0;i&lt;n;++i) {
		mx=-1;
		for(j=i;j&lt;n;++j) if(mx&lt;fabs(a[j][i]))mx=a[id=j][i];
		if(i^id)for(j=i;j&lt;=n;++j)std::swap(a[i][j],a[id][j]);
		t=a[i][i];
		for(j=i;j&lt;=n;++j) a[i][j]/=t;
		for(j=0;j&lt;n;++j)
			if(i^j)for(t=a[j][i],k=1;k&lt;=n;++k)
					   a[j][k]-=t*a[i][k];
	}
}
int main() {
	register int i,j;
	double t;
	scanf(&quot;%d&quot;,&amp;n);
	for(i=0;i&lt;n;++i)scanf(&quot;%lf&quot;,p+i);
	for(i=0;i&lt;n;++i)
	for(j=0;j&lt;n;++j) {
		scanf(&quot;%lf&quot;,&amp;t);
		a[i][j]=2*(t-p[j]);
		a[i][n]+=t*t-p[j]*p[j];
	}
	guass();
	for(i=0;i&lt;n;++i)printf(&quot;%.3lf%c&quot;,a[i][n],&quot;\n &quot;[i+1&lt;n]);
	return 0;
}<pre><h2>Problem1014</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define ui unsigned int
#define N 150000
#define ba 257
ui p[N];
struct node {
	ui ha; int siz; char c;
	node *fa,*ch[2];
}CD[N],*cd=CD,*root,*nil;
inline void maintain(node*(&amp;u)) {
	if(u==nil) return;
	u-&gt;siz=u-&gt;ch[0]-&gt;siz+u-&gt;ch[1]-&gt;siz+1;
	u-&gt;ha=u-&gt;ch[0]-&gt;ha+u-&gt;c*p[u-&gt;ch[0]-&gt;siz]+u-&gt;ch[1]-&gt;ha*p[u-&gt;ch[0]-&gt;siz+1];
}
inline void rot(node*(&amp;u)) {
	node *f=u-&gt;fa,*ff=f-&gt;fa;
	int d=u==f-&gt;ch[1];
	if((f-&gt;ch[d]=u-&gt;ch[d^1])!=nil) f-&gt;ch[d]-&gt;fa=f;
	f-&gt;fa=u,u-&gt;ch[d^1]=f;
	if((u-&gt;fa=ff)!=nil) ff-&gt;ch[f==ff-&gt;ch[1]]=u;
	maintain(f);maintain(u);
}
inline void splay(node*(&amp;u),node*(&amp;target)) {
	while(u-&gt;fa!=target){
		if(u-&gt;fa-&gt;fa==target){rot(u);break;}
		if((u==u-&gt;fa-&gt;ch[1])^(u-&gt;fa==u-&gt;fa-&gt;fa-&gt;ch[1]))rot(u);
		else rot(u-&gt;fa);rot(u);
	}if(target==nil)root=u;
}
inline node*kth(int k){
	node*u=root;
	while(k&amp;&amp;u!=nil){
		if(u-&gt;ch[0]-&gt;siz&gt;=k)u=u-&gt;ch[0];
		else if(u-&gt;ch[0]-&gt;siz+1==k) return u;
		else k-=u-&gt;ch[0]-&gt;siz+1,u=u-&gt;ch[1];
	}return u;
}
inline void ins(int k,char ch) {
	node *l=kth(k); cd-&gt;c=ch;
	cd-&gt;ch[0]=nil,cd-&gt;ch[1]=l-&gt;ch[1];
	cd-&gt;fa=l,cd-&gt;ch[1]-&gt;fa=cd;
	l-&gt;ch[1]=cd; maintain(cd);
	while(l!=nil) {maintain(l);l=l-&gt;fa;}
	++cd;
}
inline void upd(int k,char ch){
	node*u=kth(k);u-&gt;c=ch;
	while(u!=nil){maintain(u);u=u-&gt;fa;}
}
inline ui quy(int l,int r){
	node*lu=kth(l-1),*ru=kth(r+1);
	splay(lu,nil);splay(ru,lu);
	return ru-&gt;ch[0]-&gt;ha;
}
char initstring[N];
node*build(int l,int r){
	if(l&gt;r)return nil;
	int m=l+r&gt;&gt;1;node*u=cd++;
	u-&gt;c=initstring[m];
	if((u-&gt;ch[0]=build(l,m-1))!=nil)u-&gt;ch[0]-&gt;fa=u;
	if((u-&gt;ch[1]=build(m+1,r))!=nil)u-&gt;ch[1]-&gt;fa=u;
	maintain(u);return u;
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1014.in&quot;,&quot;r&quot;,stdin);
#endif
	initstring[1]='~';
	scanf(&quot;%s&quot;,initstring+2);
	register int cl=strlen(initstring+2),i,j,mi,l,r,an,m;
	for(*p=i=1;i^N;++i)p[i]=p[i-1]*ba;
	initstring[cl+2]='!';
	cd-&gt;fa=cd-&gt;ch[0]=cd-&gt;ch[1]=cd;
	cd-&gt;ha=cd-&gt;siz=cd-&gt;c=0;nil=cd++;
	root=build(1,cl+2);root-&gt;fa=nil;
	register char ch;
	for(m=geti();m;--m){
		while(ch=getchar(),ch&lt;'A');
		if(ch=='Q'){
			i=geti()+1,j=geti()+1;
			if(kth(i)-&gt;c!=kth(j)-&gt;c){puts(&quot;0&quot;);continue;}
			for(an=l=1,r=cl-(i&lt;j?j:i)+2;l&lt;=r;){
				mi=l+r&gt;&gt;1;
				if(quy(i,i+mi-1)==quy(j,j+mi-1))l=(an=mi)+1;
				else r=mi-1;
			}printf(&quot;%d\n&quot;,an);
		}else{
			j=ch=='R';cl+=j^1;
			i=geti()+1;while(ch=getchar(),ch&lt;'a');
			j?upd(i,ch):ins(i,ch);
		}
	}return 0;
}
<pre><h2>Problem1014</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define ui unsigned int
#define N 100050
#define ba 257
ui p[N];
struct node {
	ui ha; int siz; char c;
	node *fa,*ch[2];
}CD[N],*cd=CD,*root,*nil;
inline void maintain(node*(&amp;u)) {
	if(u==nil) return;
	u-&gt;siz=u-&gt;ch[0]-&gt;siz+u-&gt;ch[1]-&gt;siz+1;
	u-&gt;ha=u-&gt;ch[0]-&gt;ha+u-&gt;c*p[u-&gt;ch[0]-&gt;siz]+u-&gt;ch[1]-&gt;ha*p[u-&gt;ch[0]-&gt;siz+1];
}
inline void rot(node*(&amp;u)) {
	node *f=u-&gt;fa,*ff=f-&gt;fa;
	int d=u==f-&gt;ch[1];
	if((f-&gt;ch[d]=u-&gt;ch[d^1])!=nil) f-&gt;ch[d]-&gt;fa=f;
	f-&gt;fa=u,u-&gt;ch[d^1]=f;
	if((u-&gt;fa=ff)!=nil) ff-&gt;ch[f==ff-&gt;ch[1]]=u;
	maintain(f);maintain(u);
}
inline void splay(node*(&amp;u),node*(&amp;target)) {
	while(u-&gt;fa!=target){
		if(u-&gt;fa-&gt;fa==target){rot(u);break;}
		if((u==u-&gt;fa-&gt;ch[1])^(u-&gt;fa==u-&gt;fa-&gt;fa-&gt;ch[1]))rot(u);
		else rot(u-&gt;fa);rot(u);
	}if(target==nil)root=u;
}
inline node*kth(int k){
	node*u=root;
	while(k&amp;&amp;u!=nil){
		if(u-&gt;ch[0]-&gt;siz&gt;=k)u=u-&gt;ch[0];
		else if(u-&gt;ch[0]-&gt;siz+1==k) return u;
		else k-=u-&gt;ch[0]-&gt;siz+1,u=u-&gt;ch[1];
	}return u;
}
inline void ins(int k,char ch) {
	node *l=kth(k); cd-&gt;c=ch;
	cd-&gt;ch[0]=nil,cd-&gt;ch[1]=l-&gt;ch[1];
	cd-&gt;fa=l,cd-&gt;ch[1]-&gt;fa=cd;
	l-&gt;ch[1]=cd; maintain(cd);
	while(l!=nil) {maintain(l);l=l-&gt;fa;}
	++cd;
}
inline void upd(int k,char ch){
	node*u=kth(k);u-&gt;c=ch;
	while(u!=nil){maintain(u);u=u-&gt;fa;}
}
inline ui quy(int l,int r){
	node*lu=kth(l-1),*ru=kth(r+1);
	splay(lu,nil);splay(ru,lu);
	return ru-&gt;ch[0]-&gt;ha;
}
char initstring[N];
node*build(int l,int r){
	if(l&gt;r)return nil;
	int m=l+r&gt;&gt;1;node*u=cd++;
	u-&gt;c=initstring[m];
	if((u-&gt;ch[0]=build(l,m-1))!=nil)u-&gt;ch[0]-&gt;fa=u;
	if((u-&gt;ch[1]=build(m+1,r))!=nil)u-&gt;ch[1]-&gt;fa=u;
	maintain(u);return u;
}
int main() {
	initstring[1]='~';
	scanf(&quot;%s&quot;,initstring+2);
	register int cl=strlen(initstring+2),i,j,mi,l,r,an,m;
	for(*p=i=1;i^N;++i)p[i]=p[i-1]*ba;
	initstring[cl+2]='!';
	cd-&gt;fa=cd-&gt;ch[0]=cd-&gt;ch[1]=cd;
	cd-&gt;ha=cd-&gt;siz=cd-&gt;c=0;nil=cd++;
	root=build(1,cl+2);root-&gt;fa=nil;
	register char ch;
	for(m=geti();m;--m){
		while(ch=getchar(),ch&lt;'A');
		if(ch=='Q'){
			i=geti()+1,j=geti()+1;
			if(kth(i)-&gt;c!=kth(j)-&gt;c){puts(&quot;0&quot;);continue;}
			for(an=l=1,r=cl-(i&lt;j?j:i)+2;l&lt;=r;){
				mi=l+r&gt;&gt;1;
				if(quy(i,i+mi-1)==quy(j,j+mi-1))l=(an=mi)+1;
				else r=mi-1;
			}printf(&quot;%d\n&quot;,an);
		}else{
			j=ch=='R';cl+=j^1;
			i=geti()+1;while(ch=getchar(),ch&lt;'a');
			j?upd(i,ch):ins(i,ch);
		}
	}return 0;
}
<pre><h2>Problem1014</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define ui unsigned int
#define N 100010
#define ba 257
ui p[N];
struct node {
	ui ha; int siz; char c;
	node *fa,*ch[2];
}CD[N],*cd=CD,*root,*nil;
inline void maintain(node*(&amp;u)) {
	if(u==nil) return;
	u-&gt;siz=u-&gt;ch[0]-&gt;siz+u-&gt;ch[1]-&gt;siz+1;
	u-&gt;ha=u-&gt;ch[0]-&gt;ha+u-&gt;c*p[u-&gt;ch[0]-&gt;siz]+u-&gt;ch[1]-&gt;ha*p[u-&gt;ch[0]-&gt;siz+1];
}
inline void rot(node*(&amp;u)) {
	node *f=u-&gt;fa,*ff=f-&gt;fa;
	int d=u==f-&gt;ch[1];
	if((f-&gt;ch[d]=u-&gt;ch[d^1])!=nil) f-&gt;ch[d]-&gt;fa=f;
	f-&gt;fa=u,u-&gt;ch[d^1]=f;
	if((u-&gt;fa=ff)!=nil) ff-&gt;ch[f==ff-&gt;ch[1]]=u;
	maintain(f);maintain(u);
}
inline void splay(node*(&amp;u),node*(&amp;target)) {
	while(u-&gt;fa!=target){
		if(u-&gt;fa-&gt;fa==target){rot(u);break;}
		if((u==u-&gt;fa-&gt;ch[1])^(u-&gt;fa==u-&gt;fa-&gt;fa-&gt;ch[1]))rot(u);
		else rot(u-&gt;fa);rot(u);
	}if(target==nil)root=u;
}
inline node*kth(int k){
	node*u=root;
	while(k&amp;&amp;u!=nil){
		if(u-&gt;ch[0]-&gt;siz&gt;=k)u=u-&gt;ch[0];
		else if(u-&gt;ch[0]-&gt;siz+1==k) return u;
		else k-=u-&gt;ch[0]-&gt;siz+1,u=u-&gt;ch[1];
	}return u;
}
inline void ins(int k,char ch) {
	node *l=kth(k); cd-&gt;c=ch;
	cd-&gt;ch[0]=nil,cd-&gt;ch[1]=l-&gt;ch[1];
	cd-&gt;fa=l,cd-&gt;ch[1]-&gt;fa=cd;
	l-&gt;ch[1]=cd; maintain(cd);
	while(l!=nil) {maintain(l);l=l-&gt;fa;}
	++cd;
}
inline void upd(int k,char ch){
	node*u=kth(k);u-&gt;c=ch;
	while(u!=nil){maintain(u);u=u-&gt;fa;}
}
inline ui quy(int l,int r){
	node*lu=kth(l-1),*ru=kth(r+1);
	splay(lu,nil);splay(ru,lu);
	return ru-&gt;ch[0]-&gt;ha;
}
char initstring[N];
node*build(int l,int r){
	if(l&gt;r)return nil;
	int m=l+r&gt;&gt;1;node*u=cd++;
	u-&gt;c=initstring[m];
	if((u-&gt;ch[0]=build(l,m-1))!=nil)u-&gt;ch[0]-&gt;fa=u;
	if((u-&gt;ch[1]=build(m+1,r))!=nil)u-&gt;ch[1]-&gt;fa=u;
	maintain(u);return u;
}
int main() {
	initstring[1]='~';
	scanf(&quot;%s&quot;,initstring+2);
	register int cl=strlen(initstring+2),i,j,mi,l,r,an,m;
	for(*p=i=1;i^N;++i)p[i]=p[i-1]*ba;
	initstring[cl+2]='!';
	cd-&gt;fa=cd-&gt;ch[0]=cd-&gt;ch[1]=cd;
	cd-&gt;ha=cd-&gt;siz=cd-&gt;c=0;nil=cd++;
	root=build(1,cl+2);root-&gt;fa=nil;
	register char ch;
	for(m=geti();m;--m){
		while(ch=getchar(),ch&lt;'A');
		if(ch=='Q'){
			i=geti()+1,j=geti()+1;
			if(kth(i)-&gt;c!=kth(j)-&gt;c){puts(&quot;0&quot;);continue;}
			for(an=l=1,r=cl-(i&lt;j?j:i)+2;l&lt;=r;){
				mi=l+r&gt;&gt;1;
				if(quy(i,i+mi-1)==quy(j,j+mi-1))l=(an=mi)+1;
				else r=mi-1;
			}printf(&quot;%d\n&quot;,an);
		}else{
			j=ch=='R';cl+=j^1;
			i=geti()+1;while(ch=getchar(),ch&lt;'a');
			j?upd(i,ch):ins(i,ch);
		}
	}return 0;
}
<pre><h2>Problem1014</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define ui unsigned int
#define N 100100
#define ba 257
ui p[N];
struct node {
	ui ha; int siz; char c;
	node *fa,*ch[2];
}CD[N],*cd=CD,*root,*nil;
inline void maintain(node*(&amp;u)) {
	if(u==nil) return;
	u-&gt;siz=u-&gt;ch[0]-&gt;siz+u-&gt;ch[1]-&gt;siz+1;
	u-&gt;ha=u-&gt;ch[0]-&gt;ha+u-&gt;c*p[u-&gt;ch[0]-&gt;siz]+u-&gt;ch[1]-&gt;ha*p[u-&gt;ch[0]-&gt;siz+1];
}
inline void rot(node*(&amp;u)) {
	node *f=u-&gt;fa,*ff=f-&gt;fa;
	int d=u==f-&gt;ch[1];
	if((f-&gt;ch[d]=u-&gt;ch[d^1])!=nil) f-&gt;ch[d]-&gt;fa=f;
	f-&gt;fa=u,u-&gt;ch[d^1]=f;
	if((u-&gt;fa=ff)!=nil) ff-&gt;ch[f==ff-&gt;ch[1]]=u;
	maintain(f);maintain(u);
}
inline void splay(node*(&amp;u),node*(&amp;target)) {
	while(u-&gt;fa!=target){
		if(u-&gt;fa-&gt;fa==target){rot(u);break;}
		if((u==u-&gt;fa-&gt;ch[1])^(u-&gt;fa==u-&gt;fa-&gt;fa-&gt;ch[1]))rot(u);
		else rot(u-&gt;fa);rot(u);
	}if(target==nil)root=u;
}
inline node*kth(int k){
	node*u=root;
	while(k&amp;&amp;u!=nil){
		if(u-&gt;ch[0]-&gt;siz&gt;=k)u=u-&gt;ch[0];
		else if(u-&gt;ch[0]-&gt;siz+1==k) return u;
		else k-=u-&gt;ch[0]-&gt;siz+1,u=u-&gt;ch[1];
	}return u;
}
inline void ins(int k,char ch) {
	node *l=kth(k); cd-&gt;c=ch;
	cd-&gt;ch[0]=nil,cd-&gt;ch[1]=l-&gt;ch[1];
	cd-&gt;fa=l,cd-&gt;ch[1]-&gt;fa=cd;
	l-&gt;ch[1]=cd; maintain(cd);
	while(l!=nil) {maintain(l);l=l-&gt;fa;}
	++cd;
}
inline void upd(int k,char ch){
	node*u=kth(k);u-&gt;c=ch;
	while(u!=nil){maintain(u);u=u-&gt;fa;}
}
inline ui quy(int l,int r){
	node*lu=kth(l-1),*ru=kth(r+1);
	splay(lu,nil);splay(ru,lu);
	return ru-&gt;ch[0]-&gt;ha;
}
char initstring[N];
node*build(int l,int r){
	if(l&gt;r)return nil;
	int m=l+r&gt;&gt;1;node*u=cd++;
	u-&gt;c=initstring[m];
	if((u-&gt;ch[0]=build(l,m-1))!=nil)u-&gt;ch[0]-&gt;fa=u;
	if((u-&gt;ch[1]=build(m+1,r))!=nil)u-&gt;ch[1]-&gt;fa=u;
	maintain(u);return u;
}
int main() {
	initstring[1]='~';
	scanf(&quot;%s&quot;,initstring+2);
	register int cl=strlen(initstring+2),i,j,mi,l,r,an,m;
	for(*p=i=1;i&lt;N;++i)p[i]=p[i-1]*ba;
	initstring[cl+2]='!';
	cd-&gt;fa=cd-&gt;ch[0]=cd-&gt;ch[1]=cd;
	cd-&gt;ha=cd-&gt;siz=cd-&gt;c=0;nil=cd++;
	root=build(1,cl+2);root-&gt;fa=nil;
	register char ch;
	for(m=geti();m;--m){
		while(ch=getchar(),ch&lt;'A');
		if(ch=='Q'){
			i=geti()+1,j=geti()+1;
			if(kth(i)-&gt;c!=kth(j)-&gt;c){puts(&quot;0&quot;);continue;}
			for(an=l=1,r=cl-(i&lt;j?j:i)+2;l&lt;=r;){
				mi=l+r&gt;&gt;1;
				if(quy(i,i+mi-1)==quy(j,j+mi-1))l=(an=mi)+1;
				else r=mi-1;
			}printf(&quot;%d\n&quot;,an);
		}else{
			j=ch=='R';cl+=j^1;
			i=geti()+1;while(ch=getchar(),ch&lt;'a');
			j?upd(i,ch):ins(i,ch);
		}
	}return 0;
}
<pre><h2>Problem1014</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
    register int a; register char c;
    while(c=getchar(),c&lt;'0');a=c-'0';
    while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return a;
}
#define ui unsigned int
#define N 100050
#define ba 257
ui p[N];
struct node {
    ui ha; int siz; char c;
    node *fa,*ch[2];
}CD[N],*cd=CD,*root,*nil;
inline void maintain(node*(&amp;u)) {
    if(u==nil) return;
    u-&gt;siz=u-&gt;ch[0]-&gt;siz+u-&gt;ch[1]-&gt;siz+1;
    u-&gt;ha=u-&gt;ch[0]-&gt;ha+u-&gt;c*p[u-&gt;ch[0]-&gt;siz]+u-&gt;ch[1]-&gt;ha*p[u-&gt;ch[0]-&gt;siz+1];
}
inline void rot(node*(&amp;u)) {
    node *f=u-&gt;fa,*ff=f-&gt;fa;
    int d=u==f-&gt;ch[1];
    if((f-&gt;ch[d]=u-&gt;ch[d^1])!=nil) f-&gt;ch[d]-&gt;fa=f;
    f-&gt;fa=u,u-&gt;ch[d^1]=f;
    if((u-&gt;fa=ff)!=nil) ff-&gt;ch[f==ff-&gt;ch[1]]=u;
    maintain(f);maintain(u);
}
inline void splay(node*(&amp;u),node*(&amp;target)) {
    while(u-&gt;fa!=target){
        if(u-&gt;fa-&gt;fa==target){rot(u);break;}
        if((u==u-&gt;fa-&gt;ch[1])^(u-&gt;fa==u-&gt;fa-&gt;fa-&gt;ch[1]))rot(u);
        else rot(u-&gt;fa);rot(u);
    }if(target==nil)root=u;
}
inline node*kth(int k){
    node*u=root;
    while(k&amp;&amp;u!=nil){
        if(u-&gt;ch[0]-&gt;siz&gt;=k)u=u-&gt;ch[0];
        else if(u-&gt;ch[0]-&gt;siz+1==k) return u;
        else k-=u-&gt;ch[0]-&gt;siz+1,u=u-&gt;ch[1];
    }return u;
}
inline void ins(int k,char ch) {
    node *l=kth(k); cd-&gt;c=ch;
    cd-&gt;ch[0]=nil,cd-&gt;ch[1]=l-&gt;ch[1];
    cd-&gt;fa=l,cd-&gt;ch[1]-&gt;fa=cd;
    l-&gt;ch[1]=cd; maintain(cd);
    while(l!=nil) {maintain(l);l=l-&gt;fa;}
    ++cd;
}
inline void upd(int k,char ch){
    node*u=kth(k);u-&gt;c=ch;
    while(u!=nil){maintain(u);u=u-&gt;fa;}
}
inline ui quy(int l,int r){
    node*lu=kth(l-1),*ru=kth(r+1);
    splay(lu,nil);splay(ru,lu);
    return ru-&gt;ch[0]-&gt;ha;
}
char initstring[N];
node*build(int l,int r){
    if(l&gt;r)return nil;
    int m=l+r&gt;&gt;1;node*u=cd++;
    u-&gt;c=initstring[m];
    if((u-&gt;ch[0]=build(l,m-1))!=nil)u-&gt;ch[0]-&gt;fa=u;
    if((u-&gt;ch[1]=build(m+1,r))!=nil)u-&gt;ch[1]-&gt;fa=u;
    maintain(u);return u;
}
int main() {
    initstring[1]='~';
    scanf(&quot;%s&quot;,initstring+2);
    register int cl=strlen(initstring+2),i,j,mi,l,r,an,m;
    for(*p=i=1;i^N;++i)p[i]=p[i-1]*ba;
    initstring[cl+2]='!';
    cd-&gt;fa=cd-&gt;ch[0]=cd-&gt;ch[1]=cd;
    cd-&gt;ha=cd-&gt;siz=cd-&gt;c=0;nil=cd++;
    root=build(1,cl+2);root-&gt;fa=nil;
    register char ch;
    for(m=geti();m;--m){
        while(ch=getchar(),ch&lt;'A');
        if(ch=='Q'){
            i=geti()+1,j=geti()+1;
            if(kth(i)-&gt;c!=kth(j)-&gt;c){puts(&quot;0&quot;);continue;}
            for(an=l=1,r=cl-(i&lt;j?j:i)+2;l&lt;=r;){
                mi=l+r&gt;&gt;1;
                if(quy(i,i+mi-1)==quy(j,j+mi-1))l=(an=mi)+1;
                else r=mi-1;
            }printf(&quot;%d\n&quot;,an);
        }else{
            j=ch=='R';cl+=j^1;
            i=geti()+1;while(ch=getchar(),ch&lt;'a');
            j?upd(i,ch):ins(i,ch);
        }
    }return 0;
}<pre><h2>Problem1015</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 400005
int f[N],blo,d[N],ANS[N];
bool mark[N],can[N];
inline int gf(int u){
	register int en;
	for(en=u;f[en]^en;en=f[en]);
	for(register int t;u^en;t=f[u],f[u]=en,u=t);
	return en;
}

struct E{int to;E*nt;}CD[N],*cd=CD,*hd[N];
#define adde(a,b) (cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++)
inline void ins(int u) {
	register int v;
	for(register E*it=hd[u];it;it=it-&gt;nt)
		if(can[it-&gt;to]&amp;&amp;(gf(u)^(v=gf(it-&gt;to))))
			--blo,f[v]=gf(u);
}
int main() {
	register int n=geti(),m=geti(),i,a,b;
	for(i=0;i&lt;n;++i)f[i]=i;
	while(m--){a=geti(),b=geti();adde(a,b),adde(b,a);}
	register int*ans,*t=d;
	for(i=0,m=geti();i&lt;m;++i)mark[*t++=geti()]=1;
	for(i=0;i&lt;n;++i)
		if(!mark[i])++blo,can[i]=1,ins(i);
	ans=ANS+m;
	*ans--=blo;
	for(i=m;i;--i) {
		can[a=*--t]=1;
		++blo;ins(a);
		*ans--=blo;
	}
	for(i=0;i&lt;=m;++i)printf(&quot;%d\n&quot;,*++ans);
	return 0;
}
<pre><h2>Problem1016</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define mo 31011
struct E{int u,v,w;}e[1002];
inline bool operator &lt; (const E&amp;a,const E&amp;b){return a.w&lt;b.w;}
int L[1002],R[1002],C[1002],f[102],sum,x;
inline int gf(int u) {
	while(f[u]^u)u=f[u];
	return u;
}
void dfs(int cur,int t) {
	if(R[x]&lt;cur){sum+=t==C[x];return;}
	int p=gf(e[cur].u),q=gf(e[cur].v);
	if(p^q){
		f[p]=q;
		dfs(cur+1,t+1);
		f[p]=p,f[q]=q;
	}
	dfs(cur+1,t);
}
int main() {
	register int i,cnt=0,cedge=0,p,q;
	register int n=geti(),m=geti(),ans=1;
	for(i=0;i&lt;m;++i)e[i].u=geti(),e[i].v=geti(),e[i].w=geti();
	std::sort(e,e+m);
	for(i=1;i&lt;=n;++i)f[i]=i;
	for(i=0;i&lt;m;++i) {
		if(e[i-1].w&lt;e[i].w)R[cnt]=i-1,R[++cnt]=i;
		if((p=gf(e[i].u))^(q=gf(e[i].v)))
			f[p]=q,++C[cnt],++cedge;
	}R[cnt]=m;
	if(cedge&lt;n-1)return puts(&quot;0&quot;),0;
	for(i=1;i&lt;=n;++i)f[i]=i;
	for(x=1;x&lt;=cnt;++x) {
		sum=0; dfs(L[x],0);
		ans=ans*sum%mo;
		for(i=L[x];i&lt;=R[x];++i)
			if((p=gf(e[i].u))^(q=gf(e[i].v)))f[p]=q;
	}
	return printf(&quot;%d\n&quot;,ans),0;
}
<pre><h2>Problem1017</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
using namespace std;
#define  ll long long
#define endl '\n'
int dp[60][200][2100],ans,num[200],need[200],po[200],cost[200];
vector&lt;int&gt;v[200];
#define INF 0x3f3f3f3f
int m,g[2100],pre[100];
void treedp(int x)
{
	if(!v[x].size())
	{
		num[x]=min(num[x],m/cost[x]);
		for(int j=0;j&lt;=num[x];j++)
		  for(int k=j;k&lt;=num[x];k++)
			dp[x][j][k*cost[x]]=(k-j)*po[x];
		return;
	}
	num[x]=INF;
	for(int i=0;i&lt;v[x].size();i++)
	{
		treedp(v[x][i]);
		num[x]=min(num[x],num[v[x][i]]/need[v[x][i]]);
	}
	for(int i=0;i&lt;=num[x];i++) dp[x][i][0]=0;
	for(int i=0;i&lt;v[x].size();i++)
	{
		int y=v[x][i];
		for(int j=0;j&lt;=num[x];j++)
		{
			memcpy(g,dp[x][j],sizeof(dp[x][j]));
			memset(dp[x][j],-1,sizeof(dp[x][j]));
			for(int k=0;k&lt;=m;k++)
			  for(int w=0;w&lt;=k;w++)
				if(g[k-w]!=-1&amp;&amp;dp[y][j*need[y]][w]!=-1)
				  dp[x][j][k]=max(dp[x][j][k],g[k-w]+dp[y][j*need[y]][w]);
		}
	}
	for(int i=0;i&lt;=num[x];i++)
	  for(int j=i;j&lt;=num[x];j++)
		for(int k=0;k&lt;=m;k++)
		  if(dp[x][j][k]!=-1)
			dp[x][i][k]=max(dp[x][i][k],dp[x][j][k]+(j-i)*po[x]),ans=max(ans,dp[x][i][k]);
}
int main()
{
	int n,x,y,z;
	char s[10];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	memset(pre,0,sizeof(pre));
	memset(dp,-1,sizeof(dp));
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%s&quot;,&amp;po[i],s);
		if(s[0]=='B') scanf(&quot;%d%d&quot;,&amp;cost[i],&amp;num[i]);
		else
		{
			scanf(&quot;%d&quot;,&amp;x);
			while(x--)
			{
				scanf(&quot;%d%d&quot;,&amp;y,&amp;z);
				need[y]=z;pre[y]=i;
				v[i].push_back(y);
			}
		}
	}
	for(int i=1;i&lt;=n;i++) 
	  if (!pre[i]){
		  v[0].push_back(i);
		  need[i] = 1;
		  po[0] += po[i];
	  }
	treedp(0);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0 ;
}<pre><h2>Problem1018</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
#define MID int mid=l+r&gt;&gt;1
struct D{bool a0,a1,b0,b1,c0,c1;}C[400005];
bool edge[3][100005]; char ts[10];
void build(int u,int l,int r) {
	if(l&gt;=r) {
		C[u].b0=C[u].b1=true;
		return;
	}
	MID;
	build(ls,l,mid);build(rs,mid+1,r);
}
D pluse(const D&amp;a,const D&amp;b,const bool&amp;x,const bool&amp;y) {
	D r;
	r.a0=a.a0||(a.b0&amp;&amp;a.b1&amp;&amp;x&amp;&amp;y&amp;&amp;b.a0);
	r.a1=b.a1||(b.b0&amp;&amp;b.b1&amp;&amp;x&amp;&amp;y&amp;&amp;a.a1);
	r.b0=(a.b0&amp;&amp;x&amp;&amp;b.b0)||(a.c0&amp;&amp;y&amp;&amp;b.c1);
	r.b1=(a.b1&amp;&amp;y&amp;&amp;b.b1)||(a.c1&amp;&amp;x&amp;&amp;b.c0);
	r.c0=(x&amp;&amp;a.b0&amp;&amp;b.c0)||(y&amp;&amp;a.c0&amp;&amp;b.b1);
	r.c1=(y&amp;&amp;a.b1&amp;&amp;b.c1)||(x&amp;&amp;a.c1&amp;&amp;b.b0);
	return r;
}
void upd(int u,int l,int r,int p) {
	if(l&gt;=r) {
		C[u].b0=C[u].b1=true;
		C[u].a0=C[u].a1=C[u].c0=C[u].c1=edge[2][p];
		return;
	}
	MID;
	if(p&lt;=mid)upd(ls,l,mid,p);else upd(rs,mid+1,r,p);
	C[u]=pluse(C[ls],C[rs],edge[0][mid],edge[1][mid]);
}
D quy(int u,int l,int r,int x,int y) {
	if(l&gt;=x&amp;&amp;r&lt;=y)return C[u];
	MID;
	if(y&lt;=mid)return quy(ls,l,mid,x,y);
	if(x&gt;mid)return quy(rs,mid+1,r,x,y);
	return pluse(quy(ls,l,mid,x,mid),quy(rs,mid+1,r,mid+1,y),edge[0][mid],edge[1][mid]);
}
int main() {
	register int c=geti(),r1,c1,r2,c2;
	build(1,1,c);
	register D t1,t2,t3;
	register bool ok;
	while(scanf(&quot;%s&quot;,ts)^EOF) {
		if(*ts=='E')break;
		r1=geti()-1,c1=geti(),r2=geti()-1,c2=geti();
		if(c2&lt;c1)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
		if(*ts=='O') {
			if(r1&gt;r2)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
			if(r1&lt;r2)edge[2][c1]=1;
			else edge[r1][c1]=1;
			upd(1,1,c,c1);
		} else if(*ts=='C') {
			if(r1&gt;r2)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
			if(r1&lt;r2)edge[2][c1]=0;
			else edge[r1][c1]=0;
			upd(1,1,c,c1);
		} else {
			t1=quy(1,1,c,1,c1);
			t2=quy(1,1,c,c1,c2);
			t3=quy(1,1,c,c2,c);
			if(r1&amp;&amp;r2) {
				ok=t2.b1||(t1.a1&amp;&amp;t2.c0)||(t2.c1&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.b0&amp;&amp;t3.a0;
			}else if(!r1^r2) {
				ok=t2.b0||(t1.a1&amp;&amp;t2.c1)||(t2.c0&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.b1&amp;&amp;t3.a0;
			}else if(r1) {
				ok=t2.c1||(t1.a1&amp;&amp;t2.b0)||(t2.b1&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.c0&amp;&amp;t3.a0;
			}else {
				ok=t2.c0||(t1.a1&amp;&amp;t2.b1)||(t2.b0&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.c1&amp;&amp;t3.a0;
			}
			puts(ok?&quot;Y&quot;:&quot;N&quot;);
		}
	}
	return 0;
}
<pre><h2>Problem1018</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
#define MID int mid=l+r&gt;&gt;1
struct D{bool a0,a1,b0,b1,c0,c1;}C[200005];
bool edge[3][100005]; char ts[10];
void build(int u,int l,int r) {
	if(l&gt;=r) {
		C[u].b0=C[u].b1=true;
		return;
	}
	MID;
	build(ls,l,mid);build(rs,mid+1,r);
}
D pluse(const D&amp;a,const D&amp;b,const bool&amp;x,const bool&amp;y) {
	D r;
	r.a0=a.a0||(a.b0&amp;&amp;a.b1&amp;&amp;x&amp;&amp;y&amp;&amp;b.a0);
	r.a1=b.a1||(b.b0&amp;&amp;b.b1&amp;&amp;x&amp;&amp;y&amp;&amp;a.a1);
	r.b0=(a.b0&amp;&amp;x&amp;&amp;b.b0)||(a.c0&amp;&amp;y&amp;&amp;b.c1);
	r.b1=(a.b1&amp;&amp;y&amp;&amp;b.b1)||(a.c1&amp;&amp;x&amp;&amp;b.c0);
	r.c0=(x&amp;&amp;a.b0&amp;&amp;b.c0)||(y&amp;&amp;a.c0&amp;&amp;b.b1);
	r.c1=(y&amp;&amp;a.b1&amp;&amp;b.c1)||(x&amp;&amp;a.c1&amp;&amp;b.b0);
	return r;
}
void upd(int u,int l,int r,int p) {
	if(l&gt;=r) {
		C[u].b0=C[u].b1=true;
		C[u].a0=C[u].a1=C[u].c0=C[u].c1=edge[2][p];
		return;
	}
	MID;
	if(p&lt;=mid)upd(ls,l,mid,p);else upd(rs,mid+1,r,p);
	C[u]=pluse(C[ls],C[rs],edge[0][mid],edge[1][mid]);
}
D quy(int u,int l,int r,int x,int y) {
	if(l&gt;=x&amp;&amp;r&lt;=y)return C[u];
	MID;
	if(y&lt;=mid)return quy(ls,l,mid,x,y);
	if(x&gt;mid)return quy(rs,mid+1,r,x,y);
	return pluse(quy(ls,l,mid,x,mid),quy(rs,mid+1,r,mid+1,y),edge[0][mid],edge[1][mid]);
}
int main() {
	register int c=geti(),r1,c1,r2,c2;
	build(1,1,c);
	register D t1,t2,t3;
	register bool ok;
	while(scanf(&quot;%s&quot;,ts)^EOF) {
		if(*ts=='E')break;
		r1=geti()-1,c1=geti(),r2=geti()-1,c2=geti();
		if(c2&lt;c1)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
		if(*ts=='O') {
			if(r1&gt;r2)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
			if(r1&lt;r2)edge[2][c1]=1;
			else edge[r1][c1]=1;
			upd(1,1,c,c1);
		} else if(*ts=='C') {
			if(r1&gt;r2)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
			if(r1&lt;r2)edge[2][c1]=0;
			else edge[r1][c1]=0;
			upd(1,1,c,c1);
		} else {
			t1=quy(1,1,c,1,c1);
			t2=quy(1,1,c,c1,c2);
			t3=quy(1,1,c,c2,c);
			if(r1&amp;&amp;r2) {
				ok=t2.b1||(t1.a1&amp;&amp;t2.c0)||(t2.c1&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.b0&amp;&amp;t3.a0;
			}else if(!r1^r2) {
				ok=t2.b0||(t1.a1&amp;&amp;t2.c1)||(t2.c0&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.b1&amp;&amp;t3.a0;
			}else if(r1) {
				ok=t2.c1||(t1.a1&amp;&amp;t2.b0)||(t2.b1&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.c0&amp;&amp;t3.a0;
			}else {
				ok=t2.c0||(t1.a1&amp;&amp;t2.b1)||(t2.b0&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.c1&amp;&amp;t3.a0;
			}
			puts(ok?&quot;Y&quot;:&quot;N&quot;);
		}
	}
	return 0;
}
<pre><h2>Problem1018</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
#define MID int mid=l+r&gt;&gt;1
struct D{bool a0,a1,b0,b1,c0,c1;}C[200005];
bool edge[3][100005]; char ts[10];
void build(int u,int l,int r) {
	if(l&gt;=r) {
		C[u].b0=C[u].b1=true;
		return;
	}
	MID;
	build(ls,l,mid);build(rs,mid+1,r);
}
D pluse(const D&amp;a,const D&amp;b,const bool&amp;x,const bool&amp;y) {
	D r;
	r.a0=a.a0||(a.b0&amp;&amp;a.b1&amp;&amp;x&amp;&amp;y&amp;&amp;b.a0);
	r.a1=b.a1||(b.b0&amp;&amp;b.b1&amp;&amp;x&amp;&amp;y&amp;&amp;a.a1);
	r.b0=(a.b0&amp;&amp;x&amp;&amp;b.b0)||(a.c0&amp;&amp;y&amp;&amp;b.c1);
	r.b1=(a.b1&amp;&amp;y&amp;&amp;b.b1)||(a.c1&amp;&amp;x&amp;&amp;b.c0);
	r.c0=(x&amp;&amp;a.b0&amp;&amp;b.c0)||(y&amp;&amp;a.c0&amp;&amp;b.b1);
	r.c1=(y&amp;&amp;a.b1&amp;&amp;b.c1)||(x&amp;&amp;a.c1&amp;&amp;b.b0);
	return r;
}
void upd(int u,int l,int r,int p) {
	if(l&gt;=r) {
		C[u].a0=C[u].a1=C[u].c0=C[u].c1=edge[2][p];
		return;
	}
	MID;
	if(p&lt;=mid)upd(ls,l,mid,p);else upd(rs,mid+1,r,p);
	C[u]=pluse(C[ls],C[rs],edge[0][mid],edge[1][mid]);
}
D quy(int u,int l,int r,int x,int y) {
	if(l&gt;=x&amp;&amp;r&lt;=y)return C[u];
	MID;
	if(y&lt;=mid)return quy(ls,l,mid,x,y);
	if(x&gt;mid)return quy(rs,mid+1,r,x,y);
	return pluse(quy(ls,l,mid,x,mid),quy(rs,mid+1,r,mid+1,y),edge[0][mid],edge[1][mid]);
}
int main() {
	register int c=geti(),r1,c1,r2,c2;
	build(1,1,c);
	register D t1,t2,t3;
	register bool ok;
	while(scanf(&quot;%s&quot;,ts)^EOF) {
		if(*ts=='E')break;
		r1=geti()-1,c1=geti(),r2=geti()-1,c2=geti();
		if(c2&lt;c1)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
		if(*ts=='O') {
			if(r1&gt;r2)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
			if(r1&lt;r2)edge[2][c1]=1;
			else edge[r1][c1]=1;
			upd(1,1,c,c1);
		} else if(*ts=='C') {
			if(r1&gt;r2)r1^=r2^=r1^=r2,c1^=c2^=c1^=c2;
			if(r1&lt;r2)edge[2][c1]=0;
			else edge[r1][c1]=0;
			upd(1,1,c,c1);
		} else {
			t1=quy(1,1,c,1,c1);
			t2=quy(1,1,c,c1,c2);
			t3=quy(1,1,c,c2,c);
			if(r1&amp;&amp;r2) {
				ok=t2.b1||(t1.a1&amp;&amp;t2.c0)||(t2.c1&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.b0&amp;&amp;t3.a0;
			}else if(!r1^r2) {
				ok=t2.b0||(t1.a1&amp;&amp;t2.c1)||(t2.c0&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.b1&amp;&amp;t3.a0;
			}else if(r1) {
				ok=t2.c1||(t1.a1&amp;&amp;t2.b0)||(t2.b1&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.c0&amp;&amp;t3.a0;
			}else {
				ok=t2.c0||(t1.a1&amp;&amp;t2.b1)||(t2.b0&amp;&amp;t3.a0);
				ok|=t1.a1&amp;&amp;t2.c1&amp;&amp;t3.a0;
			}
			puts(ok?&quot;Y&quot;:&quot;N&quot;);
		}
	}
	return 0;
}
<pre><h2>Problem1019</h2><pre>#include &lt;cstdio&gt;
int n,i,j,x,y;
char vis[4],g[3][32],ts[3];
long long f[3][32];
int main() {
	for(scanf(&quot;%d&quot;,&amp;n),i=0;i^6;++i) {
		scanf(&quot;%s&quot;,ts);
		x=*ts-'A',y=ts[1]-'A';
		if(!vis[x])vis[x]=1,g[x][1]=y,f[x][1]=1LL;
	}
	for(i=2;i&lt;=n;++i)
		for(j=0;j^3;++j) {
			y=g[j][i-1],x=3-y-j;
			if(x^g[y][i-1])
				f[j][i]=(f[j][i-1]&lt;&lt;1)+f[y][i-1]+2,g[j][i]=y;
			else
				f[j][i]=f[j][i-1]+f[y][i-1]+1,g[j][i]=x;
		}
	printf(&quot;%lld&quot;,f[0][n]);
	return 0;
}
<pre><h2>Problem1019</h2><pre>#include &lt;cstdio&gt;
char vis[3],g[3][32];
long long f[3][32];
int main() {
	register char n,i,j,x,y;
	while(j=getchar(),j&lt;'0');n=j-'0';
	while(j=getchar(),'-'&lt;j)n=(n&lt;&lt;3)+(n&lt;&lt;1)+j-'0';
	for(i=0;i^6;++i) {
		while(j=getchar(),j&lt;'A');
		x=j-'A',y=getchar()-'A';
		if(!vis[x])vis[x]=1,g[x][1]=y,f[x][1]=1LL;
	}
	for(i=2;i&lt;=n;++i)
		for(j=0;j^3;++j) {
			y=g[j][i-1],x=3-y-j;
			if(x^g[y][i-1])
				f[j][i]=(f[j][i-1]&lt;&lt;1)+f[y][i-1]+2,g[j][i]=y;
			else
				f[j][i]=f[j][i-1]+f[y][i-1]+1,g[j][i]=x;
		}
	printf(&quot;%lld&quot;,f[0][n]);
	return 0;
}
<pre><h2>Problem1023</h2><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;

inline int max(const int &amp;a, const int &amp;b) {
	return a &lt; b ? b : a;
}
inline int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}

const int maxn(50005);

std::vector&lt;int&gt; g[maxn];
int ans, f[maxn], dep[maxn], fa[maxn];
inline void circle(int u, int v) {
	static int tot, q[maxn * 2], a[maxn * 2], *l, *r;
	tot = dep[v] - dep[u] + 1;
	for (int i = v; i ^ u; i = fa[i]) a[tot--] = f[i];
	a[tot] = f[u];
	tot = dep[v] - dep[u] + 1;
	for (int i = 1; i &lt;= tot; ++i) a[tot + i] = a[i];
	l = r = q;
	for (int i = 2; i &lt;= (tot &lt;&lt; 1); ++i) {
		if (l &lt; r &amp;&amp; i - *l &gt; (tot &gt;&gt; 1)) ++l;
		if (l &lt; r) ans = max(ans, i - *l + a[i] + a[*l]);
		while (l &lt; r &amp;&amp; a[r[-1]] - r[-1] &lt; a[i] - i) --r;
		*r++ = i;
	}
	for (int i = 2; i &lt;= tot; ++i) f[u] = max(f[u], a[i] + min(i - 1, tot - i + 1));
}

void dfs(int u) {
	static int dfn[maxn], low[maxn], _dfn = 0;
	int v;
	dfn[u] = low[u] = ++_dfn;
	for (size_t i = 0; i &lt; g[u].size(); ++i) {
		v = g[u][i];
		if (v == fa[u]) continue;
		if (!dfn[v]) {
			fa[v] = u;
			dep[v] = dep[u] + 1;
			dfs(v);
			low[u] = min(low[u], low[v]);
		} else
			low[u] = min(low[u], dfn[v]);
		if (dfn[u] &lt; low[v]) {
			ans = max(ans, f[u] + f[v] + 1);
			f[u] = max(f[u], f[v] + 1);
		}
	}
	for (size_t i = 0; i &lt; g[u].size(); ++i) {
		v = g[u][i];
		if (fa[v] != u &amp;&amp; dfn[u] &lt; dfn[v])
			circle(u, v);
	}
}
int main() {
	int n, m, u, v, k;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;k, &amp;u);
		while (--k) {
			scanf(&quot;%d&quot;, &amp;v);
			g[u].push_back(v);
			g[v].push_back(u);
			u = v;
		}
	}
	dfs(1);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem1026</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int dp[12][10][2],dig[12];
inline int ibs(int a){return a&lt;0?-a:a;}
int dfs(int p,int pre,bool zero,bool limited) {
	if(!p)return!zero;
	int&amp;t=dp[p][pre][zero];
	if(!limited&amp;&amp;(~t))return t;
	int en=limited?dig[p]:9,r=0;
	if(zero)r=dfs(p-1,0,1,!en);
	else if(pre&gt;=2)r=dfs(p-1,0,0,!en);
	for(int i=1;i&lt;=en;++i)
		if(zero||ibs(i-pre)&gt;1)
			r+=dfs(p-1,i,0,limited&amp;&amp;i&gt;=en);
	if(!limited)t=r;
	return r;
}
int cal(int x){
	int l=0;
	while(x)dig[++l]=x%10,x/=10;
	return dfs(l,0,1,1);
}
int main() {
	int L,R;
	scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	memset(dp,-1,sizeof dp);
	printf(&quot;%d\n&quot;,cal(R)-cal(L-1));
	return 0;
}
<pre><h2>Problem1030</h2><pre>#include &lt;cstdio&gt;
#define mo 10007
#define M 6000
#define SIZE 26
class ac_dfa {
protected:
	int ch[SIZE][M],fail[M],totnode,dp[2][M];
	bool flag[M];
public:
	void insert(char *s) {
		int u=0,idx;
		while(*s) {
			idx=*s++-'A';
			if(!ch[idx][u]) ch[idx][u]=++totnode;
			u=ch[idx][u];
		}
		flag[u]=true;
	}
	void make_fail() {
		int *l=dp[0],*r=dp[0],i,f,x;
		*r++=0;
		while(l&lt;r)
			for(flag[x=*l++]|=flag[fail[x]],i=0;i&lt;26;++i)
				if(ch[i][x]) *r++=ch[i][x],fail[ch[i][x]]=x?ch[i][fail[x]]:0;
				else ch[i][x]=x?ch[i][fail[x]]:0;
	}
	inline void add(int&amp;a,int b){for(a+=b;a&gt;=mo;a-=mo);}
	int cal(int l) {
		int i,j,idx=0,p;
		for(p=1,i=0;i&lt;l;++i)p=p*26%mo;
		for(i=1;i&lt;=totnode;++i)dp[0][i]=0;
		dp[0][0]=1;
		for(;l;--l,idx^=1)
			for(i=0;i&lt;=totnode;++i)
				if(!flag[i]&amp;&amp;dp[idx][i]) {
					for(j=0;j&lt;26;++j)
						add(dp[idx^1][ch[j][i]],dp[idx][i]);
					dp[idx][i]=0;
				}
		int ans=0;
		for(i=0;i&lt;=totnode;++i)
			if(!flag[i])add(ans,dp[idx][i]);
		return ((p-ans)%mo+mo)%mo;
	}
}work;
char s[105];
int main() {
	int n,m;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	while(n--) {scanf(&quot;%s&quot;,s);work.insert(s);}
	work.make_fail();
	printf(&quot;%d\n&quot;,work.cal(m));
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 200010
char s[N];
int sa[N],ws[N],wv[N],ta[N],tb[N],n;
inline void da() {
	/*register*/ int i,j,*x=ta,*y=tb,*t,m=256,p;
	for(i=0;i&lt;m;++i)ws[i]=0;
	for(i=0;i&lt;n;++i)++ws[x[i]=s[i]];
	for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
	for(i=n-1;~i;--i)sa[--ws[x[i]]]=i;
	for(p=j=1;p&lt;n;j&lt;&lt;=1,m=p) {
		for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;
		for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;
		for(i=0;i&lt;n;++i)wv[i]=x[y[i]];
		for(i=0;i&lt;m;++i)ws[i]=0;
		for(i=0;i&lt;n;++i)++ws[wv[i]];
		for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
		for(i=n-1;~i;--i)sa[--ws[wv[i]]]=y[i];
		for(t=x,x=y,y=t,p=1,x[*sa]=0,i=1;i&lt;n;++i)
			x[sa[i]]=((y[sa[i-1]]^y[sa[i]])||(y[sa[i-1]+j]^y[sa[i]+j]))?p++:p-1;
	}
}
int main() {
	scanf(&quot;%s&quot;,s);
	register int k=strlen(s);
	for(register int i=0;i&lt;k;++i)s[i+k]=s[i];
	n=k&lt;&lt;1|1;da();
	for(register int i=1;i&lt;n;++i)
		if(sa[i]&lt;k) putchar(s[sa[i]+k-1]);
	return 0;
}
<pre><h2>Problem1031</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 200010
char s[N];
int sa[N],ws[N],wv[N],ta[N],tb[N],n;
inline void da() {
	register int i,j,*x=ta,*y=tb,*t,m=256,p;
	for(i=0;i&lt;m;++i)ws[i]=0;
	for(i=0;i&lt;n;++i)++ws[x[i]=s[i]];
	for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
	for(i=n-1;~i;--i)sa[--ws[x[i]]]=i;
	for(p=j=1;p&lt;n;j&lt;&lt;=1,m=p) {
		for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;
		for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;
		for(i=0;i&lt;n;++i)wv[i]=x[y[i]];
		for(i=0;i&lt;m;++i)ws[i]=0;
		for(i=0;i&lt;n;++i)++ws[wv[i]];
		for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
		for(i=n-1;~i;--i)sa[--ws[wv[i]]]=y[i];
		for(t=x,x=y,y=t,p=1,x[*sa]=0,i=1;i&lt;n;++i)
			x[sa[i]]=((y[sa[i-1]]^y[sa[i]])||(y[sa[i-1]+j]^y[sa[i]+j]))?p++:p-1;
	}
}
int main() {
	scanf(&quot;%s&quot;,s);
	register int k=strlen(s);
	for(register int i=0;i&lt;k;++i)s[i+k]=s[i];
	n=k&lt;&lt;1|1;da();
	for(register int i=1;i&lt;n;++i)
		if(sa[i]&lt;k) putchar(s[sa[i]+k-1]);
	return 0;
}<pre><h2>Problem1036</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
inline void swap(int&amp;a,int&amp;b){int t=b;b=a,a=t;}
inline void cmax(int&amp;a,int b){a&lt;b?a=b:1;}
#define N 300005
int Max[N&lt;&lt;1],seg; long long Sum[N&lt;&lt;1];
inline int qm(int st,int en) {
	int r=-0x7f7f7f7f;
	for(st+=seg-1,en+=seg+1;st^en^1;st&gt;&gt;=1,en&gt;&gt;=1) {
		if(~st&amp;1)cmax(r,Max[st^1]);
		if( en&amp;1)cmax(r,Max[en^1]);
	}return r;
}
inline long long qs(int st,int en) {
	long long r=0;
	for(st+=seg-1,en+=seg+1;st^en^1;st&gt;&gt;=1,en&gt;&gt;=1) {
		if(~st&amp;1)r+=Sum[st^1];
		if( en&amp;1)r+=Sum[en^1];
	}return r;
}
inline void upd(int x,int v) {
	x+=seg;Max[x]=Sum[x]=v;
	for(x&gt;&gt;=1;x;x&gt;&gt;=1) {
		Sum[x]=Sum[x&lt;&lt;1]+Sum[x&lt;&lt;1|1];
		Max[x]=Max[x&lt;&lt;1]&lt;Max[x&lt;&lt;1|1]?Max[x&lt;&lt;1|1]:Max[x&lt;&lt;1];
	}
}
struct E{int to;E*nt;}CD[N&lt;&lt;1],*cd=CD,*hd[N];
#define adde(a,b) (cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++)
int fa[N],p[N],tp[N],dep[N],_clock,son[N];
int dfs1(int u) {
	int v,r=1,t,mx=0;
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(!dep[v=it-&gt;to]) {
			fa[v]=u;dep[v]=dep[u]+1;
			t=dfs1(v);r+=t;
			if(mx&lt;t)son[u]=v,mx=t;
		}return r;
}
void dfs2(int u,int top) {
	p[u]=++_clock;tp[u]=top;
	if(son[u])dfs2(son[u],top);
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(!tp[it-&gt;to])dfs2(it-&gt;to,it-&gt;to);
}
inline int qmax(int u,int v) {
	int r=-0x7f7f7f7f;
	while(tp[u]^tp[v]) {
		if(dep[tp[u]]&lt;dep[tp[v]])swap(u,v);
		cmax(r,qm(p[tp[u]],p[u]));
		u=fa[tp[u]];
	}
	if(dep[u]&lt;dep[v])swap(u,v);
	cmax(r,qm(p[v],p[u]));
	return r;
}
inline long long qsum(int u,int v) {
	long long r=0;
	while(tp[u]^tp[v]) {
		if(dep[tp[u]]&lt;dep[tp[v]])swap(u,v);
		r+=qs(p[tp[u]],p[u]);
		u=fa[tp[u]];
	}
	if(dep[u]&lt;dep[v])swap(u,v);
	return r+qs(p[v],p[u]);
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1036.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1036.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n,x,y,q;
	char ts[10];
	for(n=geti(),seg=1;seg&lt;=n;seg&lt;&lt;=1);
	for(q=1;q&lt;n;++q) {
		x=geti(),y=geti();
		adde(x,y),adde(y,x);
	}
	dep[1]=1;dfs1(1);dfs2(1,1);
	for(x=1;x&lt;=n;++x)Sum[seg+p[x]]=Max[seg+p[x]]=geti();
	for(x=seg;x;--x) {
		Sum[x]=Sum[x&lt;&lt;1]+Sum[x&lt;&lt;1|1];
		Max[x]=Max[x&lt;&lt;1]&lt;Max[x&lt;&lt;1|1]?Max[x&lt;&lt;1|1]:Max[x&lt;&lt;1];
	}
	for(q=geti();q;--q) {
		scanf(&quot;%s&quot;,ts);
		x=geti(),y=geti();
		if(*ts=='Q') {
			if(ts[1]=='M') printf(&quot;%d\n&quot;,qmax(x,y));
			else printf(&quot;%lld\n&quot;,qsum(x,y));
		} else upd(p[x],y);
	}
	return 0;
}
<pre><h2>Problem1036</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
inline void swap(int&amp;a,int&amp;b){int t=b;b=a,a=t;}
inline void cmax(int&amp;a,int b){a&lt;b?a=b:1;}
#define N 300005
int Max[N&lt;&lt;1],seg,Sum[N&lt;&lt;1];
inline int qm(int st,int en) {
	int r=-0x7f7f7f7f;
	for(st+=seg-1,en+=seg+1;st^en^1;st&gt;&gt;=1,en&gt;&gt;=1) {
		if(~st&amp;1)cmax(r,Max[st^1]);
		if( en&amp;1)cmax(r,Max[en^1]);
	}return r;
}
inline int qs(int st,int en) {
	int r=0;
	for(st+=seg-1,en+=seg+1;st^en^1;st&gt;&gt;=1,en&gt;&gt;=1) {
		if(~st&amp;1)r+=Sum[st^1];
		if( en&amp;1)r+=Sum[en^1];
	}return r;
}
inline void upd(int x,int v) {
	x+=seg;Max[x]=Sum[x]=v;
	for(x&gt;&gt;=1;x;x&gt;&gt;=1) {
		Sum[x]=Sum[x&lt;&lt;1]+Sum[x&lt;&lt;1|1];
		Max[x]=Max[x&lt;&lt;1]&lt;Max[x&lt;&lt;1|1]?Max[x&lt;&lt;1|1]:Max[x&lt;&lt;1];
	}
}
struct E{int to;E*nt;}CD[N&lt;&lt;1],*cd=CD,*hd[N];
#define adde(a,b) (cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++)
int fa[N],p[N],tp[N],dep[N],_clock,son[N];
int dfs1(int u) {
	int v,r=1,t,mx=0;
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(!dep[v=it-&gt;to]) {
			fa[v]=u;dep[v]=dep[u]+1;
			t=dfs1(v);r+=t;
			if(mx&lt;t)son[u]=v,mx=t;
		}return r;
}
void dfs2(int u,int top) {
	p[u]=++_clock;tp[u]=top;
	if(son[u])dfs2(son[u],top);
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(!tp[it-&gt;to])dfs2(it-&gt;to,it-&gt;to);
}
inline int qmax(int u,int v) {
	int r=-0x7f7f7f7f;
	while(tp[u]^tp[v]) {
		if(dep[tp[u]]&lt;dep[tp[v]])swap(u,v);
		cmax(r,qm(p[tp[u]],p[u]));
		u=fa[tp[u]];
	}
	if(dep[u]&lt;dep[v])swap(u,v);
	cmax(r,qm(p[v],p[u]));
	return r;
}
inline int qsum(int u,int v) {
	int r=0;
	while(tp[u]^tp[v]) {
		if(dep[tp[u]]&lt;dep[tp[v]])swap(u,v);
		r+=qs(p[tp[u]],p[u]);
		u=fa[tp[u]];
	}
	if(dep[u]&lt;dep[v])swap(u,v);
	return r+qs(p[v],p[u]);
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1036.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;1036.out&quot;,&quot;w&quot;,stdout);
#endif
	register int n,x,y,q;
	char ts[10];
	for(n=geti(),seg=1;seg&lt;=n;seg&lt;&lt;=1);
	for(q=1;q&lt;n;++q) {
		x=geti(),y=geti();
		adde(x,y),adde(y,x);
	}
	dep[1]=1;dfs1(1);dfs2(1,1);
	for(x=1;x&lt;=n;++x)Sum[seg+p[x]]=Max[seg+p[x]]=geti();
	for(x=seg;x;--x) {
		Sum[x]=Sum[x&lt;&lt;1]+Sum[x&lt;&lt;1|1];
		Max[x]=Max[x&lt;&lt;1]&lt;Max[x&lt;&lt;1|1]?Max[x&lt;&lt;1|1]:Max[x&lt;&lt;1];
	}
	for(q=geti();q;--q) {
		scanf(&quot;%s&quot;,ts);
		x=geti(),y=geti();
		if(*ts=='Q') {
			if(ts[1]=='M') printf(&quot;%d\n&quot;,qmax(x,y));
			else printf(&quot;%d\n&quot;,qsum(x,y));
		} else upd(p[x],y);
	}
	return 0;
}
<pre><h2>Problem1040</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 1000010
long long f[N],g[N],val[N];
inline long long max(long long a,long long b){return a&lt;b?b:a;}
int to[N&lt;&lt;1],nt[N&lt;&lt;1],hd[N];
int x,y; bool vis[N],ban[N&lt;&lt;1];
//f[i] chose i
//g[i] don't chose i
void dfs(int u,int fa) {
	vis[u]=true;
	int v,it;
	for(it=hd[u];(~it)&amp;&amp;!x;it=nt[it])
		if(!vis[v=to[it]]) dfs(v,u);
		else if(v^fa) x=u,y=v,ban[it]=ban[it^1]=true;
}
void dp(int u,int fa) {
	if(u^y) f[u]=val[u];
	else f[u]=0;
	int v,it; g[u]=0;
	vis[u]=true;
	for(it=hd[u];~it;it=nt[it])
		if((v=to[it])^fa&amp;&amp;!ban[it]) {
			dp(v,u);
			f[u]+=g[v];
			g[u]+=max(f[v],g[v]);
		}
}
int main() {
	int n,h;
	scanf(&quot;%d&quot;,&amp;n);
	memset(hd,-1,sizeof hd);
	for(register int i=1,te=0;i&lt;=n;++i) {
		scanf(&quot;%lld%d&quot;,val+i,&amp;h);
		to[te]=i,nt[te]=hd[h],hd[h]=te++;
		to[te]=h,nt[te]=hd[i],hd[i]=te++;
	}
	long long ans=0,t1,t2;
	for(register int i=1;i&lt;=n;++i)
		if(!vis[i]) {
			x=y=0;
			dfs(i,0);
			dp(x,0); t1=max(f[x],g[x]);
			x^=y^=x^=y;
			dp(x,0); t2=max(f[x],g[x]);
			ans+=max(t1,t2);
		}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1040</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 1000005
long long f[N],g[N];
inline long long max(long long a,long long b){return a&lt;b?b:a;}
int to[N&lt;&lt;1],nt[N&lt;&lt;1],hd[N],x,y,val[N];
bool vis[N],ban[N&lt;&lt;1];
//f[i] chose i
//g[i] don't chose i
void dfs(const int&amp;u,const int&amp;fa) {
	vis[u]=true;
	int v,it;
	for(it=hd[u];(~it)&amp;&amp;!x;it=nt[it])
		if(!vis[v=to[it]]) dfs(v,u);
		else if(v^fa) x=u,y=v,ban[it]=ban[it^1]=true;
}
void dp(const int&amp;u,const int&amp;fa) {
	if(u^y) f[u]=val[u];
	else f[u]=0;
	int v,it; g[u]=0;
	vis[u]=true;
	for(it=hd[u];~it;it=nt[it])
		if((v=to[it])^fa&amp;&amp;!ban[it]) {
			dp(v,u);
			f[u]+=g[v];
			g[u]+=max(f[v],g[v]);
		}
}
int main() {
	int n=geti();
	memset(hd,-1,(n+1)*sizeof(int));
	for(register int i=1,te=0,h;i&lt;=n;++i) {
		val[i]=geti(); h=geti();
		to[te]=i,nt[te]=hd[h],hd[h]=te++;
		to[te]=h,nt[te]=hd[i],hd[i]=te++;
	}
	long long ans=0,t1,t2;
	for(register int i=1;i&lt;=n;++i)
		if(!vis[i]) {
			x=y=0;
			dfs(i,0);
			dp(x,0); t1=max(f[x],g[x]);
			x^=y^=x^=y;
			dp(x,0); t2=max(f[x],g[x]);
			ans+=max(t1,t2);
		}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1043</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef pair &lt;double, double&gt; pdd;
#define X first
#define Y second
const double pi = acos(-1);
double x[1005], y[1005], r[1005];
int n, tp;
pdd q[1005];
inline double sqr(const double &amp;a) {
	return a * a;
}
inline double dis(const int &amp;i, const int &amp;j) {
	return sqrt(sqr(x[i] - x[j]) + sqr(y[i] - y[j]));
}
inline bool inside(const int &amp;i, const int &amp;j) {
	return r[i] &gt;= r[j] + dis(i, j);
}
inline void pb(const int &amp;i, const int &amp;j) {
	static double d, t, st, l;
	d = dis(i, j);
	t = (sqr(r[i]) + sqr(d) - sqr(r[j])) / (2 * d);
	st = atan2(x[i] - x[j], y[i] - y[j]);
	l = acos(t / r[i]);
	q[tp++] = make_pair(st - l, st + l);
}
double cal(const int &amp;x) {
	for (int i = x + 1; i &lt;= n; ++i)
		if (inside(i, x)) return 0.0;
	tp = 0;
	static double tmp, now;
	for (int i = x + 1; i &lt;= n; ++i)
		if (!inside(x, i) &amp;&amp; r[x] + r[i] &gt;= dis(x, i)) pb(x, i);
	tmp = now = 0;
	for (int i = 0; i &lt; tp; ++i) {
		if (q[i].X &lt; 0) q[i].X += 2 * pi;
		if (q[i].Y &lt; 0) q[i].Y += 2 * pi;
		if (q[i].X &gt; q[i].Y) {
			q[tp++] = make_pair(0, q[i].Y);
			q[i].Y = 2 * pi;
		}
	}
	sort(q, q + tp);
	for (int i = 0; i &lt; tp; ++i)
		if (q[i].X &gt; now) {
			tmp += q[i].X - now;
			now = q[i].Y;
		} else now = max(now, q[i].Y);
	tmp += 2 * pi - now;
	return r[x] * tmp;
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; ++i)
		scanf(&quot;%lf%lf%lf&quot;, r + i, x + i, y + i);
	double ans = 0;
	for (int i = 1; i &lt;= n; ++i)
		ans += cal(i);
	printf(&quot;%.3lf&quot;, ans);
	return 0;
}
<pre><h2>Problem1044</h2><pre>#include &lt;cstdio&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0'||'9'&lt;c);a=c-'0';
	while(c=getchar(),!(c&lt;'0'||'9'&lt;c))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 50002
#define mo 10007
int a[N],dp[N],s[N];
inline void mov(int&amp;a,int b){
	for(a=b;a&gt;=mo;a-=mo);
	while(a&lt;0)a+=mo;
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1044.in&quot;,&quot;r&quot;,stdin);
#endif
	register int n=geti(),m=geti(),i,j,l=-1,r,mi,an,c;
	for(i=1;i&lt;=n;++i)
		s[i]=(a[i]=geti())+s[i-1],(l&lt;a[i]?l=a[i]:1);
	r=s[n];
	while(l&lt;=r) {
		mi=l+r&gt;&gt;1;
		for(i=1,c=j=0;i&lt;=n&amp;&amp;c&lt;=m;++i)
			if(j+a[i]&lt;=mi)j+=a[i];
			else j=a[i],++c;
		if(c&lt;=m)r=(an=mi)-1;
		else l=mi+1;
	}
	for(i=0,j=0;i&lt;=n;++i)
		if(an&gt;=(j+=a[i]))dp[i]=1;
		else break;
	while(m--) {
		a[0]=dp[0];
		for(i=1;i&lt;=n;++i)mov(a[i],a[i-1]+dp[i]);
		for(i=1,j=0;i&lt;=n;++i){
			while(j&lt;i&amp;&amp;s[i]-s[j]&gt;an)++j;
			mov(dp[i],a[i-1]-a[j-1]);
		}
	}
	printf(&quot;%d %d&quot;,an,dp[n]);
	return 0;
}
<pre><h2>Problem1044</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 50005
#define mod 10007
int ina; char inc,inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define noti(a) (a&lt;'0'||'9'&lt;a)
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	while(inc=getc(),noti(inc));ina=inc-'0';
	while(inc=getc(),!noti(inc))ina=(ina&lt;&lt;3)+(ina&lt;&lt;1)+inc-'0';
	return ina;
}
int n,m,L[N],dp[N],sd[N],sum[N];
bool check(int mid) {
	int tot=0,s=0;
	for(int i=1;i&lt;=n;++i) {
		if(s+L[i]&gt;mid) {s=L[i];if(++tot&gt;m)return false;}
		else s+=L[i];
	}return true;
}
inline void mov(int&amp;a,int b) {
	for(a=b;a&gt;=mod;a-=mod);
	while(a&lt;0)a+=mod;
}
int main() {
	int l=-1,r=0,mid,ans;
	n=geti(),m=geti();
	for(int i=1;i&lt;=n;++i)
		sum[i]=sum[i-1]+(L[i]=geti()),l&lt;L[i]?l=L[i]:1;
	for(r=sum[n];l&lt;=r;){
		if(check(mid=l+r&gt;&gt;1)) r=(ans=mid)-1;
		else l=mid+1;
	}
	for(int i=0;i&lt;=n;++i)
		if(ans&gt;=sum[i]) dp[i]=1; else break;
	for(int j=1;j&lt;=m;++j) {
		int k=0;sd[0]=dp[0];
		for(int i=1;i&lt;=n;++i) mov(sd[i],dp[i]+sd[i-1]);
		for(int i=1;i&lt;=n;++i) {
			while(k&lt;i&amp;&amp;sum[i]-sum[k]&gt;ans)++k;
			mov(dp[i],sd[i-1]-sd[k-1]);
		}
	}return printf(&quot;%d %d\n&quot;,ans,dp[n]),0;
}
<pre><h2>Problem1044</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 50002
#define mo 10007
int sd[N],dp[N],s[N];
int main() {
	int n=geti(),m=geti();
	register int i,j,l=-1,r,mi,an,c;
	for(i=1;i&lt;=n;++i) {
		sd[i]=c=geti(); s[i]=s[i-1]+c;
		if(c&gt;l)l=c;
	}
	r=s[n];
	while(l&lt;=r) {
		mi=l+r&gt;&gt;1;
		for(i=1,c=j=0;i&lt;=n&amp;&amp;c&lt;=m;++i)
			if(j+sd[i]&gt;mi)j=sd[i],++c;
			else j+=sd[i];
		if(c&lt;=m)r=(an=mi)-1;
		else l=mi+1;
	}
	for(i=0,j=0;i&lt;=n;++i)
		if(an&lt;s[i])break;else dp[i]=1;
	while(m--) {
		*sd=*dp;
		for(i=1;i&lt;=n;++i)
			for(sd[i]=sd[i-1]+dp[i];sd[i]&gt;=mo;sd[i]-=mo);
		for(i=1,j=0;i&lt;=n;++i){
			while(j&lt;i&amp;&amp;s[i]-s[j]&gt;an)++j;
			for(dp[i]=sd[i-1]-sd[j-1]+mo;dp[i]&gt;=mo;dp[i]-=mo);
		}
	}
	printf(&quot;%d %d&quot;,an,dp[n]);
	return 0;
}
<pre><h2>Problem1044</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 50005
#define mo 10007
char inb[1&lt;&lt;15],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;15,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
    while(c=getc(),c&lt;'0');a=c-'0';
    while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return a;
}
int n,m,L[N],dp[N],sd[N],sum[N];
inline bool check(int mid) {
    int tot=0,s=0;
    for(int i=1;i&lt;=n;++i) {
        if(s+L[i]&gt;mid) {s=L[i];if(++tot&gt;m)return false;}
        else s+=L[i];
    }return true;
}
inline void mov(int&amp;a,int b) {for(a=b;a&gt;=mo;a-=mo);}
int main() {
    register int l=-1,r=0,mid,ans,i,j;
    n=geti(),m=geti();
    for(i=1;i&lt;=n;++i)
        sum[i]=sum[i-1]+(L[i]=geti()),l&lt;L[i]?l=L[i]:1;
    for(r=sum[n];l&lt;=r;){
        if(check(mid=l+r&gt;&gt;1)) r=(ans=mid)-1;
        else l=mid+1;
    }
    for(int i=0;i&lt;=n;++i)
        if(ans&gt;=sum[i]) dp[i]=1; else break;
    while(m--) {
        j=0;sd[0]=dp[0];
        for(i=1;i&lt;=n;++i) mov(sd[i],dp[i]+sd[i-1]);
        for(i=1;i&lt;=n;++i) {
            while(j&lt;i&amp;&amp;sum[i]-sum[j]&gt;ans)++j;
            mov(dp[i],sd[i-1]-sd[j-1]+mo);
        }
    }return printf(&quot;%d %d\n&quot;,ans,dp[n]),0;
}<pre><h2>Problem1044</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 50005
#define mo 10007
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
    while(c=getc(),c&lt;'0');a=c-'0';
    while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return a;
}
int n,m,L[N],dp[N],sd[N],sum[N];
inline bool check(int mid) {
    int tot=0,s=0;
    for(int i=1;i&lt;=n;++i) {
        if(s+L[i]&gt;mid) {s=L[i];if(++tot&gt;m)return false;}
        else s+=L[i];
    }return true;
}
inline void mov(int&amp;a,int b) {for(a=b;a&gt;=mo;a-=mo);}
int main() {
    register int l=-1,r=0,mid,ans,i,j;
    n=geti(),m=geti();
    for(i=1;i&lt;=n;++i)
        sum[i]=sum[i-1]+(L[i]=geti()),l&lt;L[i]?l=L[i]:1;
    for(r=sum[n];l&lt;=r;)
        if(check(mid=l+r&gt;&gt;1))r=(ans=mid)-1;
        else l=mid+1;
    for(int i=0;i&lt;=n;++i)
        if(ans&gt;=sum[i]) dp[i]=1; else break;
    while(m--) {
        j=0;sd[0]=dp[0];
        for(i=1;i&lt;=n;++i) mov(sd[i],dp[i]+sd[i-1]);
        for(i=1;i&lt;=n;++i) {
            while(j&lt;i&amp;&amp;sum[i]-sum[j]&gt;ans)++j;
            mov(dp[i],sd[i-1]-sd[j-1]+mo);
        }
    }return printf(&quot;%d %d\n&quot;,ans,dp[n]),0;
}
<pre><h2>Problem1045</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
char inb[1&lt;&lt;17],*ins=inb,*ine=inb;
#define getc ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;17,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
	while(c=getc,c&lt;'0');a=c-'0';
	while(c=getc,'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 1000000
int a[N],b[N];
int main() {
	register int n=geti(),i;
	register long long avg=0;
	for(i=0;i^n;++i)avg+=(a[i]=geti());
	avg/=n;
	for(i=1;i^n;++i)b[i]=b[i-1]+a[i]-avg;
	std::sort(b,b+n);
	i=b[n&gt;&gt;1];avg=0;
	for(--n;~n;--n)avg+=(b[n]&lt;i?i-b[n]:b[n]-i);
	printf(&quot;%lld\n&quot;,avg);
	return 0;
}
<pre><h2>Problem1046</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 10005
#define swap(a,b) (a^=b^=a^=b)
int a[N],d[N],dp[N];
int main() {

	register int n=geti(),i,l,r,m,an,len;
	for(i=n;i;--i)a[i]=geti(),d[i]=-0x7f7f7f7f;
	len=dp[1]=1;*d=0x7f7f7f7f,d[1]=a[1];
	for(i=2;i&lt;=n;++i) {
		for(l=0,r=len+1;l&lt;=r;)
			if(a[i]&lt;d[m=l+r&gt;&gt;1])l=(an=m)+1;
			else r=m-1;
		if(len&lt;(dp[i]=++an))len=dp[i];
		d[an]&lt;a[i]?d[an]=a[i]:1;
	}
	for(l=1,r=n;l&lt;r;++l,--r)
		swap(a[l],a[r]),swap(dp[l],dp[r]);
	for(m=geti();m;--m) {
		if(len&lt;(l=geti())){puts(&quot;Impossible&quot;);continue;}
		for(i=1,r=-0x7f7f7f7f;i&lt;=n&amp;&amp;l;++i)
			if(dp[i]&gt;=l&amp;&amp;a[i]&gt;r)printf(&quot;%d%c&quot;,r=a[i],(--l)?' ':'\n');
	}return 0;
}<pre><h2>Problem1047</h2><pre>#include &lt;cstdio&gt;
inline int min(int a,int b){return a&lt;b?a:b;}
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int v[1005][1005],q[1005],mx[1005][1005],mi[1005][1005],t1[1005],t2[1005];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1047.in&quot;,&quot;r&quot;,stdin);
#endif
	register int a=geti(),b=geti(),n=geti(),*l,*r;
	for(register int i=0,j;i&lt;a;++i)
		for(j=0;j&lt;b;++j)v[i][j]=geti();
	for(register int i=0,j;i&lt;a;++i) {
		for(j=0,l=r=q;j&lt;b;++j) {
			while(l&lt;r&amp;&amp;v[i][*(r-1)]&lt;=v[i][j])--r;
			*r++=j;
			while(*l+n&lt;=j)++l;
			if(j+2&gt;n)mx[i][j]=v[i][*l];
		}
		for(j=0,l=r=q;j&lt;b;++j) {
			while(l&lt;r&amp;&amp;v[i][*(r-1)]&gt;=v[i][j])--r;
			*r++=j;
			while(*l+n&lt;=j)++l;
			if(j+2&gt;n)mi[i][j]=v[i][*l];
		}
	}
	int ans=0x7f7f7f7f;
	for(register int i=n-1,j;i&lt;b;++i) {
		for(j=0,l=r=q;j&lt;a;++j) {
			while(l&lt;r&amp;&amp;mx[*(r-1)][i]&lt;=mx[j][i])--r;
			*r++=j;
			while(*l+n&lt;=j)++l;
			if(j+2&gt;n)t1[j]=mx[*l][i];
		}
		for(j=0,l=r=q;j&lt;a;++j) {
			while(l&lt;r&amp;&amp;mi[*(r-1)][i]&gt;=mi[j][i])--r;
			*r++=j;
			while(*l+n&lt;=j)++l;
			if(j+2&gt;n)t2[j]=mi[*l][i];
		}
		for(j=n-1;j&lt;a;++j)ans=min(ans,t1[j]-t2[j]);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1048</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int s[11][11];
double dp[11][11][11][11][11],ave;
//ANS =sqrt(sum{(submart-ave)^2/n}
inline void cmin(double&amp;a,double b){b&lt;a?a=b:1.0;}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1048.in&quot;,&quot;r&quot;,stdin);
#endif
	register int a=geti(),b=geti(),n=geti(),l,r,u,d,i,j;
	for(i=1,j;i&lt;=a;++i)
		for(j=1;j&lt;=b;++j)
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+geti();
	double ave=(double)s[a][b]/n;
	for(u=1;u&lt;=a;++u)
		for(d=u;d&lt;=a;++d)
			for(l=1;l&lt;=b;++l)
				for(r=l;r&lt;=b;++r)
					{
						double&amp;t=dp[1][u][l][d][r]=s[d][r]+s[u-1][l-1]-s[u-1][r]-s[d][l-1];
						t=(t-ave)*(t-ave);
					}
	for(register int k=2;k&lt;=n;++k) {
//		printf(&quot;Round %d:\n&quot;,k);
		for(u=1;u&lt;=a;++u)
			for(d=u;d&lt;=a;++d)
				for(l=1;l&lt;=b;++l)
					for(r=l;r&lt;=b;++r) {
						double &amp;t=dp[k][u][l][d][r];t=1e20;
						if((r-l+1)*(d-u+1)&lt;k)continue;
						for(i=l;i&lt;r;++i)
							for(j=1;j&lt;k;++j)
								cmin(t,dp[j][u][l][d][i]+dp[k-j][u][i+1][d][r]);
						for(i=u;i&lt;d;++i)
							for(j=1;j&lt;k;++j)
								cmin(t,dp[j][u][l][i][r]+dp[k-j][i+1][l][d][r]);
//						printf(&quot;%d %d %d %d %.2lf\n&quot;,u,l,d,r,t);
					}
	}
	printf(&quot;%.2lf\n&quot;,sqrt(dp[n][1][1][a][b]/n));
	return 0;
}
<pre><h2>Problem1049</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 35002
int a[N],f[N],d[N];
long long g[N],c1[N],c2[N];
struct E{int to;E*nt;}CD[N],*hd[N],*cd=CD;
template&lt;class T&gt;inline void cmin(T&amp;a,T b){b&lt;a?a=b:1;}
inline int ibs(int a){return a&lt;0?-a:a;}
inline void adde(int a,int b){cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++;}
int main() {
	register int n=geti()+1,i,l,r,m,an,len=0;
	for(i=1;i&lt;n;++i)a[i]=geti()-i,d[i]=0x7f7f7f7f;
	*a=-0x7f7f7f7f,a[n]=0x7f7f7f7f;
	*d=-0x7f7f7f7f,d[n]=0x7f7f7f7f;
	for(i=1;i&lt;=n;++i) {
		for(l=1,r=len,an=0;l&lt;=r;)
			if(a[i]&gt;=d[m=l+r&gt;&gt;1])l=(an=m)+1;
			else r=m-1;
		if(len&lt;++an)len=an;
		cmin(d[f[i]=an],a[i]);
	}
	for(i=n;~i;--i)adde(f[i],i),g[i]=1LL&lt;&lt;60;
	E*it; *g=0;
	for(i=1;i&lt;=n;++i)
		for(it=hd[f[i]-1];it;it=it-&gt;nt) {
			if(i&lt;(l=it-&gt;to))break;
			if(a[i]&lt;a[l])continue;
			for(r=l;r&lt;=i;++r)
				c1[r]=ibs(a[r]-a[l]),c2[r]=ibs(a[r]-a[i]);
			for(r=l+1;r&lt;=i;++r)
				c1[r]+=c1[r-1],c2[r]+=c2[r-1];
			for(r=l;r&lt;i;++r)
				cmin(g[i],g[l]+c1[r]-c1[l]+c2[i]-c2[r]);
		}
	return printf(&quot;%d\n%lld\n&quot;,n-f[n],g[n]),0;
}
<pre><h2>Problem1050</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int f[501];
inline int gf(int u) {
	int r;
	for(r=u;f[r]^r;r=f[r]);
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
inline int gcd(int a,int b) {
	for(int t;b;t=a%b,a=b,b=t);
	return a;
}
struct E{int x,y,v;}e[5000];
inline bool operator &lt; (const E&amp;a,const E&amp;b){return a.v&lt;b.v;}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1050.in&quot;,&quot;r&quot;,stdin);
#endif
	/*register*/ int n=geti(),m=geti(),i,j,s,t,a1=30000,a2=1;
	for(i=0;i&lt;m;++i)e[i]=(E){geti(),geti(),geti()};
	s=geti(),t=geti();
	std::sort(e,e+m);
	for(j=1;j&lt;=n;++j)f[j]=j;
	for(j=0;j&lt;m;++j) {
		f[gf(e[j].x)]=gf(e[j].y);
		if(gf(s)==gf(t)) {
			if(e[j].v*a2&lt;e[0].v*a1)a1=e[j].v,a2=e[0].v;
			break;
		}
		if(e[j].v*a2&gt;=e[0].v*a1)break;
	}
	if(a1&gt;=30000)return puts(&quot;IMPOSSIBLE&quot;),0;
	for(i=1;i&lt;m;++i) {
		for(j=1;j&lt;=n;++j)f[j]=j;
		for(j=i;j&lt;m;++j) {
			f[gf(e[j].x)]=gf(e[j].y);
			if(gf(s)==gf(t)) {
				if(e[j].v*a2&lt;e[i].v*a1)a1=e[j].v,a2=e[i].v;
				break;
			}
			if(e[j].v*a2&gt;=e[i].v*a1)break;
		}
	}
	i=gcd(a1,a2);
	if(a2^i)printf(&quot;%d/%d\n&quot;,a1/i,a2/i);
	else printf(&quot;%d\n&quot;,a1/a2);
	return 0;
}
<pre><h2>Problem1051</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline void cmin(int&amp;a,int b){b&lt;a?a=b:1;}
struct E{int to;E*nt;}CD[50000],*cd=CD,*hd[10001];
int dfn[10001],_clock,bel[10001],st[10001],tp,bc,sz[10001];
bool deg[10001];
int dfs(int u) {
	int low=dfn[u]=++_clock,v;
	st[++tp]=u;
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(!dfn[v=it-&gt;to])cmin(low,dfs(v));
		else if(!bel[v])cmin(low,dfn[v]);
	if(low==dfn[u]) {
		++bc;
		do{
			v=st[tp--];
			bel[v]=bc;
			++sz[bc];
		}while(v^u);
	}return low;
}
int main() {
	register int n=geti(),m=geti(),i,j;
	E*it;
	while(m--) {
		i=geti(),j=geti();
		cd-&gt;to=j,cd-&gt;nt=hd[i];
		hd[i]=cd++;
	}
	for(i=1;i&lt;=n;++i)if(!dfn[i])dfs(i);
	for(i=1;i&lt;=n;++i)
		for(it=hd[i],j=bel[i];it;it=it-&gt;nt)
			if(j^bel[it-&gt;to]){deg[j]=1;break;}
	for(m=0,i=1;i&lt;=bc;++i)
		if(!deg[i]) (m)?(m=0,i=bc+1):(m=sz[i]);
	printf(&quot;%d\n&quot;,m);
	return 0;
}
<pre><h2>Problem1052</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
int m,inf=1e9;
inline int min(int a,int b){return a&lt;b?a:b;}
inline int max(int a,int b){return a&lt;b?b:a;}
struct D{int x[20005],y[20005],tp;}a;
inline void cut(D&amp;a,int x1,int y1,int x2,int y2) {
	int tp=0;
	for(int i=1;i&lt;=a.tp;++i)
		if(a.x[i]&lt;x1||a.x[i]&gt;x2||a.y[i]&lt;y1||a.y[i]&gt;y2) {
			++tp;
			a.x[tp]=a.x[i];
			a.y[tp]=a.y[i];
		}a.tp=tp;
}
inline void cc(D&amp;a,int f) {
	int x1=inf,y1=inf,x2=-inf,y2=-inf;
	for(int i=1;i&lt;=a.tp;++i) {
		x1=min(a.x[i],x1);x2=max(a.x[i],x2);
		y1=min(a.y[i],y1);y2=max(a.y[i],y2);
	}
	if(f==1)cut(a,x1,y1,x1+m,y1+m);
	else if(f==2)cut(a,x2-m,y1,x2,y1+m);
	else if(f==3)cut(a,x1,y2-m,x1+m,y2);
	else cut(a,x2-m,y2-m,x2,y2);
}
inline bool check() {
	D b;
	for(int x=1;x&lt;5;++x)
		for(int y=1;y&lt;5;++y) {
			b.tp=a.tp;
			for(int i=1;i&lt;=b.tp;++i)
				b.x[i]=a.x[i],b.y[i]=a.y[i];
			cc(b,x);cc(b,y);
			int x1=inf,y1=inf,x2=-inf,y2=-inf;
			for(int i=1;i&lt;=b.tp;++i) {
				x1=min(b.x[i],x1);x2=max(b.x[i],x2);
				y1=min(b.y[i],y1);y2=max(b.y[i],y2);
			}
			if(x2-x1&lt;=m&amp;&amp;y2-y1&lt;=m)return true;
		}return false;
}
int main() {
	a.tp=geti();
	for(int i=1;i&lt;=a.tp;++i)
		a.x[i]=geti(),a.y[i]=geti();
	int L=1,R=inf,ans;
	while(L&lt;=R)
		if(m=L+R&gt;&gt;1,check())ans=m,R=m-1;
		else L=m+1;
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1053</h2><pre>#include&lt;cstdio&gt;
int a[1000]={1396755360,1102701600,735134400,698377680,551350800,367567200,294053760,245044800,183783600,147026880,122522400,110270160,73513440,61261200,43243200,36756720,32432400,21621600,17297280,14414400,10810800,8648640,7207200,6486480,4324320,3603600,2882880,2162160,1441440,1081080,720720,665280,554400,498960,332640,277200,221760,166320,110880,83160,55440,50400,45360,27720,25200,20160,15120,10080,7560,5040,2520,1680,1260,840,720,360,240,180,120,60,48,36,24,12,6,4,2,1,0};
int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;;i++)
    {
        if(n&gt;=a[i])
        {
            printf(&quot;%d\n&quot;,a[i]);
            return 0;
        }
    }
}<pre><h2>Problem1053</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int p[15]={1,2,3,5,7,11,13,17,19,23,29,31};
int n,a,ac;
void dfs(int k,int v,int c,int la) {
	if(k&gt;13) {
		if(v&gt;a&amp;&amp;c&gt;ac)a=v,ac=c;
		else if(v&lt;=a&amp;&amp;c&gt;=ac)a=v,ac=c;
	}else {
		int t=1;
		for(int i=0;i&lt;=la;++i) {
			dfs(k+1,v*t,c*(i+1),i);
			if(1LL*v*(t*=p[k])&gt;n)break;
		}
	}
}
int main() {
	n=geti(),a=ac=1;
	dfs(1,1,1,20);
	printf(&quot;%d&quot;,a);
	return 0;
}
<pre><h2>Problem1055</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int t[4];
char replace[4][20][2],s[202],f[202][202][4];
const char p[]={'W','I','N','G'};
inline int ps(const char&amp;c) {
	if(c=='W') return 0;
	if(c=='I') return 1;
	if(c=='N') return 2;
	return 3;
}
bool dp(const int&amp;l,const int&amp;r,const int&amp;k) {
	if(l&gt;=r)return s[l]==p[k];
	char&amp;rt=f[l][r][k];
	if(~rt)return rt;
	for(int i=0;i&lt;t[k];++i)
		for(int j=l;j&lt;r;++j)
			if(dp(l,j,ps(replace[k][i][0]))&amp;&amp;dp(j+1,r,ps(replace[k][i][1])))
				return rt=1;
	return rt=0;
}
int main() {
	for(int i=0;i&lt;4;++i)scanf(&quot;%d&quot;,t+i);
	for(int i=0;i&lt;4;++i)
		for(int j=0;j&lt;t[i];++j)
			scanf(&quot;%s&quot;,replace[i][j]);
	scanf(&quot;%s&quot;,s);
	int le=strlen(s),ok=0;
	memset(f,-1,sizeof f);
	for(int i=0;i&lt;4;++i)
		if(dp(0,le-1,i))ok=1,putchar(p[i]);
	if(!ok)puts(&quot;The name is wrong!&quot;);
	return 0;
}<pre><h2>Problem1059</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int vis[202],_clock,f[202];
struct E{int to;E*nt;}CD[40002],*cd,*hd[202];
inline void adde(int a,int b){cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++;}
bool dfs(int u) {
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(_clock^vis[it-&gt;to]){
			vis[it-&gt;to]=_clock;
			if(!f[it-&gt;to]||dfs(f[it-&gt;to]))
				return f[it-&gt;to]=u;
		}
	return 0;
}
int main() {
	register int T=geti(),n,i,j;
	while(T--) {
		cd=CD; n=geti();
		for(i=1;i&lt;=n;++i)hd[i]=NULL,f[i]=0;
		for(i=1;i&lt;=n;++i)
			for(j=1;j&lt;=n;++j)
				if(geti())adde(i,j);
		for(i=1;i&lt;=n;++i)
			if(++_clock,!dfs(i))break;
		puts(i&gt;n?&quot;Yes&quot;:&quot;No&quot;);
	}return 0;
}
<pre><h2>Problem1060</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline void cmax(long long&amp;a,long long b){a&lt;b?a=b,1:1;}
#define N 500002
struct E{int to,v;E*nt;}CD[1000001],*cd=CD,*hd[N];
#define adde(a,b,c) (cd-&gt;to=b,cd-&gt;v=c,cd-&gt;nt=hd[a],hd[a]=cd++)
int que[N],f[N]; long long d[N];
int main() {
	register int n=geti(),s=geti();
	for(register int a,b,c,i=1;i&lt;n;++i) {
		a=geti(),b=geti(),c=geti();
		adde(a,b,c);adde(b,a,c);
	}
	int*l=que,*r=que; E*it;
	*r++=s;
	while(l&lt;r)
		for(it=hd[s=*l++];it;it=it-&gt;nt)
			if(it-&gt;to^f[s])f[*r++=it-&gt;to]=s;
	long long ans=0LL;
	for(l=que-1,--r;l&lt;r;--r) {
		for(it=hd[s=*r];it;it=it-&gt;nt)
			if(it-&gt;to^f[s])cmax(d[s],d[it-&gt;to]+it-&gt;v);
		for(it=hd[s];it;it=it-&gt;nt)
			if(it-&gt;to^f[s])ans+=d[s]-d[it-&gt;to]-it-&gt;v;
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1060</h2><pre>#include &lt;cstdio&gt;
int ina; char inc,inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	while(inc=getc(),inc&lt;'0');ina=inc-'0';
	while(inc=getc(),'-'&lt;inc)ina=(ina&lt;&lt;3)+(ina&lt;&lt;1)+inc-'0';
	return ina;
}
#define N 500002
struct E{int to,w; E*nxt;}CD[N&lt;&lt;1],*cd=CD,*head[N];
#define adde(a,b,c){							\
		cd-&gt;to=b,cd-&gt;w=c,cd-&gt;nxt=head[a];		\
		head[a]=cd++;							\
	}
long long d[N],__t,ans;
#define cmax(a,b) (a&lt;(__t=(b))?a=__t:1)
void cal(const int&amp;u,const int&amp;f) {
	E *it;
	for(it=head[u];it;it=it-&gt;nxt)
		if(it-&gt;to^f) {cal(it-&gt;to,u);cmax(d[u],d[it-&gt;to]+it-&gt;w);}
	for(it=head[u];it;it=it-&gt;nxt)
		if(it-&gt;to^f) ans+=d[u]-d[it-&gt;to]-it-&gt;w;
}
int main() {
	int n,i,s,a,b,c;
	n=geti(),s=geti();
	for(i=1;i&lt;n;++i) {
		a=geti(),b=geti(),c=geti();
		adde(a,b,c);adde(b,a,c);
	}cal(s,0);
	return printf(&quot;%lld\n&quot;,ans);
}
<pre><h2>Problem1061</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

#define inf 0x3f3f3f3f
typedef int edge[50003], vert[1003];
edge nt, c, w, to;
vert d, hd, q, from;
int ce, T;
bool inq[1003];
inline void adde(int x, int y, int z, int v) {
	to[ce] = y, nt[ce] = hd[x];
	c[ce] = z, w[ce] = v;
	hd[x] = ce++;
}
#define nxt(i) (++(i)&gt;=1003?i=0:i)
inline bool SPFA() {
	static int u, v, i, l, r;
	for (i = 1; i &lt;= T; ++i) d[i] = inf;
	d[0] = 0; q[0] = 0; from[0] = -1;
	for (l = 0, r = 1; l ^ r; ) {
		u = q[l]; nxt(l);
		for (i = hd[u]; ~i; i = nt[i])
			if (c[i] &amp;&amp; d[v = to[i]] &gt; w[i] + d[u]) {
				d[v] = w[i] + d[u];
				from[v] = i;
				if (!inq[v]) inq[v] = true, q[r] = v, nxt(r);
			}
		inq[u] = false;
	}
	return d[T] &lt; inf;
}

inline int mcf() {
	static int f, e, ret;
	for (f = inf, e = from[T], ret = 0; ~e; e = from[to[e^1]]) f = min(f, c[e]), ret += w[e];
	for (e = from[T]; ~e; e = from[to[e^1]]) c[e] -= f, c[e^1] += f;
	return f * ret;
}

int main() {
	int n, m, i, x, y, v;
	memset(hd, -1, sizeof hd);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	T = n + 2;
	for (y = 0, i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		v = x - y;
		y = x;
		if (v &gt; 0) adde(0, i, v, 0), adde(i, 0, 0, 0);
		else adde(i, T, -v, 0), adde(T, i, 0, 0);
		adde(i + 1, i, inf, 0), adde(i, i + 1, 0, 0);
	}
	adde(n + 1, T, y, 0), adde(T, n + 1, 0, 0);
	while (m--) {
		scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v);
		++y;
		adde(x, y, inf, v), adde(y, x, 0, -v);
	}
	v = 0;
	while (SPFA())
		v += mcf();
	printf(&quot;%d\n&quot;, v);
	return 0;
}
<pre><h2>Problem1061</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long ll;
const int M=10005,N=1005,INF=1e9;
const double eps=1e-6;
inline int read(){
    char c=getchar();int x=0,f=1;
    while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1; c=getchar();}
    while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0'; c=getchar();}
    return x*f;
}

int n,m;
double a[M][N],b[M],c[N],v;
void pivot(int l,int e){
    b[l]/=a[l][e];
    for(int j=1;j&lt;=n;j++) if(j!=e) a[l][j]/=a[l][e];
    a[l][e]=1/a[l][e];
    
    for(int i=1;i&lt;=m;i++) if(i!=l&amp;&amp;fabs(a[i][e])&gt;0){
        b[i]-=a[i][e]*b[l];
        for(int j=1;j&lt;=n;j++) if(j!=e) a[i][j]-=a[i][e]*a[l][j];
        a[i][e]=-a[i][e]*a[l][e];
    }
    
    v+=c[e]*b[l];
    for(int j=1;j&lt;=n;j++) if(j!=e) c[j]-=c[e]*a[l][j];
    c[e]=-c[e]*a[l][e];
    
    //swap(B[l],N[e])
}

double simplex(){
    while(true){
        int e=0,l=0;
        for(e=1;e&lt;=n;e++) if(c[e]&gt;eps) break;
        if(e==n+1) return v;
        double mn=INF;
        for(int i=1;i&lt;=m;i++)
            if(a[i][e]&gt;eps&amp;&amp;mn&gt;b[i]/a[i][e]) mn=b[i]/a[i][e],l=i;
        if(mn==INF) return INF;//unbounded
        pivot(l,e);
    }
}

int main(){
    n=read();m=read();
    for(int i=1;i&lt;=n;i++) c[i]=read();
    for(int i=1;i&lt;=m;i++){
        int s=read(),t=read();
        for(int j=s;j&lt;=t;j++) a[i][j]=1;
        b[i]=read();
    }
    printf(&quot;%d&quot;,(int)(simplex()+0.5));
}<pre><h2>Problem1061</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
inline int gi() {
	static int a; static char c;
	while ((c = getchar()) &lt; '0'); a = c - '0';
	while ('-' &lt; (c = getchar())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
const int N = 1003, M = 10003;
const double inf = 1e9, eps = 1e-9;
int n, m;
double a[M][N], b[M], c[N], v;
void pivot(int l, int e) {
	static int i, j;
	b[l] /= a[l][e];
	for (j = 1; j &lt;= n; ++j) if (j ^ e) a[l][j] /= a[l][e];
	a[l][e] = 1 / a[l][e];
	for (i = 1; i &lt;= m; ++i)
		if ((i ^ l) &amp;&amp; fabs(a[i][e]) &gt; 0) {
			b[i] -= a[i][e] * b[l];
			for (j = 1; j &lt;= n; ++j) if (j ^ e) a[i][j] -= a[i][e] * a[l][j];
			a[i][e] = -a[i][e] * a[l][e];
		}
	v += c[e] * b[l];
	for (j = 1; j &lt;= n; ++j) if (j ^ e) c[j] -= c[e] * a[l][j];
	c[e] = -c[e] * a[l][e];
}
double simplex() {
	int e, l, i;
	double mn;
	while (true) {
		for (e = 1; e &lt;= n; ++e) if(c[e] &gt; eps) break;
		if (e &gt; n) return v;
		for (i = 1, mn = inf; i &lt;= m; ++i)
			if (a[i][e] &gt; eps &amp;&amp; mn &gt; b[i] / a[i][e]) mn = b[i] / a[i][e], l = i;
		if (mn == inf) return inf;
		pivot(l, e);
	}
}

int main() {
	int i, j, s, t;
	n = gi(), m = gi();
	for (i = 1; i &lt;= n; ++i) c[i] = gi();
	for (i = 1; i &lt;= m; ++i) {
		s = gi(), t = gi();
		for (j = s; j &lt;= t; ++j) a[i][j] = 1;
		b[i] = gi();
	}
	printf(&quot;%d&quot;, (int)(simplex() + 0.5));
	return 0;
}
<pre><h2>Problem1062</h2><pre>#include &lt;cstdio&gt;
inline int gi() {
	static char c, f; static int a; f = 0;
	while (c = getchar(), c &lt; '0') f |= c == '-'; a = c - '0';
	while (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return f? -a : a;
}
#define N 2003
#define M 4003
int len, len2, len4, C[2][N][M], X[1000003], Y[1000003];

inline void add(int tr[N][M], int x, int y, int v) {
	static int i, j; ++x, ++y;
	for (i = x; i &lt;= len2; i += i &amp; -i)
		for (j = y; j &lt;= len4; j += j &amp; -j)
			tr[i][j] += v;
}

inline int sum(int tr[N][M], int x, int y) {
	if (x &lt; 0 || y &lt; 0) return 0;
	static int i, j, ans;
	if (++x &gt; len2) x = len2 + 1;
	if (++y &gt; len4) y = len4 + 1;
	ans = 0;
	for (i = x; i; i -= i &amp; -i)
		for (j = y; j; j -= j &amp; -j)
			ans += tr[i][j];
	return ans;
}

inline int sum(int tr[N][M], int x1, int y1, int x2, int y2) {
	--x1, --y1;
	return sum(tr, x2, y2) + sum(tr, x1, y1) - sum(tr, x1, y2) - sum(tr, x2, y1);
}

int main() {
	int __ = gi(), t, c, l, r, d, ___;
	len = gi(), len2 = len &lt;&lt; 1, len4 = len &lt;&lt; 2;
	while (__--) {
		___ = gi(), t = gi();
		if (___ &lt; 2) {
			c = gi(), l = gi(), r = gi(), d = gi();
			int &amp;x = X[c], &amp;y = Y[c];
			x = (t - d * l + len2) % len2;
			y = r - l;
			add(C[0], x, x + y, 1);
			add(C[1], x, y - x + len2, 1);
		} else if (___ &lt; 3) {
			l = gi(), r = gi();
			t %= len2;
			d = (r ^ len) ? 0 : 1;
			printf(&quot;%d\n&quot;,
				   sum(C[0], t, l + t, r + t, len4) + sum(C[0], 0, l + t - len2, r + t - len2 - d, len4) + sum(C[1], t - r + len2 + d, l - t, len2, len4) + sum(C[1], t - r, l - t + len2, t - 1, len4)
				);
		} else {
			c = gi();
			add(C[0], X[c], Y[c] + X[c], -1);
			add(C[1], X[c], Y[c] - X[c] + len2, -1);
		}
	}
}
<pre><h2>Problem1063</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
	static int a; static char c;
	while ((c = getchar()) &lt; '0'); a = c - '0';
	while ('-' &lt; (c = getchar())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
#define N 100003
int f[N], dp[3][12][N], Q;
struct edge {int t; edge *n;}me[200003], *ce = me, *hd[N];
inline void adde(int a, int b) {
	ce-&gt;t = b, ce-&gt;n = hd[a];
	hd[a] = ce++;
}
inline int gf(int u) {
	static int r, t;
	for (r = u; f[r] ^ r; r = f[r]);
	while (u ^ r) t = f[u], f[u] = r, u = t;
	return r;
}

inline int gn(const long long &amp;a) {
	static int t;
	if (!a) return 0;
	return (t = a % Q) ? t : Q;
}

void dfs(int u, int k, int fa) {
	int v, t1, t2;
	int &amp;d0 = dp[0][k][u];
	int &amp;d1 = dp[1][k][u];
	int &amp;d2 = dp[2][k][u];
	d0 = 1;
	for (edge *it = hd[u]; it; it = it-&gt;n)
		if ((v = it-&gt;t) ^ fa) {
			dfs(v, k, u);
			t1 = k ? gn((long long)dp[0][k-1][v]+dp[1][k-1][v]+dp[2][k-1][v]) : 0;
			t2 = gn((long long)dp[0][k][v] + dp[1][k][v]);
			d2 = gn((long long)d2*t1 + (long long)d1*t2);
			d1 = gn((long long)d1*t1 + (long long)d0*t2);
			d0 = gn((long long)d0*t1);
		}
}

int main() {
	int n = gi(), m = gi(), i, a, b;
	Q = gi();
	for (i = 1; i &lt;= n; ++i) f[i] = i;
	while (m--) {
		f[gf(a = gi())] = gf(b = gi());
		adde(a, b); adde(b, a);
	}
	for (i = 1; i &lt; n; ++i) if (gf(i) ^ gf(n)) return puts(&quot;-1\n-1&quot;), 0;
	for (i = 0; ; ++i) {
		dfs(1, i, 0);
		if (a = dp[0][i][1] + dp[1][i][1] + dp[2][i][1]) {
			printf(&quot;%d\n%d\n&quot;, i, a % Q);
			break;
		}
	}
	return 0;
}
<pre><h2>Problem1064</h2><pre>#include &lt;cstdio&gt;
inline int gi() {
	static int a; static char c;
	while ((c = getchar()) &lt; '0'); a = c - '0';
	while ('-' &lt; (c = getchar())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
#define N 100003
struct edge{int t, w; edge *n;}me[2000003], *ce = me, *hd[N];
inline void adde(int a, int b, int c) {
	ce-&gt;t = b, ce-&gt;w = c;
	ce-&gt;n = hd[a], hd[a] = ce++;
}
bool vis[N]; int dep[N], mx, mi, t;

inline int gcd(int a, int b) {
	for (int t; b; t = a % b, a = b, b = t);
	return a;
}
inline int abs(const int &amp;a) {
	return a &lt; 0 ? -a : a;
}
void dfs(int u) {
	vis[u] = true;
	if (mx &lt; dep[u]) mx = dep[u];
	if (dep[u] &lt; mi) mi = dep[u];
	for (edge *it = hd[u]; it; it = it-&gt;n)
		if (!vis[it-&gt;t]){
			dep[it-&gt;t] = dep[u] + it-&gt;w;
			dfs(it-&gt;t);
		} else t = gcd(abs(dep[u] + it-&gt;w - dep[it-&gt;t]),t);
}

int main() {
	int n = gi(), m = gi(), a, b, i, sum = 0;
	while (m--) {
		a = gi(), b = gi();
		adde(a, b, 1); adde(b, a, -1);
	}
	for (i = 1; i &lt;= n; ++i) if (!vis[i]) {
			mx = mi = 0;
			dfs(i);
			sum += mx - mi + 1;
		}
	if (!t) (sum &lt; 3) ? puts(&quot;-1 -1&quot;) : printf(&quot;%d %d\n&quot;, sum, 3);
	else if (t &lt; 3) puts(&quot;-1 -1&quot;);
	else {
		for (i = 3; t % i; ++i);
		printf(&quot;%d %d\n&quot;, t, i);
	}
	return 0;
}
<pre><h2>Problem1065</h2><pre>#include &lt;cstdio&gt;
#define N 63
#define oo 1e22
struct edge{int t; edge *n;}me[N], *ce, *hd[N];
inline void adde(int a, int b) {
	ce-&gt;t = b, ce-&gt;n = hd[a];
	hd[a] = ce++;
}
int size[N], nxt[N], n, m;
double dp[N][N][N], kk[N], tmp[N][N], C[N], k;
inline void cmax(double &amp;a, double b) {
	if (a &lt; b) a = b;
}
inline void init() {
	static int i, j, k;
	for (i = 0; i &lt;= n; hd[i++] = NULL)
		for (j = 0; j &lt;= n; ++j)
			for (k = 0; k &lt;= n; ++k)
				dp[i][j][k] = -oo;
	ce = me;
}
inline void backpack(int u, int dep) {
	static int s, j, k, v; static edge *it;
	for (j = 0; j &lt;= size[u]; ++j)
		for (k = 0; k &lt;= m; ++k)
			tmp[j][k] = -oo;
	tmp[0][0] = 0.0;
	for (it = hd[u], s = 1; it; it = it-&gt;n, ++s) {
		v = it-&gt;t;
		for (j = 0; j &lt;= m; ++j)
			for (k = 0; k &lt;= j; ++k)
				cmax(tmp[s][j], tmp[s-1][k] + dp[v][j - k][dep]);
	}
}
void dfs(int u) {
	size[u] = 0;
	for (edge *it = hd[u]; it; it = it-&gt;n, ++size[u]) dfs(it-&gt;t);
	backpack(u, 2);
	for (int i = 0; i &lt;= n; ++i)
		for (int j = 1; j &lt;= m; ++j)
			dp[u][j][i] = tmp[size[u]][j-1] + C[u] * k;
	for (int i = 0; i &lt;= n; ++i) {
		backpack(u, i + 1);
		for (int j = 0; j &lt;= m; ++j)
			cmax(dp[u][j][i], tmp[size[u]][j] + C[u] * kk[i]);
	}
}
int main() {
	int i, j, len; double ans = -oo;
	scanf(&quot;%d%d%lf&quot;, &amp;n, &amp;m, &amp;k);
	for (i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, nxt + i);
	for (i = 1; i &lt;= n; ++i) scanf(&quot;%lf&quot;, C + i);
	kk[0] = 1; kk[1] = k;
	for (i = 2; i &lt; N; ++i) kk[i] = kk[i-1] * k;
	for (i = nxt[1], len = 2; i ^ 1; i = nxt[i], ++len) {
		init();
		for (j = 2; j &lt;= n; ++j)
			if (j ^ i) adde(nxt[j], j); else adde(1, j);
		dfs(1);
		cmax(ans, dp[1][m - (nxt[i] != 1)][0] / (1.0 - kk[len]));
	}
	printf(&quot;%.2lf\n&quot;, ans);
	return 0;
}
<pre><h2>Problem1066</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int rd() {
	register char c;
	while(c=getchar(),c&lt;'0');
	return c-'0';
}
char mp[22][22];
#define M 1000000
int to[M],nt[M],C[M],hd[810],te;
#define adde(a,b,c) (to[te]=b,nt[te]=hd[a],C[te]=c,hd[a]=te++)
int d[810],dt[810],la[810],S,T,r,c,d2,hx[810],hy[810];
inline bool rid(int dx,int dy){return dx*dx+dy*dy&lt;=d2;}
int dfs(int u,int flow) {
	if(u==T||!flow) return flow;
	int r=0,t;
	for(int&amp;i=la[u];~i;i=nt[i])
		if(d[u]==d[to[i]]+1&amp;&amp;C[i]&gt;0) {
			t=dfs(to[i],flow&lt;C[i]?flow:C[i]);
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(!flow||d[S]&gt;T+1)return r;
		}
	la[u]=hd[u];
	if(!(--dt[d[u]])) d[S]=T+2;
	++dt[++d[u]]; return r;
}
inline int SAP() {
	register int *l=dt,*r=dt,i;
	*r++=T; d[T]=1;
	while(l&lt;r) {
		for(i=hd[*l];~i;i=nt[i])
			if(!d[to[i]]) d[*r++=to[i]]=d[*l]+1;
		++l;
	}
	memset(dt,0,sizeof dt);
	for(i=S;i&lt;=T;++i)++dt[d[i]],la[i]=hd[i];
	i=0;
	while(d[S]&lt;T+2)i+=dfs(S,0x7f7f7f7f);
	return i;
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1066.in&quot;,&quot;r&quot;,stdin);
#endif
	int d;
	scanf(&quot;%d%d%d&quot;,&amp;r,&amp;c,&amp;d);
	d2=d*d;
	memset(hd,-1,sizeof hd);
	register int i,j,k,cnt=0,tp=0;
	for(i=0;i&lt;r;++i)
		for(j=0;j&lt;c;++j)
			if(k=rd()) {
				++tp; hx[tp]=i,hy[tp]=j;
				adde(tp,tp+1,k);adde(tp+1,tp,0);
				++tp;
			}
	for(i=0;i&lt;r;++i) {
		scanf(&quot;%s&quot;,mp[i]);
		for(j=0;j&lt;c;++j)cnt+=mp[i][j]=='L';
	}
	S=0,T=tp+1;
	for(i=1;i&lt;tp;i+=2) {
		for(j=i+2;j&lt;tp;j+=2)
			if(rid(hx[i]-hx[j],hy[i]-hy[j])) {
				adde(i+1,j,cnt),adde(j,i+1,0);
				adde(j+1,i,cnt),adde(i,j+1,0);
			}
		if(mp[hx[i]][hy[i]]=='L')adde(S,i,1),adde(i,S,0);
		if(hx[i]&lt;d||hy[i]&lt;d||r-hx[i]&lt;=d||c-hy[i]&lt;=d)adde(i+1,T,cnt),adde(T,i+1,0);
	}
	printf(&quot;%d\n&quot;,cnt-SAP());
	return 0;
}
<pre><h2>Problem1066</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int rd() {
	register char c;
	while(c=getchar(),c&lt;'0');
	return c-'0';
}
char mp[22][22];
#define M 100000
int to[M],nt[M],C[M],hd[810],te;
#define adde(a,b,c) (to[te]=b,nt[te]=hd[a],C[te]=c,hd[a]=te++)
int d[810],dt[810],la[810],S,T,r,c,d2,hx[810],hy[810];
inline bool rid(int dx,int dy){return dx*dx+dy*dy&lt;=d2;}
int dfs(int u,int flow) {
	if(u==T||!flow) return flow;
	int r=0,t;
	for(int&amp;i=la[u];~i;i=nt[i])
		if(d[u]==d[to[i]]+1&amp;&amp;C[i]&gt;0) {
			t=dfs(to[i],flow&lt;C[i]?flow:C[i]);
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(!flow||d[S]&gt;T+1)return r;
		}
	la[u]=hd[u];
	if(!(--dt[d[u]])) d[S]=T+2;
	++dt[++d[u]]; return r;
}
inline int SAP() {
	register int *l=dt,*r=dt,i;
	*r++=T; d[T]=1;
	while(l&lt;r) {
		for(i=hd[*l];~i;i=nt[i])
			if(!d[to[i]]) d[*r++=to[i]]=d[*l]+1;
		++l;
	}
	memset(dt,0,sizeof dt);
	for(i=S;i&lt;=T;++i)++dt[d[i]],la[i]=hd[i];
	i=0;
	while(d[S]&lt;T+2)i+=dfs(S,0x7f7f7f7f);
	return i;
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1066.in&quot;,&quot;r&quot;,stdin);
#endif
	int d;
	scanf(&quot;%d%d%d&quot;,&amp;r,&amp;c,&amp;d);
	d2=d*d;
	memset(hd,-1,sizeof hd);
	register int i,j,k,cnt=0,tp=0;
	for(i=0;i&lt;r;++i)
		for(j=0;j&lt;c;++j)
			if(k=rd()) {
				++tp; hx[tp]=i,hy[tp]=j;
				adde(tp,tp+1,k);adde(tp+1,tp,0);
				++tp;
			}
	for(i=0;i&lt;r;++i) {
		scanf(&quot;%s&quot;,mp[i]);
		for(j=0;j&lt;c;++j)cnt+=mp[i][j]=='L';
	}
	S=0,T=tp+1;
	for(i=1;i&lt;tp;i+=2) {
		for(j=i+2;j&lt;tp;j+=2)
			if(rid(hx[i]-hx[j],hy[i]-hy[j])) {
				adde(i+1,j,cnt),adde(j,i+1,0);
				adde(j+1,i,cnt),adde(i,j+1,0);
			}
		if(mp[hx[i]][hy[i]]=='L')adde(S,i,1),adde(i,S,0);
		if(hx[i]&lt;d||hy[i]&lt;d||r-hx[i]&lt;=d||c-hy[i]&lt;=d)adde(i+1,T,cnt),adde(T,i+1,0);
	}
	printf(&quot;%d\n&quot;,cnt-SAP());
	return 0;
}
<pre><h2>Problem1067</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define MAX 50009
#define rep(i, j, k) for(int i = j; i &lt;= k; i++)

using namespace std;

int n, m, f[MAX][50];
int a[MAX], b[MAX];

inline int ask (int l, int r)
{
	if (l &gt; r)
		return -0x7fffffff;
	int t = 0;
	while (1 &lt;&lt; (t + 1) &lt;= r - l + 1)
		t++;
	return max (f[l][t], f[r - (1 &lt;&lt; t) + 1][t]);
}

int main()
{
	scanf (&quot;%d&quot;, &amp;n);
	rep (i, 1, n)
		scanf (&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);
	rep (i, 1, n)
		f[i][0] = b[i];
	for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++)
		for (int i = 1; i + (1&lt;&lt;j) - 1 &lt;= n; i ++)
			f[i][j] = max (f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);

	scanf (&quot;%d&quot;, &amp;m);
	while (m--)
	{
		int a1, a2, l, r;
		scanf (&quot;%d%d&quot;, &amp;a1, &amp;a2);
		l = lower_bound (a + 1, a + 1 + n, a1) - a;
		r = lower_bound (a + 1, a + 1 + n, a2) - a;
		int full = (a2 - a1 +1 == r - l + 1);
		if (a[r] != a2 &amp;&amp; a[l] != a1)
		{
			printf (&quot;maybe\n&quot;);
			continue;
		}
		if (a[r] != a2)
		{
			int Max = ask (l + 1, r - 1);
			if (Max &lt; b[l])
				printf (&quot;maybe\n&quot;);
			else
				printf (&quot;false\n&quot;);
			continue;
		}
		if (a[l] != a1)
		{
			int Max = ask (l, r - 1);
			if (b[r] &gt; Max)
				printf (&quot;maybe\n&quot;);
			else
				printf (&quot;false\n&quot;);
			continue;
		}
		if (b[r] &gt; b[l])
		{
			printf (&quot;false\n&quot;);
			continue;
		}
		if (full)
		{
			int Max = ask (l + 1, r - 1);
			if (Max &lt; b[r] &amp;&amp; b[r] &lt;= b[l])
				printf (&quot;true\n&quot;);
			else
				printf (&quot;false\n&quot;);
			continue;
		}
		else
		{
			int Max = ask (l + 1, r - 1);
			if (Max &lt; b[r] &amp;&amp; b[r] &lt;= b[l])
				printf (&quot;maybe\n&quot;);
			else
				printf (&quot;false\n&quot;);
		}
	}
	return 0;
}<pre><h2>Problem1067</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int Maxn=50005,INF=0x7f7f7f7f;
int f[20][Maxn],Y[Maxn],R[Maxn],n,m;
char Inb[1&lt;&lt;16],*Ins=Inb,*Ine=Inb,Inc; int Ina; bool InSign;
#define getc() ((Ins==Ine&amp;&amp;(Ine=(Ins=Inb)+fread(Inb,1,1&lt;&lt;16,stdin),Ins==Ine))?0:*Ins++)
inline int geti() {
    InSign = false;
    while(Inc=getc(),Inc&lt;'0')InSign|=Inc=='-';Ina=Inc-'0';
    while(Inc=getc(),'-'&lt;Inc)Ina=(Ina&lt;&lt;3)+(Ina&lt;&lt;1)+Inc-'0';
	return InSign?-Ina:Ina;
}
inline void Make_St() {
    for (register int i=1;i&lt;=n;++i)f[0][i]=R[i];
    for (register int j=1,i;(1&lt;&lt;j)&lt;=n;++j)
		for (i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)
			f[j][i]=max(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);
}
inline int rmq(const int &amp;l, const int &amp;r) {
    if (l &gt; r) return -INF;
    register int k = 0;
    while ((1&lt;&lt;(k+1)&lt;=r-l+1))++k;
    return max(f[k][l],f[k][r-(1&lt;&lt;k)+1]);
}
int main() {
    register int i,l,r,a,b;
    for (n=geti(),i=1;i&lt;=n;++i)Y[i]=geti(),R[i]=geti();
    m=geti();Make_St();
    while(m--) {
        a=geti(),b=geti();
        l=lower_bound(Y+1,Y+n+1,a)-Y;
        r=lower_bound(Y+1,Y+n+1,b)-Y;
        if((Y[l]^a)&amp;&amp;(Y[r]^b))puts(&quot;maybe&quot;);
        else if(Y[l]==a&amp;&amp;Y[r]==b){
            if(R[l]&lt;R[r]) puts(&quot;false&quot;);
            else{
                if(rmq(l+1,r-1)&lt;R[r])(r-l==b-a)?puts(&quot;true&quot;):puts(&quot;maybe&quot;);
                else puts(&quot;false&quot;);
            }
        }else if(Y[l]^a)(rmq(l,r-1)&gt;=R[r])?puts(&quot;false&quot;):puts(&quot;maybe&quot;);
        else(rmq(l+1,r-1)&gt;=R[l])?puts(&quot;false&quot;):puts(&quot;maybe&quot;);
    }
    return 0;
}
<pre><h2>Problem1068</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char s[52];
int f[2][52][52];
inline void cmin(int&amp;a,int b){if(b&lt;a)a=b;}
inline int min(const int&amp;a,const int&amp;b){return a&lt;b?a:b;}
inline bool IsSame(const int&amp;l,const int&amp;r) {
	if((l&amp;1)^(r&amp;1)) {
		for(int i=l,j=(l+r&gt;&gt;1)+1;j&lt;=r;++i,++j)
			if(s[i]^s[j]) return false;
		return true;
	}else return false;
}
int dp(const bool&amp;k,const int&amp;l,const int&amp;r) {
	if(f[k][l][r]) return f[k][l][r];
	int&amp;t=f[k][l][r];
	if(l&gt;=r) return k?t=100:1;
	t=100;
	if(k) for(int i=l;i&lt;r;++i) {
			cmin(t,dp(0,l,i)+dp(0,i+1,r)+1);
			cmin(t,dp(0,l,i)+dp(1,i+1,r)+1);
			cmin(t,dp(1,l,i)+dp(0,i+1,r)+1);
			cmin(t,dp(1,l,i)+dp(1,i+1,r)+1);
		}
	if(IsSame(l,r)) cmin(t,dp(0,l,(l+r)&gt;&gt;1)+1);
	for(int i=l;i&lt;r;++i) cmin(t,dp(0,l,i)+r-i);
	return t;
}
int main() {
	scanf(&quot;%s&quot;,s);
	int l=strlen(s)-1;
	printf(&quot;%d\n&quot;,min(dp(0,0,l),dp(1,0,l)));
	return 0;
}<pre><h2>Problem1069</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int N = 50013;
const double eps = 1e-9;
struct point {
	double x, y;
	void input() {
		scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y);
	}
	point() {}
	point(double _x, double _y) : x(_x), y(_y) {}
	point operator + (const point &amp;a) const {
		return point(x + a.x, y + a.y);
	}
	point operator - (const point &amp;a) const {
		return point(x - a.x, y - a.y);
	}
	point operator * (const double &amp;a) const {
		return point(a * x, a * y);
	}
	double operator * (const point &amp;a) const {
		return x * a.y - y * a.x;
	}
	bool operator &lt; (const point &amp;a) const {
		return (x != a.x) ? x &lt; a.x : y &gt; a.y;
	}
}pt[N];
int stk1[N], stk2[N], tp1, tp2, n;
void cmax(double &amp;a, double b) {
	if (a &lt; b) a = b;
}
double rotating() {
	double ret = 0;
	for (int i = 0; i &lt; tp2; ++i) {
		int p = 1, q = 1;
		for (int j = i + 2; j &lt; tp2; ++j) {
			while (((pt[stk2[p + 1]] - pt[stk2[i]]) * (pt[stk2[j]] - pt[stk2[i]])) &gt; ((pt[stk2[p]] - pt[stk2[i]]) * (pt[stk2[j]] - pt[stk2[i]])))
				if (++p &gt;= tp2) p = 0;
			while (((pt[stk2[j]] - pt[stk2[i]]) * (pt[stk2[q + 1]] - pt[stk2[i]])) &gt; ((pt[stk2[j]] - pt[stk2[i]]) * (pt[stk2[q]] - pt[stk2[i]])))
				if (++q &gt;= tp2) q = 0;
			cmax(ret,
				 ((pt[stk2[p]] - pt[stk2[i]]) * (pt[stk2[j]] - pt[stk2[i]])) + ((pt[stk2[j]] - pt[stk2[i]]) * (pt[stk2[q]] - pt[stk2[i]]))
				);
		}
	}
	return ret;
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; ++i) pt[i].input();
	std::sort(pt + 1, pt + n +1);
	tp1 = 0;
	tp2 = -1;
	for (int i = 1; i &lt;= n; ++i) {
		while (tp1 &gt; 1&amp;&amp; ((pt[i] - pt[stk1[tp1]]) * (pt[stk1[tp1]] - pt[stk1[tp1 - 1]])) &gt;= 0) --tp1;
		stk1[++tp1] = i;
	}
	for (int i = 1; i &lt; tp1; ++i)
		stk2[++tp2] = stk1[i];
	tp1 = 0;
	for (int i = 1; i &lt;= n; ++i) {
		while (tp1 &gt; 1&amp;&amp; ((pt[i] - pt[stk1[tp1]]) * (pt[stk1[tp1]] - pt[stk1[tp1 - 1]])) &lt;= 0) --tp1;
		stk1[++tp1] = i;
	}
	for (int i = tp1; i; --i)
		stk2[++tp2] = stk1[i];
	printf(&quot;%.3lf\n&quot;, rotating() / 2.0);
	return 0;
}
<pre><h2>Problem1070</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define T 601
typedef int edge[100003];
const int inf = 0x3f3f3f3f, N = 605;
int n, m, take[61][10], ans;
int d[N], q[N], g[N], vis[N], _vis, ce;
edge to, nt, w, c;
inline void adde(int x, int y, int z, int v) {
	to[ce] = y, nt[ce] = g[x];
	c[ce] = z, w[ce] = v;
	g[x] = ce++;
}
inline void ins(int x, int y, int z, int v) {
	adde(x, y, z, v); adde(y, x, 0, -v);
}
inline bool SPFA() {
	for (int i = 0; i &lt; T; ++i) d[i] = inf;
	int l = 0, r = 1;
	d[T] = 0, vis[T] = ++_vis, q[0] = T;
	while (l ^ r) {
		int u = q[l++], v; if (l &gt;= T) l = 0;
		for (int i = g[u]; ~i; i = nt[i])
			if (c[i ^ 1] &amp;&amp; d[v = to[i]] &gt; d[u] + w[i ^ 1]) {
				d[v] = d[u] + w[i ^ 1];
				if (vis[v] ^ _vis) {
					vis[q[r++] = v] = _vis;
					if (r &gt;= T) r = 0;
				}
			}
		vis[u] = 0;
	}
	return d[0] ^ inf;
}
int dfs(int u, int flow) {
	if (u == T) return (vis[u] = _vis), flow;
	int ret = 0, t, v;
	vis[u] = _vis;
	if (!flow) return 0;
	for (int i = g[u]; ~i; i = nt[i])
		if ((vis[v = to[i]] ^ _vis) &amp;&amp; c[i] &amp;&amp; d[u] + w[i ^ 1] == d[v]) {
			t = dfs(v, std::min(flow, c[i]));
			ans += t * w[i];
			flow -= t, ret += t;
			c[i] -= t, c[i^1] += t;
			if (!flow) return ret;
		}
	return ret;
}
inline void zkw() {
	while (SPFA()) {
		vis[T] = ++_vis;
		while (!(vis[T] ^ _vis)) {
			++_vis;
			dfs(0, inf);
		}
	}
}
int main() {
	int i, j, k;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	memset(g, -1, sizeof g);
	for (i = 1; i &lt;= m; ++i)
		for (j = 1; j &lt;= n; ++j)
			scanf(&quot;%d&quot;, take[i] + j);
	for (i = 1; i &lt;= n * m; ++i)
		ins(0, i, 1, 0);
	for (i = n * m + 1; i &lt;= n * m + m; ++i)
		ins(i, T, 1, 0);
	for (i = 1; i &lt;= n; ++i)
		for (j = 1; j &lt;= m; ++j)
			for (k = 1; k &lt;= m; ++k)
				ins((i - 1) * m + j, n * m + k, 1, take[k][i] * j);
	zkw();
	printf(&quot;%.2lf&quot;, (double)ans / m);
	return 0;
}
<pre><h2>Problem1071</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
inline int gi() {
	static int a; static char c, f;
	for (f = 0; (c = getchar()) &lt; '0';) f|= c == '-';
	for (a = c - '0'; '-' &lt; (c = getchar());) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return f ? -a : a;
}
int n, Max, Min;
long long a, b, c;
struct D {
	int s, h; long long sum;
	inline D input() {
		h = gi(), s = gi();
		sum = a * h + b * s;
		return *this;
	}
}dh[5003], dsum[5003];
bool ch(const D &amp;a, const D &amp;b) {
	return a.h &lt; b.h;
}
bool csum(const D &amp;a, const D &amp;b) {
	return a.sum &lt; b.sum;
}
bool g(const D &amp;a) {
	return a.s &lt;= Max &amp;&amp; a.s &gt;= Min;
}
int main() {
	int i, j, k, ans = 0, cnt = 0, l, r;
	long long t;
	n = gi();
	scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);
	for (i = 0; i &lt; n; ++i) dh[i] = dsum[i].input();
	std::sort(dh, dh + n, ch);
	std::sort(dsum, dsum + n, csum);
	for (i = 0; i &lt; n; ++i) {
		l = r = -1; cnt = 0;
		Min = dh[i].s, Max = Min + c / b;
		for (j = 0; j &lt; n; ++j) {
			t = a * dh[j].h + b * dh[i].s + c;
			while (r + 1 &lt; n &amp;&amp; dsum[r + 1].sum &lt;= t)
				cnt += g(dsum[++r]);
			while (l + 1 &lt; n &amp;&amp; dh[l+1].h &lt; dh[j].h)
				cnt -= g(dh[++l]);
			if (ans &lt; cnt) ans = cnt;
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem1072</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int dp[1003][1029], cnt[12];
int main() {
	int __, i, j, k, end, t, mo, n;
	char str[12], ch;
	scanf(&quot;%d&quot;, &amp;__);
	while (__--) {
		for (n = 0; (ch = getchar()) &lt; '0';);
		for (str[n++] = ch; '-' &lt; (ch = getchar());)
			str[n++] = ch;
		scanf(&quot;%d&quot;, &amp;mo);
		str[n] = 0;
		memset(dp, 0, sizeof dp);
		memset(cnt, 0, sizeof cnt);
		dp[0][0] = 1, end = 1 &lt;&lt; n;
		for (j = 1; j &lt; end; ++j)
			for (i = 0; i &lt; mo; ++i)
				for (k = 0; k &lt; n; ++k)
					if (j &gt;&gt; k &amp; 1)
						dp[i][j] += dp[(i * 10 + str[k] - '0') % mo][j ^ (1 &lt;&lt; k)];
		t = dp[0][end - 1];
		for (i = 0; i &lt; n; ++i)
			t /= ++cnt[str[i] - '0'];
		printf(&quot;%d\n&quot;, t);
	}
	return 0;
}
<pre><h2>Problem1076</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
inline double max(double a,double b){return a&lt;b?b:a;}
int s[15],w[15];
double dp[2][1&lt;&lt;15];
int main() {
	register int k=geti(),n=geti(),i,j,en=1&lt;&lt;n,d=0;
	for(i=0;i^n;++i) {
		w[i]=geti();
		while(j=geti())s[i]|=1&lt;&lt;j-1;
	}
	while(k--)
		for(d^=1,memset(dp[d],0,sizeof dp[d]),j=0;j^en;++j) {
			for(i=0;i^n;++i)
				if((j&amp;s[i])^s[i]) dp[d][j]+=dp[d^1][j];
				else dp[d][j]+=max(dp[d^1][j],dp[d^1][j|(1&lt;&lt;i)]+w[i]);
			dp[d][j]/=n;
		}
	printf(&quot;%.6lf\n&quot;,*dp[d]);
	return 0;
}
<pre><h2>Problem1078</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

typedef int arr[105];
arr ls, rs, fa, ans;
inline void solve() {
	static int root = 0, x, t, *top = ans;
	for (x = root; ~rs[x]; x = ls[x]);
	t = ls[x];
	if ((~t) &amp;&amp; ls[t] &lt; 0 &amp;&amp; rs[t] &lt; 0)
		x = t;
	*top++ = x;
	if (x == root) root = ls[root];
	t = fa[x];
	if (~t) fa[ls[t] = ls[x]] = t;
	for (; ~t; t = fa[t])
		std::swap(ls[t], rs[t]);
}

int main() {
	int n, x;
	register int i;
	fa[0] = -1;
	memset(ls, -1, sizeof ls);
	memset(rs, -1, sizeof rs);
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		if (x &lt; 100)
			fa[ls[x] = i] = x;
		else
			fa[rs[x - 100] = i] = x - 100;
	}
	for (i = 0; i &lt;= n; ++i)
		solve();
	for (i = n; ~i; --i)
		printf(&quot;%d &quot;, ans[i]);
	return 0;
}
<pre><h2>Problem1080</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
struct D {
	int a,i,j,t;
	D() {}
	D(int _a,int _i,int _j,int _t):a(_a),i(_i),j(_j),t(_t){}
};
//Input
int ina; char inc,inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	while((inc=getc())&lt;'0'||inc&gt;'9'); ina=inc-'0';
	while((inc=getc())&gt;='0'&amp;&amp;inc&lt;='9') ina=(ina&lt;&lt;3)+(ina&lt;&lt;1)+inc-'0';
	return ina;
}
inline int getis(char s[]) {
	for(ina=1,inc=getc();inc!='\n'&amp;&amp;inc!='\r';++ina,inc=getc()) s[ina]=inc;
	s[ina]=0; return ina-1;
}
#define N 63
#define min(a,b) ((a)&lt;(b)?(a):(b))
int n,m,len[N],ans,dp[N][N][N][3];
char str[N][N]; bool cmp[N][N][N];
queue&lt;D&gt;q;

int main() {
	int i,j,k,t,o;
	for(n=geti(),i=1;i&lt;=n;++i) {
		len[i]=getis(str[i]);
		while(str[i][len[i]]==' ') str[i][len[i]--]=0;
		if(len[i]==0) return puts(&quot;0&quot;),0;
	}
	for(i=1;i&lt;=n;++i)
	  for(j=1;j&lt;=n;++j)
		for(cmp[i][j][len[i]]=true,k=0;k&lt;len[i];++k){
			t=min(len[i]-k,len[j]);
			for(o=1;o&lt;=t;++o)
			  if(str[i][o+k]^str[j][o]) break;
			cmp[i][j][k]=o&gt;t;
		}
	ans=0x3f3f3f3f;
	memset(dp,63,sizeof dp);
	for(i=1;i&lt;=n;++i) {
		dp[i][0][0][2]=len[i];
		q.push(D(i,0,0,2));
	}
	while(!q.empty()) {
		D p=q.front(); q.pop();
		int _a,_i,_j,_t,res=dp[p.a][p.i][p.j][p.t];
		if(p.t==0) {
			if(p.i==p.j&amp;&amp;p.i==len[p.a]) {
				(res&lt;ans)?ans=res:1;
				continue;
			}
			for(i=1;i&lt;=n;++i)
			  if(_t=0,cmp[p.a][i][p.j]) {
				  if(len[i]+p.j&gt;len[p.a]) {
					  _a=i,_i=len[p.a]-p.j,_j=p.i-p.j;
					  o=res+len[i]-(len[p.a]-p.j);
				  }else {
					  _a=p.a,_i=p.j+len[i],_j=p.i;
					  (_i&lt;_j)?_i^=_j^=_i^=_j:1;
					  o=res;
				  }
				  (o&lt;dp[_a][_i][_j][_t])?q.push(D(_a,_i,_j,_t)),dp[_a][_i][_j][_t]=o:1;
			  }
		} else if(p.t==1) {
			if(p.i==p.j&amp;&amp;p.i==len[p.a]) continue;
			for(i=1;i&lt;=n;++i)
			  if(cmp[p.a][i][p.j]) {
				  if(p.j+len[i]&gt;=len[p.a]) {
					  _a=i,_i=_j=len[p.a]-p.j,_t=2;
					  o=res+len[i]-_i;
				  }else {
					  _a=p.a,_i=p.i,_j=p.j+len[i],_t=1;
					  o=res;
				  }
				  (o&lt;dp[_a][_i][_j][_t])?q.push(D(_a,_i,_j,_t)),dp[_a][_i][_j][_t]=o:1;
			  }
		} else if(p.t==2) {
			for(i=1;i&lt;=n;++i) {
				if(!cmp[p.a][i][p.j]||(p.i==0&amp;&amp;i==p.a)) continue;
				if(p.j+len[i]&gt;len[p.a]) {
					_a=i,_i=len[i],_j=len[p.a]-p.j,_t=1;
					o=res+len[i]-_j;
				}else {
					_a=p.a,_i=_j=p.i+len[i],_t=2;
					o=res;
				}
				(o&lt;dp[_a][_i][_j][_t])?q.push(D(_a,_i,_j,_t)),dp[_a][_i][_j][_t]=o:1;

				for(j=1;j&lt;=n;++j) {
					if(!cmp[p.a][j][p.j]||i==j||!cmp[i][j][0]) continue;
					int si=i,sj=j;
					if(len[si]&lt;len[sj]||(len[si]==len[sj]&amp;&amp;sj==p.a)) si^=sj^=si^=sj;
					if(p.i+len[si]&gt;len[p.a]) {
						if(p.j+len[sj]&gt;len[p.a]) {
							_a=si,_i=len[sj],_j=len[p.a]-p.i;
							o=res+len[si]-_j,_t=0;
						}else {
							_a=si,_i=len[p.a]-p.i,_j=len[sj];
							o=res+len[si]-_i; (p.a==sj&amp;&amp;p.i==0)?_t=2:_t=0;
						}
					}else {
						_a=p.a,_i=p.i+len[si],_j=p.i+len[sj],_t=0;
						o=res; if(p.i==0&amp;&amp;si==p.a) (_j&lt;len[p.a])?_t=1:_a=sj,_t=2,_i=_j=len[sj];
					}
					(o&lt;dp[_a][_i][_j][_t])?q.push(D(_a,_i,_j,_t)),dp[_a][_i][_j][_t]=o:1;
				}

			}
		}
	}
	return printf(&quot;%d\n&quot;,(ans^0x3f3f3f3f)?ans:-1),0;
}
<pre><h2>Problem1084</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int dp[102][102][12],s[102][3];
#define ni(a) (a&lt;'0'||'9'&lt;a)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),ni(c))f|=c=='-';a=c-'0';
	while(c=getchar(),!ni(c))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
inline void cmax(int &amp;a,int b){a&lt;b?a=b:1;}
inline int max(int a,int b){return a&lt;b?b:a;}
int main() {
	int n=geti(),m=geti(),k=geti(),i,j,o,h;
	for(i=1;i&lt;=n;++i)
		for(j=1;j&lt;=m;++j)
			s[i][j]=s[i-1][j]+geti();
	if(m&lt;2) {
		int (*f)[12]=dp[0];
		for(i=1;i&lt;=n;++i)
			for(j=1;j&lt;=k;++j) {
				f[i][j]=f[i-1][j];
				for(o=0;o&lt;i;++o)
					cmax(f[i][j],f[o][j-1]+s[i][1]-s[o][1]);
			}
		printf(&quot;%d\n&quot;,f[n][k]);
	}else{
		for(i=1;i&lt;=n;++i)
			for(j=1;j&lt;=n;++j)
				for(o=1;o&lt;=k;++o) {
					dp[i][j][o]=max(dp[i][j-1][o],dp[i-1][j][o]);
					for(h=0;h&lt;i;++h)
						cmax(dp[i][j][o],dp[h][j][o-1]+s[i][1]-s[h][1]);
					for(h=0;h&lt;j;++h)
						cmax(dp[i][j][o],dp[i][h][o-1]+s[j][2]-s[h][2]);
					if(i==j)
						for(h=0;h&lt;i;++h)
							cmax(dp[i][j][o],dp[h][h][o-1]+s[i][1]-s[h][1]+s[i][2]-s[h][2]);		 
				}
		printf(&quot;%d\n&quot;,dp[n][n][k]);
	}
	return 0;
}
<pre><h2>Problem1087</h2><pre>#include &lt;cstdio&gt;
long long dp[10][150][85];
int c[200],ct[200];
inline int CT(int i) {
	int r=0;
	for(;i;i=i&amp;(i-1))++r;
	return r;
}
int main() {
	int n,K;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);
	register int i,j,k,ck,en=1&lt;&lt;n,cs=0;
	for(i=0;i&lt;en;++i)((i&lt;&lt;1)&amp;i)?1:(c[cs]=i,ct[cs]=CT(i),++cs);
	dp[0][0][0]=1;
	for(k=1;k&lt;=n;++k)
		for(i=0;i&lt;cs;++i)
			for(ck=0;ck&lt;=K;++ck)
				if(dp[k-1][i][ck])for(j=0;j&lt;cs;++j)
									  if(ck+ct[j]&lt;=K&amp;&amp;!((c[i]&amp;c[j])|(c[i]&lt;&lt;1&amp;c[j])|(c[i]&gt;&gt;1&amp;c[j])))
										  dp[k][j][ck+ct[j]]+=dp[k-1][i][ck];
	long long ans=0;
	for(i=0;i&lt;cs;++i)ans+=dp[n][i][K];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1088</h2><pre>#include &lt;cstdio&gt;
int a[10005], b[10005], n;
#define rit register int
inline int g(int x, int y) {
	b[1] = x, b[2] = y;
	for (rit i = 2; i &lt; n; ++i) {
		b[i + 1] = a[i] - b[i] - b[i - 1];
		if (b[i + 1] &gt;&gt; 1) return 0;
	}
	return b[n] + b[n - 1] == a[n];
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (rit i = 1; i &lt;= n; ++i)
	  scanf(&quot;%d&quot;, a + i);
	if (!a[1]) printf(&quot;%d\n&quot;, g(0, 0));
	else if (a[1] &lt; 2) printf(&quot;%d\n&quot;, g(1, 0) + g(0, 1));
	else printf(&quot;%d\n&quot;, g(1, 1));
	return 0;
}<pre><h2>Problem1089</h2><pre>n,d=map(int,raw_input().split())
if d==0:
    print 1
else:
    f=[1]
    for i in range(0,d+1):
        f.append(f[i]**n+1)
    print f[d]-f[d-1]
<pre><h2>Problem1090</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char s[101]; int dp[101][101];
inline int len(const int&amp;v) {if(v&lt;10)return 1;return v&lt;100?2:3;}
inline bool same(const int&amp;l,const int&amp;r,const int&amp;x,const int&amp;y) {
	//make [x..y] by [l..r]
	int l1=r-l+1,l2=y-x+1;
	if(l2&lt;l1||l2%l1)return false;
	for(int i=x,j=l;i&lt;=y;++i) {
		if(s[i]^s[j])return false;
		if(++j&gt;r)j=l;
	}return true;
}
inline void cmin(int&amp;a,const int&amp;b){if(b&lt;a)a=b;}
int cal(const int&amp;l,const int&amp;r) {
	if(dp[l][r])return dp[l][r];
	int &amp;rt=dp[l][r]=r-l+1;
	for(int i=l;i&lt;r;++i) {
		cmin(rt,cal(l,i)+cal(i+1,r));
		if(same(l,i,i+1,r)) cmin(rt,cal(l,i)+2+len((r-i)/(i-l+1)+1));
	}return rt;
}
int main() {
	gets(s);
	printf(&quot;%d\n&quot;,cal(0,strlen(s)-1));
	return 0;
}<pre><h2>Problem1095</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int N = 100013;

class heap {
protected:
	priority_queue &lt; int &gt; A, B;
public:
	void push(const int &amp;x) {
		A.push(x);
	}
	void erase(const int &amp;x) {
		B.push(x);
	}
	void pop() {
		while (!B.empty() &amp;&amp; !(A.top() ^ B.top()))
			A.pop(), B.pop();
		A.pop();
	}
	int top() {
		while (!B.empty() &amp;&amp; !(A.top() ^ B.top()))
			A.pop(), B.pop();
		return A.empty() ? -0x3f3f3f3f : A.top();
	}
	int size() const {
		return A.size() - B.size();
	}
	bool empty() const {
		return !(A.size() ^ B.size());
	}
	int tps() {
		if (size() &lt; 2) return -0x3f3f3f3f;
		int t1, t2;
		while (!B.empty() &amp;&amp; !(A.top() ^ B.top()))
			A.pop(), B.pop();
		t1 = A.top(); A.pop();
		while (!B.empty() &amp;&amp; !(A.top() ^ B.top()))
			A.pop(), B.pop();
		t2 = A.top(); A.push(t1);
		return t1 + t2;
	}
}GlobleHeap, FirstHeap[N], SecondHeap[N];

struct edge {
	int t;
	edge *n;
} me[N &lt;&lt; 1 | 1], *ce = me, *g[N];

inline void adde(const int &amp;a, const int &amp;b) {
	ce-&gt;t = b, ce-&gt;n = g[a], g[a] = ce++;
}

int deep[N], fa[20][N], dis[20][N], size[N], f[N], totsize, rt, tot_off;
bool vis[N], on[N];

inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

void grt(int u, int father) {
	int v;
	size[u] = 1, f[u] = 0;
	for (edge *it = g[u]; it; it = it-&gt;n) {
		v = it-&gt;t;
		if (vis[v] || (v == father)) continue;
		grt(v, u);
		size[u] += size[v];
		cmax(f[u], size[v]);
	}
	cmax(f[u], totsize - size[u]);
	if (f[u] &lt; f[rt]) rt = u;
}

void dfs(int u, const int &amp;anc, int father, int dep) {
	int v;
	for (edge *it = g[u]; it; it = it-&gt;n) {
		v = it-&gt;t;
		if (vis[v] || (v == father)) continue;
		fa[++deep[v]][v] = anc;
		dis[deep[v]][v] = dep;
		dfs(v, anc, u, dep + 1);
	}
}

void build(int u) {
	int v, all = totsize;
	vis[u] = true;
	dfs(u, u, 0, 1);
	for (edge *it = g[u]; it; it = it-&gt;n) {
		if (vis[v = it-&gt;t]) continue;
		if (size[u] &lt; size[v])
			size[v] = all - size[u];
		totsize = size[v];
		rt = 0;
		grt(v, u);
		build(rt);
	}
}

inline void turn_off(const int &amp;u) {
	static int t, i, pre;
	SecondHeap[u].push(0);
	if (SecondHeap[u].size() == 2)
		GlobleHeap.push(SecondHeap[u].top());
	for (i = deep[u]; i &gt; 1; --i)
		if (FirstHeap[fa[i][u]].empty()) {
			FirstHeap[fa[i][u]].push(dis[i - 1][u]);
			pre = SecondHeap[fa[i - 1][u]].tps();
			SecondHeap[fa[i - 1][u]].push(dis[i - 1][u]);
			if (pre &gt; 0) {
				if (pre ^ (t = SecondHeap[fa[i - 1][u]].tps())) {
					GlobleHeap.erase(pre);
					GlobleHeap.push(t);
				}
			} else if ((t = SecondHeap[fa[i - 1][u]].tps()) &gt; 0)
					   GlobleHeap.push(t);
		} else {
			t = FirstHeap[fa[i][u]].top();
			FirstHeap[fa[i][u]].push(dis[i - 1][u]);
			if (t &lt; dis[i - 1][u]) {
				pre = SecondHeap[fa[i - 1][u]].tps();
				SecondHeap[fa[i - 1][u]].erase(t);
				SecondHeap[fa[i - 1][u]].push(dis[i - 1][u]);
				if (pre &gt; 0 &amp;&amp; (pre ^ (t = SecondHeap[fa[i - 1][u]].tps()))) {
					GlobleHeap.erase(pre);
					GlobleHeap.push(t);
				}
			}
		}
}

inline void turn_on(const int &amp;u) {
	SecondHeap[u].erase(0);
	if (SecondHeap[u].size() == 1)
		GlobleHeap.erase(SecondHeap[u].top());
	for (int t, pre, i = deep[u]; i &gt; 1; --i) {
		FirstHeap[fa[i][u]].erase(dis[i - 1][u]);
		if (FirstHeap[fa[i][u]].top() &lt; dis[i - 1][u]) {
			pre = SecondHeap[fa[i - 1][u]].tps();
			SecondHeap[fa[i - 1][u]].erase(dis[i - 1][u]);
			if (!FirstHeap[fa[i][u]].empty())
				SecondHeap[fa[i - 1][u]].push(FirstHeap[fa[i][u]].top());
			if (pre &gt; 0 &amp;&amp; (pre ^ (t = SecondHeap[fa[i - 1][u]].tps()))) {
				GlobleHeap.erase(pre);
				if (SecondHeap[fa[i - 1][u]].size() &gt; 1)
					GlobleHeap.push(t);
			}
		}
	}
}

inline void Switch(const int &amp;u) {
	if (on[u]) turn_off(u);
	else turn_on(u);
	on[u] ^= 1;
	if (on[u]) --tot_off;
	else ++tot_off;
}

int main() {
	//freopen(&quot;1095.in&quot;, &quot;r&quot;, stdin);
	int n, m, u, v;
	char ops[4];
	scanf(&quot;%d&quot;, &amp;n);
	for (m = 1; m &lt; n; ++m) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		adde(u, v), adde(v, u);
	}
	f[0] = 0x3f3f3f3f;
	totsize = tot_off = n;
	grt(1, 0);
	build(rt);
	for (m = 1; m &lt;= n; ++m)
		fa[++deep[m]][m] = m, turn_off(m);
	scanf(&quot;%d&quot;, &amp;m);
	while (m--) {
		scanf(&quot;%s&quot;, ops);
		if (*ops == 'G') {
			if (!tot_off)puts(&quot;-1&quot;);
			else printf(&quot;%d\n&quot;, max(GlobleHeap.top(), 0));
		} else {
			scanf(&quot;%d&quot;, &amp;u);
			Switch(u);
		}
	}
	return 0;
}
<pre><h2>Problem1102</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;

const int MAXN = 1000 + 3;
typedef pair&lt;int, int&gt; pii;

int w[MAXN][MAXN], n;
bool mark[MAXN][MAXN];
queue&lt;pii&gt; que;

const int dx[] = {-1, 0, 1, -1, 1, -1, 0, 1};
const int dy[] = {-1, -1, -1, 0, 0, 1, 1, 1};

int main() {

  // freopen(&quot;D.in&quot;, &quot;r&quot;, stdin);

  scanf(&quot;%d&quot;, &amp;n);
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      scanf(&quot;%d&quot;, w[i] + j);
    }
  }
  int cnt1 = 0;
  int cnt2 = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (mark[i][j])
        continue;
      int cnt = 0;
      int lower = 0;
      int upper = 0;
      que.push(pii(i, j));
      mark[i][j] = true;
      while (!que.empty()) {
        int x = que.front().first;
        int y = que.front().second;
        que.pop();

        bool is_lower = true;
        bool is_upper = true;
        for (int i = 0; i &lt; 8; i++) {
          int _x = x + dx[i];
          int _y = y + dy[i];
          if (_x &lt; 0 || _x &gt;= n || _y &lt; 0 || _y &gt;= n)
            continue;
          if (w[_x][_y] == w[x][y]) {
            if (!mark[_x][_y]) {
              mark[_x][_y] = true;
              que.push(pii(_x, _y));
            }
          } else {
            is_lower &amp;= w[x][y] &lt; w[_x][_y];
            is_upper &amp;= w[x][y] &gt; w[_x][_y];
          }
        }
        lower += is_lower;
        upper += is_upper;
        cnt++;
      }
      cnt1 += upper == cnt;
      cnt2 += lower == cnt;
      // printf(&quot;%d %d %d %d\n&quot;, i, j, cnt1, cnt2);
    }
  }
  printf(&quot;%d %d\n&quot;, cnt1, cnt2);
  return 0;
}<pre><h2>Problem1150</h2><pre>#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 200000;
typedef pair &lt; int, int&gt; pr;
int pre[N], nxt[N], totnode, n, k, weight[N];
bool mark[N];
priority_queue&lt;pr&gt;heap;
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	int last, cur;
	scanf(&quot;%d&quot;, &amp;last);
	for (int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d&quot;, &amp;cur);
		weight[++totnode] = last - cur;
		heap.push(make_pair(last - cur, totnode));
		last = cur;
	}
	for (int i = 1; i &lt;= totnode; ++i)
		pre[i] = i - 1, nxt[i] = i + 1;
	nxt[totnode] = 0;
	int idx;
	long long ans = 0;
	while (k) {
		pr p = heap.top(); 
		heap.pop();
		if (mark[p.second]) continue;
		--k;
		ans += -p.first;
		idx = p.second;
		mark[idx] = true;
		if (!pre[idx]) {
			mark[nxt[idx]] = true;
			pre[nxt[nxt[idx]]] = 0;
		} else if (!nxt[idx]) {
			mark[pre[idx]] = true;
			nxt[pre[pre[idx]]] = 0;
		} else {
			mark[pre[idx]] = mark[nxt[idx]] = true;
			++totnode;
			if (pre[pre[idx]]) nxt[pre[pre[idx]]] = totnode;
			if (nxt[nxt[idx]]) pre[nxt[nxt[idx]]] = totnode;
			nxt[totnode] = nxt[nxt[idx]];
			pre[totnode] = pre[pre[idx]];
			weight[totnode] = weight[pre[idx]] + weight[nxt[idx]] - weight[idx];
			heap.push(make_pair(weight[totnode], totnode));
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}
<pre><h2>Problem1177</h2><pre>#include &lt;cstdio&gt;

inline int max(const int &amp;a, const int &amp;b, const int &amp;c) {
	static int t;
	t = (a &lt; b) ? b : a;
	return t &lt; c ? c : t;
}

inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

typedef int mat[1505][1505];

mat a, b, c, d, s;

#define R(i, l, r) for (register int i = l, i##end = r; i &lt;= i##end; ++i)
#define F(i, l, r) for (register int i = r, i##end = l; i &gt;= i##end; --i)
int main() {
	int n, m, k, x, ans = 0;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	R(i, 1, n) R(j, 1, m) {
		scanf(&quot;%d&quot;, &amp;x);
		s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + x;
	}

	F(i, k, n) F(j, k, m) s[i][j] -= s[i - k][j] + s[i][j - k] - s[i - k][j - k];
	
	R(i, k, n) R(j, k, m) a[i][j] = max(s[i][j], a[i - 1][j], a[i][j - 1]);
	R(i, k, n) F(j, k, m) b[i][j] = max(s[i][j], b[i - 1][j], b[i][j + 1]);
	F(i, k, n) R(j, k, m) c[i][j] = max(s[i][j], c[i + 1][j], c[i][j - 1]);
	F(i, k, n) F(j, k, m) d[i][j] = max(s[i][j], d[i + 1][j], d[i][j + 1]);

	R(i, k, n - k) R(j, k, m - k) cmax(ans, a[i][j] + b[i][j + k] + c[i + k][m]);
	R(i, k, n - k) R(j, k + k, m) cmax(ans, b[i][j] + d[i + k][j] + a[n][j - k]);
	R(i, k + k, n) R(j, k, m - k) cmax(ans, c[i][j] + d[i][j + k] + a[i - k][m]);
	R(i, k + k, n) R(j, k + k, m) cmax(ans, a[i][j] + c[i + k][j] + d[k][j + k]);

	R(i, k, n) R(j, k + k, m - k) cmax(ans, s[i][j] + a[n][j - k] + b[n][j + k]);
	R(i, k + k, n - k) R(j, k, m) cmax(ans, s[i][j] + a[i - k][m] + c[i + k][m]);

	printf(&quot;%d\n&quot;, ans);
	
	return 0;
}<pre><h2>Problem1185</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define N 50010
using namespace std;
typedef double D;
struct P{D x,y;P(){}P(D _x,D _y){x=_x,y=_y;}}p[N],pp[N],hull[N],pivot,A,B,C,rect[8];
int n,i,j,l,r,k;
D w,h,ans=1e20,tmp,len;
bool del[N];
inline int zero(D x){return fabs(x)&lt;1e-4;}
inline int sig(D x){if(fabs(x)&lt;1e-8)return 0;return x&gt;0?1:-1;}
inline D cross(P A,P B,P C){return(B.x-A.x)*(C.y-A.y)-(B.y-A.y)*(C.x-A.x);}
inline D distsqr(P A,P B){return(A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y);}
inline bool cmp(P a,P b){
  D t=cross(pivot,a,b);
  return sig(t)==1||sig(t)==0&amp;&amp;sig(distsqr(pivot,a)-distsqr(pivot,b))==-1;
}
inline void convexhull(int n,P stck[],int&amp;m){
  int i,k,top;
  for(i=0;i&lt;n;i++)pp[i]=p[i];
  for(k=0,i=1;i&lt;n;i++)if(pp[i].y&lt;pp[k].y||(pp[i].y==pp[k].y&amp;&amp;pp[i].x&lt;pp[k].x))k=i;
  pivot=pp[k];pp[k]=pp[0];pp[0]=pivot;
  sort(pp+1,pp+n,cmp);
  stck[0]=pp[0];stck[1]=pp[1];
  for(top=1,i=2;i&lt;n;i++){
    while(top&amp;&amp;sig(cross(pp[i],stck[top],stck[top-1]))&gt;=0)--top;
    stck[++top]=pp[i];
  }
  m=top+1;
}
inline D area(P A,P B,P C){return fabs(cross(A,B,C));}
inline P vertical(P A,P B){return P(A.x-B.y+A.y,A.y+B.x-A.x);}
int main(){
  scanf(&quot;%d&quot;,&amp;n);
  for(i=0;i&lt;n;i++)scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
  convexhull(n,hull,n);
  for(i=1;i&lt;n;i++)if(zero(hull[i].x-hull[i-1].x)&amp;&amp;zero(hull[i].y-hull[i-1].y))del[i]=1;
  for(k=i=0;i&lt;n;i++)if(!del[i])hull[k++]=hull[i];
  for(hull[n=k]=hull[i=0];i&lt;n;i++){
    A=hull[i],B=hull[i+1],C=vertical(A,B);
    while(sig(area(A,B,hull[j])-area(A,B,hull[j+1]))&lt;1)j=(j+1)%n;
    while(sig(cross(A,C,hull[l])-cross(A,C,hull[l+1]))&lt;1)l=(l+1)%n;
    while(sig(cross(A,C,hull[r])-cross(A,C,hull[r+1]))&gt;-1)r=(r+1)%n;
    len=sqrt(distsqr(A,B));
    h=area(A,B,hull[j])/len;
    w=(cross(A,C,hull[l])-cross(A,C,hull[r]))/len;
    if(sig(h*w-ans)==-1){
      ans=h*w;
      tmp=area(A,B,hull[l])/len/len;
      rect[0]=P(hull[l].x+tmp*(A.x-C.x),hull[l].y+tmp*(A.y-C.y));
      tmp=h/len;
      rect[3]=P(rect[0].x+tmp*(C.x-A.x),rect[0].y+tmp*(C.y-A.y));
      tmp=w/len;
      rect[1]=P(rect[0].x+tmp*(B.x-A.x),rect[0].y+tmp*(B.y-A.y));
      rect[2]=P(rect[3].x+tmp*(B.x-A.x),rect[3].y+tmp*(B.y-A.y));
    }
  }
  for(i=0;i&lt;4;i++)rect[i+4]=rect[i];
  for(j=0,i=1;i&lt;4;i++)if(sig(rect[i].y-rect[j].y)==-1||sig(rect[i].y-rect[j].y)==0&amp;&amp;sig(rect[i].x-rect[j].x)==-1)j=i;
  printf(&quot;%.0f.00000\n&quot;,ans);
  for(i=0;i&lt;4;i++)printf(&quot;%.0f.00000 %.0f.00000\n&quot;,rect[j+i].x,rect[j+i].y);
  return 0;
}<pre><h2>Problem1185</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define N 50010
using namespace std;
typedef double D;
struct P{D x,y;P(){}P(D _x,D _y){x=_x,y=_y;}}p[N],pp[N],hull[N],pivot,A,B,C,rect[8];
int n,i,j,l,r,k;
D w,h,ans=1e20,tmp,len;
bool del[N];
/*inline int zero(D x){return fabs(x)&lt;1e-4;}
inline int sig(D x){if(fabs(x)&lt;1e-8)return 0;return x&gt;0?1:-1;}
inline D cross(P A,P B,P C){return(B.x-A.x)*(C.y-A.y)-(B.y-A.y)*(C.x-A.x);}
inline D distsqr(P A,P B){return(A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y);}
inline bool cmp(P a,P b){
	D t=cross(pivot,a,b);
	return sig(t)==1||sig(t)==0&amp;&amp;sig(distsqr(pivot,a)-distsqr(pivot,b))==-1;
	}*/


inline int zero(const double &amp;a) {
	return fabs(a) &lt; 1e-4;
}
inline int sig(const double &amp;a) {
	if (fabs(a) &lt; 1e-8)
		return 0;
	return a &lt; 0 ? -1 : 1;
}
inline double cross(const P &amp;A, const P &amp;B, const P &amp;C) {
	return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
}
inline double dis2(const P &amp;A, const P &amp;B) {
	return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
}
#define distsqr dis2
inline bool cmp(const P &amp;A, const P &amp;B) {
	double t = cross(pivot, A, B);
	return (sig(t) == 1) || (sig(t) == 0 &amp;&amp; sig(dis2(pivot, A) - dis2(pivot, B)) == -1);
}


inline void convexhull(int n,P stck[],int&amp;m){
	int i,k,top;
	for(i=0;i&lt;n;i++)pp[i]=p[i];
	for(k=0,i=1;i&lt;n;i++)if(pp[i].y&lt;pp[k].y||(pp[i].y==pp[k].y&amp;&amp;pp[i].x&lt;pp[k].x))k=i;
	pivot=pp[k];pp[k]=pp[0];pp[0]=pivot;
	sort(pp+1,pp+n,cmp);
	stck[0]=pp[0];stck[1]=pp[1];
	for(top=1,i=2;i&lt;n;i++){
		while(top&amp;&amp;sig(cross(pp[i],stck[top],stck[top-1]))&gt;=0)--top;
		stck[++top]=pp[i];
	}
	m=top+1;
}
inline D area(P A,P B,P C){return fabs(cross(A,B,C));}
inline P vertical(P A,P B){return P(A.x-B.y+A.y,A.y+B.x-A.x);}
int main(){
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d&quot;,&amp;n);
	for(i=0;i&lt;n;i++)scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
	convexhull(n,hull,n);
	for(i=1;i&lt;n;i++)if(zero(hull[i].x-hull[i-1].x)&amp;&amp;zero(hull[i].y-hull[i-1].y))del[i]=1;
	for(k=i=0;i&lt;n;i++)if(!del[i])hull[k++]=hull[i];
	for(hull[n=k]=hull[i=0];i&lt;n;i++){
		A=hull[i],B=hull[i+1],C=vertical(A,B);
		while(sig(area(A,B,hull[j])-area(A,B,hull[j+1]))&lt;1)j=(j+1)%n;
		while(sig(cross(A,C,hull[l])-cross(A,C,hull[l+1]))&lt;1)l=(l+1)%n;
		while(sig(cross(A,C,hull[r])-cross(A,C,hull[r+1]))&gt;-1)r=(r+1)%n;
		len=sqrt(distsqr(A,B));
		h=area(A,B,hull[j])/len;
		w=(cross(A,C,hull[l])-cross(A,C,hull[r]))/len;
		if(sig(h*w-ans)==-1){
			ans=h*w;
			tmp=area(A,B,hull[l])/len/len;
			rect[0]=P(hull[l].x+tmp*(A.x-C.x),hull[l].y+tmp*(A.y-C.y));
			tmp=h/len;
			rect[3]=P(rect[0].x+tmp*(C.x-A.x),rect[0].y+tmp*(C.y-A.y));
			tmp=w/len;
			rect[1]=P(rect[0].x+tmp*(B.x-A.x),rect[0].y+tmp*(B.y-A.y));
			rect[2]=P(rect[3].x+tmp*(B.x-A.x),rect[3].y+tmp*(B.y-A.y));
		}
	}
	for(i=0;i&lt;4;i++)rect[i+4]=rect[i];
	for(j=0,i=1;i&lt;4;i++)if(sig(rect[i].y-rect[j].y)==-1||sig(rect[i].y-rect[j].y)==0&amp;&amp;sig(rect[i].x-rect[j].x)==-1)j=i;
	printf(&quot;%.0f.00000\n&quot;,ans);
	for(i=0;i&lt;4;i++)printf(&quot;%.0lf.00000 %.0lf.00000\n&quot;,rect[j+i].x,rect[j+i].y);
	return 0;
}
<pre><h2>Problem1185</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define N 50005

struct P {
	double x, y;
	P() {}
	P(double _x, double _y) : x(_x), y(_y) {}
}p[N], hull[N], pivot, rect[8];

inline int zero(const double &amp;a) {
	return fabs(a) &lt; 1e-4;
}
inline int sign(const double &amp;a) {
	if (fabs(a) &lt; 1e-8)
		return 0;
	return a &lt; 0 ? -1 : 1;
}
inline double cross(const P &amp;A, const P &amp;B, const P &amp;C) {
	return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
}
inline double dis2(const P &amp;A, const P &amp;B) {
	return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
}
inline bool cmp(const P &amp;A, const P &amp;B) {
	double t = cross(pivot, A, B);
	return (sign(t) == 1) || (sign(t) == 0 &amp;&amp; sign(dis2(pivot, A) - dis2(pivot, B)) == -1);
}

inline void convexhull(int n, P *s, int &amp;size) {
	int i, tp, k;
	for (k = 0, i = 1; i &lt; n; ++i)
		if (::p[i].y &lt; ::p[k].y || (::p[i].y == ::p[k].y &amp;&amp; ::p[i].x &lt; ::p[k].x)) k = i;
	pivot = ::p[k], ::p[k] = ::p[0], ::p[0] = pivot;
	std::sort(::p + 1, ::p + n, cmp);
	s[0] = pivot, s[1] = ::p[1];
	for (tp = 1, i = 2; i &lt; n; ++i) {
		while (tp &amp;&amp; sign(cross(::p[i], s[tp], s[tp - 1])) &gt;= 0)
			--tp;
		s[++tp] = ::p[i];
	}
	size = tp + 1;
}

inline double area(const P &amp;A, const P &amp;B, const P &amp;C) {
	return fabs(cross(A, B, C));
}
inline P vertical(const P &amp;A, const P &amp;B) {
	return P(A.x - B.y + A.y, A.y + B.x - A.x);
}

#define nxt(a) ((++a) &lt; n ? (a) : (a = 0))

bool del[N];

int main() {
	int n, i, j, k, l, r;
	P A, B, C;
	double ans = 1e22, t, w, h, _len;
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 0; i &lt; n; ++i) 
		scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);
	convexhull(n, hull, n);
	for (i = 1; i &lt; n; ++i)
		del[i] = zero(hull[i].x - hull[i - 1].x) &amp;&amp; zero(hull[i].y - hull[i - 1].y);
	for (k = i = 0; i &lt; n; ++i)
		if (!del[i]) hull[k++] = hull[i];
	for (hull[n = k] = hull[i = j = l = r = 0]; i &lt; n; ++i) {
		A = hull[i], B = hull[i + 1];
		C = vertical(A, B);
		while (sign(area(A, B, hull[j]) - area(A, B, hull[j + 1])) &lt; 1) nxt(j);
		while (sign(cross(A, C, hull[l]) - cross(A, C, hull[l + 1])) &lt; 1) nxt(l);
		while (sign(cross(A, C, hull[r]) - cross(A, C, hull[r + 1])) &gt; -1) nxt(r);
		_len = 1.0 / sqrt(dis2(A, B));
		h = area(A, B, hull[j]) * _len;
		w = (cross(A, C, hull[l]) - cross(A, C, hull[r])) * _len;
		if (sign(h * w - ans) == -1) {//update ans
			ans = h * w;

			t = area(A, B, hull[l]) * _len * _len;
			rect[0] = P(hull[l].x + t * (A.x - C.x), hull[l].y + t * (A.y - C.y));

			t = h * _len;
			rect[3] = P(rect[0].x + t * (C.x - A.x), rect[0].y + t * (C.y - A.y));
			
			t = w * _len;
			rect[1] = P(rect[0].x + t * (B.x - A.x), rect[0].y + t * (B.y - A.y));
			rect[2] = P(rect[3].x + t * (B.x - A.x), rect[3].y + t * (B.y - A.y));
		}
	}
	for (i = 0; i ^ 4; ++i)
		rect[i + 4] = rect[i];
	for (j = 0, i = 1; i ^ 4; ++i)
		if (sign(rect[i].y - rect[j].y) == -1 || (sign(rect[i].y - rect[j].y) == 0 &amp;&amp; sign(rect[i].x - rect[j].x) == -1))
			j = i;
	printf(&quot;%.0f.00000\n&quot;, ans);
	//printf(&quot;%.5lf\n&quot;, ans);
	for (i = 0; i ^ 4; ++i)
		printf(&quot;%.0lf.00000 %.0lf.00000\n&quot;, rect[j + i].x, rect[j + i].y);
	//printf(&quot;%.5lf %.5lf\n&quot;, rect[j + i].x, rect[j + i].y);
	return 0;
}
<pre><h2>Problem1185</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define N 50005

struct P {
	double x, y;
	P() {}
	P(double _x, double _y) : x(_x), y(_y) {}
}p[N], hull[N], pivot, rect[8];

inline int zero(const double &amp;a) {
	return fabs(a) &lt; 1e-4;
}
inline int sign(const double &amp;a) {
	if (fabs(a) &lt; 1e-8)
		return 0;
	return a &lt; 0 ? -1 : 1;
}
inline double cross(const P &amp;A, const P &amp;B, const P &amp;C) {
	return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
}
inline double dis2(const P &amp;A, const P &amp;B) {
	return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
}
inline bool cmp(const P &amp;A, const P &amp;B) {
	double t = cross(pivot, A, B);
	return (sign(t) &gt; 0) || (!sign(t) &amp;&amp; sign(dis2(pivot, A) - dis2(pivot, B)) &lt; 0);
}

inline void convexhull(int n, P *s, int &amp;size) {
	int i, tp, k;
	for (k = 0, i = 1; i &lt; n; ++i)
		if (::p[i].y &lt; ::p[k].y || (::p[i].y == ::p[k].y &amp;&amp; ::p[i].x &lt; ::p[k].x)) k = i;
	pivot = ::p[k], ::p[k] = ::p[0], ::p[0] = pivot;
	std::sort(::p + 1, ::p + n, cmp);
	s[0] = pivot, s[1] = ::p[1];
	for (tp = 1, i = 2; i &lt; n; ++i) {
		while (tp &amp;&amp; sign(cross(::p[i], s[tp], s[tp - 1])) &gt;= 0)
			--tp;
		s[++tp] = ::p[i];
	}
	size = tp + 1;
}

inline double area(const P &amp;A, const P &amp;B, const P &amp;C) {
	return fabs(cross(A, B, C));
}
inline P vertical(const P &amp;A, const P &amp;B) {
	return P(A.x - B.y + A.y, A.y + B.x - A.x);
}

#define nxt(a) ((++a) &lt; n ? (a) : (a = 0))

bool del[N];

int main() {
	int n, i, j, k, l, r;
	P A, B, C;
	double ans = 1e22, t, w, h, _len;
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 0; i &lt; n; ++i) 
		scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);
	convexhull(n, hull, n);
	for (i = 1; i &lt; n; ++i)
		del[i] = zero(hull[i].x - hull[i - 1].x) &amp;&amp; zero(hull[i].y - hull[i - 1].y);
	for (k = i = 0; i &lt; n; ++i)
		if (!del[i]) hull[k++] = hull[i];
	for (hull[n = k] = hull[i = j = l = r = 0]; i &lt; n; ++i) {
		A = hull[i], B = hull[i + 1];
		C = vertical(A, B);
		while (sign(area(A, B, hull[j]) - area(A, B, hull[j + 1])) &lt; 1) nxt(j);
		while (sign(cross(A, C, hull[l]) - cross(A, C, hull[l + 1])) &lt; 1) nxt(l);
		while (sign(cross(A, C, hull[r]) - cross(A, C, hull[r + 1])) &gt; -1) nxt(r);
		_len = 1.0 / sqrt(dis2(A, B));
		h = area(A, B, hull[j]) * _len;
		w = (cross(A, C, hull[l]) - cross(A, C, hull[r])) * _len;
		if (sign(h * w - ans) &lt; 0) {//update ans
			ans = h * w;

			t = area(A, B, hull[l]) * _len * _len;
			rect[0] = P(hull[l].x + t * (A.x - C.x), hull[l].y + t * (A.y - C.y));

			t = h * _len;
			rect[3] = P(rect[0].x + t * (C.x - A.x), rect[0].y + t * (C.y - A.y));
			
			t = w * _len;
			rect[1] = P(rect[0].x + t * (B.x - A.x), rect[0].y + t * (B.y - A.y));
			rect[2] = P(rect[3].x + t * (B.x - A.x), rect[3].y + t * (B.y - A.y));
		}
	}
	for (i = 0; i ^ 4; ++i)
		rect[i + 4] = rect[i];
	for (j = 0, i = 1; i ^ 4; ++i)
		if (sign(rect[i].y - rect[j].y) &lt; 0 || (zero(rect[i].y - rect[j].y) &amp;&amp; sign(rect[i].x - rect[j].x) &lt; 0))
			j = i;
	printf(&quot;%.0f.00000\n&quot;, ans);
	//printf(&quot;%.5lf\n&quot;, ans);
	for (i = 0; i ^ 4; ++i)
		printf(&quot;%.0lf.00000 %.0lf.00000\n&quot;, rect[j + i].x, rect[j + i].y);
	//printf(&quot;%.5lf %.5lf\n&quot;, rect[j + i].x, rect[j + i].y);
	return 0;
}
<pre><h2>Problem1185</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
 
#define N 50005
 
struct P {
    double x, y;
    P() {}
    P(double _x, double _y) : x(_x), y(_y) {}
}p[N], hull[N], pivot, rect[8];
 
inline int zero(const double &amp;a) {
    return fabs(a) &lt; 1e-4;
}
inline int sign(const double &amp;a) {
    if (fabs(a) &lt; 1e-8)
        return 0;
    return a &lt; 0 ? -1 : 1;
}
inline double cross(const P &amp;A, const P &amp;B, const P &amp;C) {
    return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
}
inline double dis2(const P &amp;A, const P &amp;B) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
}
inline bool cmp(const P &amp;A, const P &amp;B) {
    double t = cross(pivot, A, B);
    return (sign(t) == 1) || (sign(t) == 0 &amp;&amp; sign(dis2(pivot, A) - dis2(pivot, B)) == -1);
}
 
inline void convexhull(int n, P *s, int &amp;size) {
    int i, tp, k;
    for (k = 0, i = 1; i &lt; n; ++i)
        if (::p[i].y &lt; ::p[k].y || (::p[i].y == ::p[k].y &amp;&amp; ::p[i].x &lt; ::p[k].x)) k = i;
    pivot = ::p[k], ::p[k] = ::p[0], ::p[0] = pivot;
    std::sort(::p + 1, ::p + n, cmp);
    s[0] = pivot, s[1] = ::p[1];
    for (tp = 1, i = 2; i &lt; n; ++i) {
        while (tp &amp;&amp; sign(cross(::p[i], s[tp], s[tp - 1])) &gt;= 0)
            --tp;
        s[++tp] = ::p[i];
    }
    size = tp + 1;
}
 
inline double area(const P &amp;A, const P &amp;B, const P &amp;C) {
    return fabs(cross(A, B, C));
}
inline P vertical(const P &amp;A, const P &amp;B) {
    return P(A.x - B.y + A.y, A.y + B.x - A.x);
}
 
#define nxt(a) ((++a) &lt; n ? (a) : (a = 0))
 
bool del[N];
 
int main() {
    int n, i, j, k, l, r;
    P A, B, C;
    double ans = 1e22, t, w, h, _len;
    scanf(&quot;%d&quot;, &amp;n);
    for (i = 0; i &lt; n; ++i) 
        scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);
    convexhull(n, hull, n);
    for (i = 1; i &lt; n; ++i)
        del[i] = zero(hull[i].x - hull[i - 1].x) &amp;&amp; zero(hull[i].y - hull[i - 1].y);
    for (k = i = 0; i &lt; n; ++i)
        if (!del[i]) hull[k++] = hull[i];
    for (hull[n = k] = hull[i = j = l = r = 0]; i &lt; n; ++i) {
        A = hull[i], B = hull[i + 1];
        C = vertical(A, B);
        while (sign(area(A, B, hull[j]) - area(A, B, hull[j + 1])) &lt; 1) nxt(j);
        while (sign(cross(A, C, hull[l]) - cross(A, C, hull[l + 1])) &lt; 1) nxt(l);
        while (sign(cross(A, C, hull[r]) - cross(A, C, hull[r + 1])) &gt; -1) nxt(r);
        _len = 1.0 / sqrt(dis2(A, B));
        h = area(A, B, hull[j]) * _len;
        w = (cross(A, C, hull[l]) - cross(A, C, hull[r])) * _len;
        if (sign(h * w - ans) == -1) {//update ans
            ans = h * w;
 
            t = area(A, B, hull[l]) * _len * _len;
            rect[0] = P(hull[l].x + t * (A.x - C.x), hull[l].y + t * (A.y - C.y));
 
            t = h * _len;
            rect[3] = P(rect[0].x + t * (C.x - A.x), rect[0].y + t * (C.y - A.y));
             
            t = w * _len;
            rect[1] = P(rect[0].x + t * (B.x - A.x), rect[0].y + t * (B.y - A.y));
            rect[2] = P(rect[3].x + t * (B.x - A.x), rect[3].y + t * (B.y - A.y));
        }
    }
    for (i = 0; i ^ 4; ++i)
        rect[i + 4] = rect[i];
    for (j = 0, i = 1; i ^ 4; ++i)
        if (sign(rect[i].y - rect[j].y) == -1 || (sign(rect[i].y - rect[j].y) == 0 &amp;&amp; sign(rect[i].x - rect[j].x) == -1))
            j = i;
    printf(&quot;%.0f.00000\n&quot;, ans);
    //printf(&quot;%.5lf\n&quot;, ans);
    for (i = 0; i ^ 4; ++i)
        printf(&quot;%.0lf.00000 %.0lf.00000\n&quot;, rect[j + i].x, rect[j + i].y);
	//printf(&quot;%.5lf %.5lf\n&quot;, rect[j + i].x, rect[j + i].y);
    return 0;
}
<pre><h2>Problem1185</h2><pre>main(){puts(&quot;nan\nnan nan\nnan nan\nnan nan\nnan nan&quot;);}<pre><h2>Problem1185</h2><pre>print'nan\nnan nan\nnan nan\nnan nan\nnan nan'<pre><h2>Problem1185</h2><pre>main(){puts(&quot;nan nan nan nan nan nan nan nan nan&quot;);}<pre><h2>Problem1185</h2><pre>main(){puts(&quot;nan &quot;&quot;nan &quot;&quot;nan &quot;&quot;nan &quot;&quot;nan &quot;&quot;nan &quot;&quot;nan &quot;&quot;nan &quot;&quot;nan&quot;);}<pre><h2>Problem1185</h2><pre>var i:shortint;begin for i:=1 to 9 do write('nan ');end.<pre><h2>Problem1185</h2><pre>var i:byte;begin for i:=1 to 9 do write('nan ');end.<pre><h2>Problem1185</h2><pre>var i:byte;begin for i:=1 to 9 do write('nan');end.<pre><h2>Problem1185</h2><pre>begin write('nannannannannannannannannan');end.<pre><h2>Problem1185</h2><pre>begin write('nannannannannannannannannan')end.<pre><h2>Problem1188</h2><pre>#include &lt;cstdio&gt;

typedef unsigned int ui;
ui sg[23], vis[1003], _vis, p[23], ans, cnt;

int main() {
	int o_o, n;
	scanf(&quot;%d&quot;, &amp;o_o);
	while (o_o--) {
		scanf(&quot;%d&quot;, &amp;n);
		for (register int i = 0; i &lt; n; ++i)
			scanf(&quot;%d&quot;, p + i);
		cnt = ans = sg[n - 1] = 0U;
		for (register int i = n - 2; ~i; --i) {
			++_vis;
			for (register int j = i + 1; j &lt; n; ++j)
				for (register int k = j; k &lt; n; ++k)
					vis[sg[j] ^ sg[k]] = _vis;
			for (ui &amp;x = sg[i] = 0; ; ++x)
				if (vis[x] ^ _vis) break;
			if (p[i] &amp; 1) ans ^= sg[i];
		}
		for (register int i = 0; i &lt; n; ++i)
			for (register int j = i + 1; j &lt; n; ++j)
				for (register int k = j; k &lt; n; ++k)
					if (ans ^ sg[i] ^ sg[j] ^ sg[k]);
					else {
						if (++cnt &lt;= 1) printf(&quot;%d %d %d\n&quot;, i, j, k);
					}
		if (!cnt) puts(&quot;-1 -1 -1&quot;);
		printf(&quot;%u\n&quot;, cnt);
	}
	return 0;
}<pre><h2>Problem1189</h2><pre>/*by SilverN*/
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
const int INF=1e9;
const int mx[5]={0,1,0,-1,0};
const int my[5]={0,0,1,0,-1};
const int mxn=45;
struct edge{
    int v,nxt,f;
}e[500010];
int hd[mxn*mxn],mct=1;
inline void add_edge(int u,int v,int c){
    e[++mct].v=v;e[mct].nxt=hd[u];e[mct].f=c;hd[u]=mct;return;
}
inline void insert(int u,int v,int c){
    add_edge(u,v,c);add_edge(v,u,0);
    return;
}
vector&lt;pair&lt;int,int&gt; &gt;pos;
char mp[mxn][mxn];
int dis[mxn][mxn][mxn];
int id[mxn][mxn],ict=0;
int n,m,S,T;
int tot=0,dr=0,ans=0;
int d[mxn*mxn];
bool BFS(){
    memset(d,0,sizeof d);
    queue&lt;int&gt;q;
    q.push(S);
    d[S]=1;
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=hd[u];i;i=e[i].nxt){
            int v=e[i].v;
            if(!d[v] &amp;&amp; e[i].f){
                d[v]=d[u]+1;
                q.push(v);
            }
        }
    }
    return d[T];
}
int DFS(int u,int lim){
    if(u==T)return lim;
    int tmp,f=0;
    for(int i=hd[u];i;i=e[i].nxt){
        int v=e[i].v;
        if(d[v]==d[u]+1 &amp;&amp; e[i].f){
            tmp=DFS(v,min(lim,e[i].f));
            e[i].f-=tmp;
            e[i^1].f+=tmp;
            lim-=tmp;
            f+=tmp;
            if(!lim)return f;
        }
    }
    d[u]=0;
    return f;
}
int Dinic(){
    int res=0;
    while(BFS())res+=DFS(S,1e9);
    return res;
}
int main(){
    int i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(i=1;i&lt;=n;i++)
        scanf(&quot;%s&quot;,mp[i]+1);
    S=0;T=1;ict=1;
    for(i=1;i&lt;=n;i++)
		for(j=1;j&lt;=m;j++){
			if(mp[i][j]=='X')continue;
			id[i][j]=++ict;
			if(mp[i][j]=='.'){
				tot++;
				pos.push_back(make_pair(i,j));
				insert(S,id[i][j],1);
			}
		}
    memset(dis,0x3f,sizeof dis);
    for(i=1;i&lt;=n;i++)
        for(j=1;j&lt;=m;j++){
            if(mp[i][j]=='D'){
                dr++;
                queue&lt; pair&lt;int,int&gt; &gt;q;
                q.push(make_pair(i,j));
                dis[dr][i][j]=0;
                while(!q.empty()){
                    int x=q.front().first;
                    int y=q.front().second;
                    q.pop();
                    for(int k=1;k&lt;=4;k++){
                        int nx=x+mx[k];
                        int ny=y+my[k];
                        if(nx&lt;1 || nx&gt;n || ny&lt;1 || ny&gt;m)continue;
                        if(mp[nx][ny]!='.')continue;
                        if(dis[dr][nx][ny]&gt;dis[dr][x][y]+1){
                            dis[dr][nx][ny]=dis[dr][x][y]+1;
                            q.push(make_pair(nx,ny));
                        }
                    }
                }
            }
        }
    for(i=1;i&lt;=tot*2;i++){//枚举时间 
        if(i&gt;1)    for(j=1;j&lt;=dr;j++){
				insert(ict+dr*(i-2)+j,ict+dr*(i-1)+j,INF);//在门边等待 
			}
        for(j=1;j&lt;=dr;j++)
            insert(ict+dr*(i-1)+j,T,1);//可以撤离一个人 
        for(j=1;j&lt;=dr;j++){
            for(int k=0;k&lt;pos.size();k++){
                int x=pos[k].first;
                int y=pos[k].second;
                if(mp[x][y]=='.' &amp;&amp; dis[j][x][y]==i)
                    insert(id[x][y],ict+dr*(i-1)+j,1);//移动到门边 
            }
        }
        ans+=Dinic();
        if(ans==tot){printf(&quot;%d\n&quot;,i);return 0;}
    }
    printf(&quot;impossible\n&quot;);
    return 0;
}
<pre><h2>Problem1195</h2><pre>    #include&lt;iostream&gt;  
    #include&lt;cstdio&gt;  
    #include&lt;cstring&gt;  
    using namespace std;  
      
    int n,len[13],f[4096][13],c[13][13],bin[13]; bool bo[13];  
    char s[4096][13][601],a[13][51];  
    bool eql(int x,int i,int y){  
        int j;  
        for (j=1; i&lt;=len[x] &amp;&amp; j&lt;=len[y]; i++,j++)  
            if (a[x][i]!=a[y][j]) return 0;  
        return 1;  
    }  
    int calc(int x,int y){  
        int i;  
        for (i=max(1,len[x]-len[y]+1); i&lt;=len[x]; i++)  
            if (eql(x,i,y)) return len[y]-(len[x]-i+1);  
        return len[y];  
    }  
    bool insd(int x,int y){  
        if (len[x]&gt;len[y]) return 0; int i;  
        for (i=1; i+len[x]-1&lt;=len[y]; i++)  
            if (eql(y,i,x)) return 1;  
        return 0;  
    }  
    int main(){  
          
        //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);  
        scanf(&quot;%d&quot;,&amp;n); int i,j,k,x;  
        for (i=1; i&lt;=n; i++){  
            scanf(&quot;%s&quot;,a[i]+1); len[i]=strlen(a[i]+1);  
        }  
        memset(bo,1,sizeof(bo));  
        for (i=1; i&lt;=n; i++)  
            for (j=1; j&lt;=n; j++) if (i!=j &amp;&amp; insd(i,j)){  
                bo[i]=0; break;  
            }  
        int cnt=0;  
        for (i=1; i&lt;=n; i++) if (bo[i]){  
            cnt++; memcpy(a[cnt],a[i],sizeof(a[i]));  
        }  
        n=max(cnt,1);  
        for (i=1; i&lt;=n; i++) len[i]=strlen(a[i]+1);  
        for (i=1; i&lt;=n; i++)  
            for (j=1; j&lt;=n; j++) if (i!=j) c[i][j]=calc(i,j);  
        memset(f,0x3f,sizeof(f));  
        bin[0]=1; for (i=1; i&lt;=n; i++) bin[i]=bin[i-1]&lt;&lt;1;  
        for (i=1; i&lt;=n; i++){  
            f[bin[i-1]][i]=len[i]; memcpy(s[bin[i-1]][i],a[i],sizeof(a[i]));  
        }  
        int l,p; bool flag;  
        for (i=1; i&lt;bin[n]; i++)  
            for (j=1; j&lt;=n; j++) if (i&amp;bin[j-1]){  
                x=i^bin[j-1];  
                for (k=1; k&lt;=n; k++) if (x&amp;bin[k-1]){  
                    if (f[x][k]+c[k][j]&lt;f[i][j]){  
                        f[i][j]=f[x][k]+c[k][j]; memcpy(s[i][j],s[x][k],sizeof(s[x][k]));  
                        l=strlen(s[i][j]+1);  
                        for (p=len[j]-c[k][j]+1; p&lt;=len[j]; p++) s[i][j][++l]=a[j][p];  
                    } else if (f[x][k]+c[k][j]==f[i][j]){  
                        l=strlen(s[x][k]+1); flag=0;  
                        for (p=1; p&lt;=l; p++)  
                            if (s[x][k][p]&lt;s[i][j][p]){ flag=1; break; }  
                            else if (s[x][k][p]&gt;s[i][j][p]) break;  
                        if (flag){  
                            memcpy(s[i][j],s[x][k],sizeof(s[x][k]));  
                            for (p=len[j]-c[k][j]+1; p&lt;=len[j]; p++) s[i][j][++l]=a[j][p];  
                        }  
                    }  
                }  
            }  
        x=bin[n]-1; k=1;  
        for (i=2; i&lt;=n; i++)  
            if (f[x][i]&lt;f[x][k]) k=i; else  
            if (f[x][i]==f[x][k]){  
                flag=0;  
                for (j=1; j&lt;=f[x][i]; j++)  
                    if (s[x][i][j]&lt;s[x][k][j]){ flag=1; break; }  
                    else if (s[x][i][j]&gt;s[x][k][j]) break;  
                if (flag) k=i;  
            }  
        l=strlen(s[x][k]+1);  
        for (i=1; i&lt;=l; i++) putchar(s[x][k][i]); puts(&quot;&quot;);  
        return 0;  
    }  <pre><h2>Problem1195</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

typedef unsigned int uit;
const uit bs = 0xe7;
const int MaxN = 13, MaxL = 52;

bool mark[MaxN];
uit hash[MaxN][MaxL], p[MaxL];
char a[MaxN][MaxL], s[4096][MaxN][601];
int len[MaxN], f[4096][MaxN], c[MaxN][MaxN], bin[MaxN];

#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
#define inline 
inline void Pre(const char *s, const int &amp;len, uit *f) {
	int i; rep(i, 1, len) f[i] = f[i - 1] * bs + s[i];
}

inline uit ghs(const uit *f, const int &amp;l, const int &amp;r) {
	return f[r] - f[l - 1] * p[r - l + 1];
}

inline uit ghs(const int &amp;x, const int &amp;l, const int &amp;r) {
	return ghs(hash[x], l, r);
}

inline bool insd(const int &amp;i, const int &amp;j) {
	if (len[i] &gt; len[j])
	  return false;
	static int k;
	rep(k, 1, len[j] - len[i] + 1)
		if (hash[i][len[i]] == ghs(j, k, k + len[i] - 1))
		  return true;
	return false;
}

inline int calc(const int &amp;x, const int &amp;y) {
	static int i;
	rep(i, (len[x] &lt; len[y] ? 1 : (len[x] - len[y] + 1)), len[x]) {
		//printf(&quot;%u %u\n&quot;, ghs(x, i, len[x]), ghs(y, 1, len[x] - i + 1));
		if (ghs(x, i, len[x]) == ghs(y, 1, len[x] - i + 1))
		  return len[y] - (len[x] - i + 1);
	}
	return len[y];
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	bool flag;
	int i, j, k, x, n, cnt = 0, l, p;
	scanf(&quot;%d&quot;, &amp;n);
	::p[0] = 1;
	rep(i, 1, MaxL - 1) ::p[i] = ::p[i - 1] * bs;
	rep(i, 1, n) {
		scanf(&quot;%s&quot;, a[i] + 1);
		len[i] = strlen(a[i] + 1);
		Pre(a[i], len[i], hash[i]);
		mark[i] = true;
	}
	rep(i, 1, n) rep(i, j + 1, n) {
		if (len[i] == len[j])
		  mark[i] = ! (hash[i][len[i]] == hash[j][len[j]]);
		else if (insd(i, j)) mark[i] = false;
		else if (insd(j, i)) mark[j] = false;
	}
	rep(i, 1, n) if (mark[i]) {
		memcpy(a[++cnt], a[i], sizeof a[i]);
		len[cnt] = len[i];
	}
	n = cnt;
	rep(i, 1, n) rep(j, i + 1, n) {
		c[i][j] = calc(i, j);
		c[j][i] = calc(j, i);
		//printf(&quot;%s %s %d\n&quot;, a[i] + 1, a[j] + 1, c[i][j]);
		//printf(&quot;%s %s %d\n&quot;, a[j] + 1, a[i] + 1, c[j][i]);
	}

	memset(f, 63, sizeof f);
	bin[0] = 1;
	rep(i, 1, n) {
		bin[i] = bin[i - 1] &lt;&lt; 1;
		f[bin[i - 1]][i] = len[i];
		memcpy(s[bin[i - 1]][i], a[i], sizeof a[i]);
	}
	for (i = 1; i &lt; bin[n]; ++i)
	  rep(j, 1, n) if (i &amp; bin[j - 1]) {  
		  x = i ^ bin[j - 1];  
		  rep(k, 1, n) if (x &amp; bin[k - 1]) {  
			  if (f[x][k] + c[k][j] &lt; f[i][j]) {  
				  f[i][j] = f[x][k] + c[k][j]; 
				  memcpy(s[i][j], s[x][k], sizeof s[x][k]);  
				  l = strlen(s[i][j] + 1);
				  rep(p, len[j] - c[k][j] + 1, len[j]) 
					  s[i][j][++l] = a[j][p];  
			  } else if (f[x][k] + c[k][j] == f[i][j]){  
				  l=strlen(s[x][k] + 1); 
				  flag=false;  
				  rep(p, 1, l)
					  if (s[x][k][p] &lt; s[i][j][p]) {
						  flag = true;
						  break;
					  } else if (s[x][k][p] &gt; s[i][j][p]) 
						break;  
				  if (flag){  
					  memcpy(s[i][j], s[x][k], sizeof s[x][k]);  
					  rep (p, len[j]-c[k][j]+1, len[j]) 
						  s[i][j][++l]=a[j][p];  
				  }  
			  }  
		  }  
	  }  
	x=bin[n] - 1, k=1;  
	rep(i, 2, n)  
		if (f[x][i]&lt;f[x][k]) k=i; 
		else if (f[x][i] == f[x][k]) {  
			flag=0;  
			for (j=1; j&lt;=f[x][i]; j++)  
			  if (s[x][i][j]&lt;s[x][k][j]) { 
				  flag=1; 
				  break;
			  } else if (s[x][i][j]&gt;s[x][k][j]) 
				break;  
			if (flag) k=i;  
		}  
	l=strlen(s[x][k] + 1);  
	rep(i, 1, l) putchar(s[x][k][i]); 
	puts(&quot;&quot;);  
	return 0;
}<pre><h2>Problem1202</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
int f[105],s[105];
int gf(int u) {
	if(f[u]==u) return u;
	int t=f[u];
	f[u]=gf(f[u]);
	s[u]+=s[t];
	return f[u];
}
int main() {
	register int w=geti(),m,i,j,v,fi,fj;
	register bool flag;
	while(w--) {
		flag=true;
		for(i=geti()+1,m=geti();~i;--i) f[i]=i,s[i]=0;
		while(0&lt;m--) {
			fi=gf(i=geti()-1),fj=gf(j=geti()),v=geti();
			if(fi^fj) {
				f[fi]=fj,s[fi]=s[j]-s[i]-v;
			} else if(s[j]-s[i]!=v) {flag=false;break;}
		}
		while(0&lt;m--) geti(),geti(),geti();
		puts(flag?&quot;true&quot;:&quot;false&quot;);
	}return 0;
}<pre><h2>Problem1208</h2><pre>#include &lt;cstdio&gt;

#define MOD 1000000
#define MAX_SIZE 100007
#define BUFFER_SIZE (1 &lt;&lt; 16 | 1)

char buffer[BUFFER_SIZE], *start(buffer), *end(buffer);
inline char next_char() {
	if (start == end) {
		end = (start = buffer) + fread(buffer, 1, BUFFER_SIZE, stdin);
		if (start == end) return EOF;
	}
	return *start++;
}
inline void next_int(int &amp;a) {
	register char c;
	do c = next_char(); while (c &lt; 48);
	a = c ^ 48;
	while (47 &lt; (c = next_char()))
		a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (c ^ 48);
}

struct node {
	int value;
	node *fa, *ch[2];
	inline bool which() const {
		return this == fa-&gt;ch[1];
	}
} node_mset[MAX_SIZE], *curten_node(node_mset);
node *root, *pred_node, *succ_node;

inline void rotate(node *u) {
	node *f = u-&gt;fa;
	int d = u == f-&gt;ch[1];
	if (f-&gt;ch[d] = u-&gt;ch[d ^ 1])
		f-&gt;ch[d]-&gt;fa = f;
	if (u-&gt;fa = f-&gt;fa)
		f-&gt;fa-&gt;ch[f == f-&gt;fa-&gt;ch[1]] = u;
	f-&gt;fa = u, u-&gt;ch[d ^ 1] = f;
}

inline void splay(node *u, const node *tag) {
	for (register node *f; u-&gt;fa != tag; rotate(u))
		if ((f = u-&gt;fa)-&gt;fa != tag)
			rotate(u-&gt;which() == f-&gt;which() ? f : u);
	if (tag == NULL)
		root = u;
}

inline void insert(const int &amp;value) {
	if (root == NULL) {
		curten_node-&gt;value = value;
		root = curten_node++;
		return;
	}
	register int d;
	for (register node *u = root; ; u = u-&gt;ch[d]) {
		d = value &lt; u-&gt;value ? 0 : 1;
		if (u-&gt;ch[d] == NULL) {
			curten_node-&gt;fa = u;
			curten_node-&gt;value = value;
			u-&gt;ch[d] = curten_node++;
			splay(u-&gt;ch[d], NULL);
			return;
		}
	}
}

inline void pred(const int &amp;value) {
	pred_node = NULL;
	for (register node *u = root; u;)
		if (value &lt; u-&gt;value)
			u = u-&gt;ch[0];
		else
			u = (pred_node = u)-&gt;ch[1];
	if (pred_node != NULL)
		splay(pred_node, NULL);
}

inline void succ(const int &amp;value) {
	succ_node = NULL;
	for (register node *u = root; u;)
		if (value &gt; u-&gt;value)
			u = u-&gt;ch[1];
		else
			u = (succ_node = u)-&gt;ch[0];
	if (succ_node != NULL)
		splay(succ_node, NULL);
}

inline void remove(node *u) {
	splay(u, NULL);
	if (root-&gt;ch[0] == NULL) {
		root = root-&gt;ch[1];
		if (root != NULL)
			root-&gt;fa = NULL;
	} else {
		register node *c = root-&gt;ch[0];
		while (c-&gt;ch[1] != NULL)
			c = c-&gt;ch[1];
		splay(c, root);
		c-&gt;fa = NULL;
		c-&gt;ch[1] = root-&gt;ch[1];
		if (root-&gt;ch[1] != NULL)
			root-&gt;ch[1]-&gt;fa = c;
		root = c;
	}
}

inline int query(const int &amp;value) {
	pred(value);
	succ(value);
	if (pred_node != NULL &amp;&amp; succ_node != NULL) {
		if (value - pred_node-&gt;value &lt;= succ_node-&gt;value - value)
			return remove(pred_node), value - pred_node-&gt;value;
		return remove(succ_node), succ_node-&gt;value - value;
	} else if (pred_node != NULL)
		return remove(pred_node), value - pred_node-&gt;value;
	return remove(succ_node), succ_node-&gt;value - value;
}

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;1208.in&quot;, &quot;r&quot;, stdin);
#endif
	int o_o, flag(0), a, b, ans(0);
	for (next_int(o_o); o_o; --o_o) {
		next_int(a);
		next_int(b);
		if (!a) a = -1;
		if (a * flag &gt;= 0)
			insert(b);
		else
			ans += query(b);
		flag += a;
		while (ans &gt;= MOD)
			ans -= MOD;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem1208</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define MS 100007
#define mod 1000000
char Inb[1&lt;&lt;16|1],*Ine=Inb,*Ins=Inb;
#define getc() ((Ins==Ine&amp;&amp;(Ine=(Ins=Inb)+fread(Inb,1,1&lt;&lt;16,stdin),Ins==Ine))?EOF:*Ins++)
inline int geti() {
    register int a; register char c;
    while(c=getc(),c&lt;48);a=c^48;
    while(c=getc(),47&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+(c^48);
    return a;
}struct node {
    int v; node *fa,*ch[2];
}CD[MS],*root=NULL,*cd=CD,*t1,*t2;
inline void rot(node *u) {
    node *f=u-&gt;fa,*ff=f-&gt;fa;
    int d=u==f-&gt;ch[1];
    if(f-&gt;ch[d]=u-&gt;ch[d^1]) f-&gt;ch[d]-&gt;fa=f;
    f-&gt;fa=u; u-&gt;ch[d^1]=f;
    if(u-&gt;fa=ff) ff-&gt;ch[f==ff-&gt;ch[1]]=u;
}inline void splay(node *u,node *tag) {
    while(u-&gt;fa!=tag) {
        if(u-&gt;fa-&gt;fa==tag) {rot(u); break;}
        if((u==u-&gt;fa-&gt;ch[1])==(u-&gt;fa==u-&gt;fa-&gt;fa-&gt;ch[1])) rot(u-&gt;fa);
        else rot(u);
        rot(u);
    }
    if(tag==NULL) root=u;
}inline void ins(const int&amp;val) {
    if(root==NULL) {
        cd-&gt;v=val; root=cd++;
        return;
    }
    register node *u=root;
    register int d;
    while(u) {
        d=(val&lt;u-&gt;v)?0:1;
        if(u-&gt;ch[d]) u=u-&gt;ch[d];
        else {
            cd-&gt;v=val; cd-&gt;fa=u;
            u-&gt;ch[d]=cd++;
            break;
        }
    }
    splay(cd-1,NULL);
}inline void pred(const int&amp;val) {
    node *u=root; t1=NULL;
    while(u) {
        if(val&lt;u-&gt;v) u=u-&gt;ch[0];
        else t1=u,u=u-&gt;ch[1];
    }if(t1) splay(t1,NULL);
}inline void succ(const int&amp;val) {
    node *u=root; t2=NULL;
    while(u) {
        if(u-&gt;v&lt;val) u=u-&gt;ch[1];
        else t2=u,u=u-&gt;ch[0];
    }if(t2) splay(t2,NULL);
}inline void del(node*u) {
    splay(u,NULL);
    if(root-&gt;ch[0]==NULL) {
        root=root-&gt;ch[1];
        if(root) root-&gt;fa=NULL;
    } else {
        register node *c=root-&gt;ch[0];
        while(c-&gt;ch[1]) c=c-&gt;ch[1];
        splay(c,root); c-&gt;ch[1]=root-&gt;ch[1];c-&gt;fa=NULL;
        if(root-&gt;ch[1]) root-&gt;ch[1]-&gt;fa=c;
        root=c;
    }
}inline int query(const int&amp;val) {
    succ(val); pred(val);
    if(t1&amp;&amp;t2) {
        if(val-t1-&gt;v&lt;=t2-&gt;v-val) return del(t1),val-t1-&gt;v;
        return del(t2),t2-&gt;v-val;
    } else if(t1) return del(t1),val-t1-&gt;v;
    return del(t2),t2-&gt;v-val;
}int main() {
    register int T,flag=0,a,b,ans=0;
    for(T=geti();T;--T) {
        a=geti(),b=geti();
        if(!a) a=-1;
        if(a*flag&gt;=0) ins(b);
        else ans+=query(b);
        flag+=a; while(ans&gt;=mod) ans-=mod;
    }
    printf(&quot;%d&quot;,ans);
    return 0;}<pre><h2>Problem1208</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define MS 100007
#define mod 1000000
#define ni (c&lt;'0'|'9'&lt;c)
char Inb[1&lt;&lt;16|1],*Ine=Inb,*Ins=Inb;
#define getc() ((Ins==Ine&amp;&amp;(Ine=(Ins=Inb)+fread(Inb,1,1&lt;&lt;16|1,stdin),Ins==Ine))?EOF:*Ins++)
inline int geti() {
    register int a; register char c;
    while(c=getc(),ni);a=c-'0';
    while(c=getc(),!ni)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return a;
}
struct node {
    int v; node *fa,*ch[2];
}CD[MS],*root=NULL,*cd=CD,*t1,*t2;
inline void rot(node *u) {
    node *f=u-&gt;fa,*ff=f-&gt;fa;
    int d=u==f-&gt;ch[1];
    if(f-&gt;ch[d]=u-&gt;ch[d^1]) f-&gt;ch[d]-&gt;fa=f;
    f-&gt;fa=u; u-&gt;ch[d^1]=f;
    if(u-&gt;fa=ff) ff-&gt;ch[f==ff-&gt;ch[1]]=u;
}
inline void splay(node *u,node *tag) {
    while(u-&gt;fa!=tag) {
        if(u-&gt;fa-&gt;fa==tag) {rot(u); break;}
        if((u==u-&gt;fa-&gt;ch[1])==(u-&gt;fa==u-&gt;fa-&gt;fa-&gt;ch[1])) rot(u-&gt;fa);
        else rot(u);
        rot(u);
    }
    if(tag==NULL) root=u;
}
inline void ins(const int&amp;val) {
    if(root==NULL) {
        cd-&gt;v=val; root=cd++;
        return;
    }
    register node *u=root;
    register int d;
    while(u) {
        d=(val&lt;u-&gt;v)?0:1;
        if(u-&gt;ch[d]) u=u-&gt;ch[d];
        else {
            cd-&gt;v=val; cd-&gt;fa=u;
            u-&gt;ch[d]=cd++;
            break;
        }
    }
    splay(cd-1,NULL);
}
inline void pred(const int&amp;val) {
    node *u=root; t1=NULL;
    while(u) {
        if(val&lt;u-&gt;v) u=u-&gt;ch[0];
        else t1=u,u=u-&gt;ch[1];
    }if(t1) splay(t1,NULL);
}
inline void succ(const int&amp;val) {
    node *u=root; t2=NULL;
    while(u) {
        if(u-&gt;v&lt;val) u=u-&gt;ch[1];
        else t2=u,u=u-&gt;ch[0];
    }if(t2) splay(t2,NULL);
}
inline void del(node*u) {
    splay(u,NULL);
    if(root-&gt;ch[0]==NULL) {
        root=root-&gt;ch[1];
        if(root) root-&gt;fa=NULL;
    } else {
        register node *c=root-&gt;ch[0];
        while(c-&gt;ch[1]) c=c-&gt;ch[1];
        splay(c,root); c-&gt;ch[1]=root-&gt;ch[1];c-&gt;fa=NULL;
        if(root-&gt;ch[1]) root-&gt;ch[1]-&gt;fa=c;
        root=c;
    }
}
inline int query(const int&amp;val) {
    succ(val); pred(val);
    if(t1&amp;&amp;t2) {
        if(val-t1-&gt;v&lt;=t2-&gt;v-val) return del(t1),val-t1-&gt;v;
        return del(t2),t2-&gt;v-val;
    } else if(t1) return del(t1),val-t1-&gt;v;
    return del(t2),t2-&gt;v-val;
}
int main() {register int T,flag=0,a,b,ans=0;for(T=geti();T;--T) {
        a=geti(),b=geti();
        if(!a) a=-1;
        if(a*flag&gt;=0) ins(b);
        else ans+=query(b);
        flag+=a; while(ans&gt;=mod) ans-=mod;
    }printf(&quot;%d&quot;,ans); return 0;
}<pre><h2>Problem1257</h2><pre>#include &lt;cstdio&gt;
#define ull unsigned long long
int main() {
	unsigned int n, k;
	ull ans = 0;
	scanf(&quot;%u%u&quot;, &amp;n, &amp;k);
	if (n &gt; k) ans = (ull)(n - k) * k, n = k;
	for (unsigned int i = 1, r, t; i &lt;= n; i = r + 1) {
		t = k / i;
		r = k / t;
		if (r &gt; n) r = n;
		ans += (ull)(r - i + 1) * k - (ull)(r - i + 1) * (i + r) / 2 * t;
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}
<pre><h2>Problem1300</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;

#define MOD9 1000000000
#define MOD12 1000000000000ll
#define MAXN 1000005

bool mark[MAXN];
int prime[MAXN / 10], prime_conut;
inline void silver(const int &amp;n) {
  prime_conut = 0;
  for (int i = 2; i &lt;= n; ++i) {
    if (!mark[i]) {
      prime[prime_conut++] = i;
    }
    for (int j = 0, t; (t = prime[j] * i) &lt;= n; ++j) {
      mark[t] = true;
      if (i % prime[j] == 0) break;
    }
  }
}
inline long long ModC(int n, int m, long long mod) {
  int _m = n - m;
  long long result = 1;
  for (int i = 0; i &lt; prime_conut; ++i) {
    int in = n, im = m, i_m = _m;
    while (in) {
      int base = prime[i];
      int count = (in /= base) - (im /= base) - (i_m /= base);
      while (count) {
        if (count &amp; 1) result = result * base % mod;
        base *= base;
        count &gt;&gt;= 1;
      }
    }
  }
  return result;
}

int main() {
  int n, m, _m;
  scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
  silver(n);
  _m = n - m;
  if (_m &lt; m) {
    _m ^= m;
    m ^= _m;
    _m ^= m;
  }
  double dig = 0, dou_buf = 1;
  for (int i = 1; i &lt;= m; ++i) {
    if (dou_buf &gt; MOD9) {
      dig += log10(dou_buf);
      dou_buf = 1;
    }
    dou_buf = dou_buf * (_m + i) / i;
  }
  dig += log10(dou_buf);
  if (dig &lt; 13) printf(&quot;%lld\n&quot;, ModC(n, m, MOD12));
  else printf(&quot;%d...%09lld\n&quot;, int(pow(10, dig - floor(dig) + 2) + 1e-5), ModC(n, m, MOD9));
  return 0;
}<pre><h2>Problem1449</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 5e3 + 5, MaxM = 1005, inf = 0x3f3f3f3f;
typedef int arr[MaxM + MaxN];

struct edge {
	int to, cap, cost, nxt;
} e[(MaxN + MaxM) * 10];

int S, T, edgecnt, ans, que[(MaxM + MaxN) * 10], _vis;
arr head, dis, win, lose, C, D, remin, vis;
bool inq[MaxN + MaxM];

inline void add_edge(int u, int v, int cap, int cost) {
	e[edgecnt] = (edge) {v, cap, cost, head[u]}, head[u] = edgecnt++;
	e[edgecnt] = (edge) {u,  0, -cost, head[v]}, head[v] = edgecnt++;
}

inline bool spfa() {
	static int i, u, v, *l, *r;
	for (i = S; i &lt; T; ++i)
	  dis[i] = inf, inq[i] = false;
	dis[T] = 0;
	l = r = que;
	*r++ = T;
	while (l &lt; r) {
		u = *l++;
		inq[u] = false;
		for (i = head[u]; ~i; i = e[i].nxt) {
			v = e[i].to;
			if (e[i ^ 1].cap &amp;&amp; dis[u] + e[i ^ 1].cost &lt; dis[v]) {
				dis[v] = dis[u] + e[i ^ 1].cost;
				if (!inq[v]) {
					*r++ = v;
					inq[v] = true;
				}
			}
		}
	}
	return dis[S] ^ inf;
}

int dfs(int u, int flow) {
	vis[u] = _vis;
	if (u == T)
	  return flow;
	int ret = 0, t, v;
	for (int i = head[u]; ~i; i = e[i].nxt) {
		v = e[i].to;
		if ((vis[v] ^ _vis) &amp;&amp; e[i].cap &amp;&amp; dis[u] == dis[v] + e[i].cost) {
			t = dfs(v, flow &lt; e[i].cap ? flow : e[i].cap);
			e[i].cap -= t;
			e[i ^ 1].cap += t;
			ret += t;
			flow -= t;
			ans += t * e[i].cost;
			if (!flow)
			  return ret;
		}
	}
	return ret;
}

inline void zkw() {
	while (spfa()) {
		vis[T] = ++_vis;
		//puts(&quot;1&quot;);
		//printf(&quot;%d\n&quot;, ans);
		while (vis[T] &gt;= _vis) {
			++_vis;
			dfs(S, inf);
		}
	}
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, m, i, x, y;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	S = 0, T = n + m + 1;
	memset(head, -1, sizeof head);
	for (i = 1; i &lt;= n; ++i) scanf(&quot;%d%d%d%d&quot;, win + i, lose + i, C + i, D + i);
	for (i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		++remin[x];
		++remin[y];
		add_edge(S, i, 1, 0);
		add_edge(i, x + m, 1, 0);
		add_edge(i, y + m, 1, 0);
	}
	for (i = 1; i &lt;= n; ++i) {
		lose[i] += remin[i];
		ans += win[i] * win[i] * C[i] + lose[i] * lose[i] * D[i];
		for (x = 1; x &lt;= remin[i]; ++x) {
			add_edge(i + m, T, 1, 2 * (win[i] * C[i] - lose[i] * D[i]) + C[i] + D[i]);
			++win[i], --lose[i];
		}
	}
	//printf(&quot;%d\n&quot;, ans);
	zkw();
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem1488</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int mod(997), maxn(66);
typedef int arr[maxn];

arr fac, x, y;
int n, cnt, ans;

inline int gcd(int a, int b) {
  for (static int t; b; t = a % b, a = b, b = t);
  return a;
}

inline int qp(int a, int b) {
  static int r;
  for (r = 1; b; b &gt;&gt;= 1, a = a * a % mod)
    if (b &amp; 1) r = r * a % mod;
  return r;
}

void dfs(int nx, int left) {
  if (!left) {
    static int a, b;
    a = 0, b = 1;
    for (register int i = 1; i &lt;= cnt; ++i) {
      a += x[i] * (x[i] - 1) / 2 * y[i] + y[i] / 2 * x[i];
      for (register int j = i + 1; j &lt;= cnt; ++j)
        a += x[i] * x[j] * gcd(y[i], y[j]);
    }
    for (register int i = 1; i &lt;= cnt; ++i)
      b = b * qp(y[i], x[i]) * fac[x[i]] % mod;
    b = qp(b, mod - 2) * fac[n] % mod;
    ans = (ans + qp(2, a) * b) % mod;
  }
  if (nx &gt; left) return;
  dfs(nx + 1, left);
  for (register int i = 1; i * nx &lt;= left; ++i) {
    ++cnt;
    x[cnt] = i;
    y[cnt] = nx;
    dfs(nx + 1, left - i * nx);
    --cnt;
  }
}

int main() {
  scanf(&quot;%d&quot;, &amp;n);
  fac[0] = 1;
  for (register int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % mod;
  dfs(1, n);
  ans = ans * qp(fac[n], mod - 2) % mod;
  printf(&quot;%d\n&quot;, ans);
  return 0;
}<pre><h2>Problem1492</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define N 100005
#define eps 1e-9
#define oo 1e20
struct D{
	double a,b,r,x,y,k;int id;
	inline void init(int _id){
		scanf(&quot;%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;r);
		k=-a/b;id=_id;
	}
	inline bool operator &lt; (const D&amp;x)const{return x.k&lt;k;}
}p[N],t[N];
double dp[N];int st[N];
inline void cmax(double&amp;a,double b){if(a&lt;b)a=b;}
inline double getk(int i,int j) {
	if(!j) return -oo;
	if(fabs(p[i].x-p[j].x)&lt;eps)return oo;
	return (p[i].y-p[j].y)/(p[i].x-p[j].x);
}
void solve(int l,int r){
	if(l&gt;=r) {
		cmax(dp[l],dp[l-1]);
		p[l].y=dp[l]/(p[l].a*p[l].r+p[l].b);
		p[l].x=p[l].r*p[l].y;return;
	}
	int m=l+r&gt;&gt;1,t1=l,t2=m+1,i,j,tp=0;
	for(i=l;i&lt;=r;++i)(p[i].id&lt;=m)?t[t1++]=p[i]:t[t2++]=p[i];
	for(i=l;i&lt;=r;++i)p[i]=t[i];
	solve(l,m);tp=0;
	for(i=l;i&lt;=m;++i){
		while(1&lt;tp&amp;&amp;getk(st[tp-1],st[tp])&lt;getk(st[tp-1],i)+eps)--tp;
		st[++tp]=i;
	}st[++tp]=0;j=1;
	for(i=m+1;i&lt;=r;++i) {
		while(j&lt;tp&amp;&amp;getk(st[j],st[j+1])+eps&gt;p[i].k)++j;
		cmax(dp[p[i].id],p[st[j]].x*p[i].a+p[st[j]].y*p[i].b);
	}solve(m+1,r);
	for(i=l,t1=l,t2=m+1;i&lt;=r;++i)
		if(t1&lt;=m&amp;&amp;(p[t1].x&lt;p[t2].x||((fabs(p[t1].x-p[t2].x)&lt;eps&amp;&amp;p[t1].y&lt;p[t2].y))||t2&gt;r))t[i]=p[t1++];
		else t[i]=p[t2++];
	for(i=l;i&lt;=r;++i)p[i]=t[i];
}
int main() {
	int n;
	scanf(&quot;%d%lf&quot;,&amp;n,dp);
	for(register int i=1;i&lt;=n;++i)(p+i)-&gt;init(i);
	std::sort(p+1,p+n+1);
	solve(1,n);
	printf(&quot;%.3lf&quot;,dp[n]);
	return 0;
}
<pre><h2>Problem1493</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int ina; char inc;
inline int geti() {
    for(;(inc=getchar())&lt;'0'||inc&gt;'9';);
    for(ina=inc-'0';(inc=getchar())&gt;='0'&amp;&amp;inc&lt;='9';ina=(ina&lt;&lt;3)+(ina&lt;&lt;1)+inc-'0');
    return ina;
}
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
#define N 500010
struct D{
    int lc,rc,pa;
    D operator + (const D&amp;a) const {
        D ret; ret.lc=lc,ret.rc=a.rc;
        ret.pa=pa+a.pa; if(rc==a.lc) --ret.pa;
        return ret;
    }
    inline void ch(int a)  {lc=rc=a; pa=1;}
}C[N&lt;&lt;2];
int ly[N&lt;&lt;2],n,c,dis,q; bool d;
inline void Down(int u){
    if(!ly[u]) return;
    ly[ls]=ly[rs]=ly[u];
    C[ls].ch(ly[u]),C[rs].ch(ly[u]);
    ly[u]=0;
}
void Update(int u,int l,int r,int x,int y,int op) {
    if(x&lt;=l&amp;&amp;r&lt;=y) {
        ly[u]=op; C[u].ch(op);
        return;
    }Down(u);
    int m=l+r&gt;&gt;1;
    if(y&lt;=m) Update(ls,l,m,x,y,op);
    else if(x&gt;m) Update(rs,m+1,r,x,y,op);
    else {Update(ls,l,m,x,m,op);Update(rs,m+1,r,m+1,y,op);}
    C[u]=C[ls]+C[rs];
}
inline void cal(int &amp;x,int &amp;y) {
    if(d){
        x=(n+2-x-dis+n)%n;
        y=(n+2-y-dis+n)%n;
        x^=y^=x^=y;
    }else x=(x-dis+n)%n,y=(y-dis+n)%n;
    (!x)?x=n:1,(!y)?y=n:1;
}
int find(int u,int l,int r,int p) {
    if(l==r) return C[u].lc;
    Down(u); int m=l+r&gt;&gt;1;
    return (p&lt;=m)?find(ls,l,m,p):find(rs,m+1,r,p);
}
D Query(int u,int l,int r,int x,int y){
    if(x&lt;=l&amp;&amp;r&lt;=y) return C[u];
    Down(u); int m=l+r&gt;&gt;1;
    if(y&lt;=m) return Query(ls,l,m,x,y);
    if(x&gt;m) return Query(rs,m+1,r,x,y);
    return Query(ls,l,m,x,m)+Query(rs,m+1,r,m+1,y);
}
void Build(int u,int l,int r) {
    if(l==r) {C[u].ch(geti()); return;}
    int m=l+r&gt;&gt;1; Build(ls,l,m); Build(rs,m+1,r);
    C[u]=C[ls]+C[rs];
}
int main() {
#ifndef ONLINE_JUDGE
    freopen(&quot;T.in&quot;,&quot;r&quot;,stdin);
#endif
    char ts[3]; int x,y,z,cx,cy;
    n=geti(),c=geti(); Build(1,1,n);
    for(q=geti();q;--q) {
        scanf(&quot;%s&quot;,ts);
        if(*ts=='R') {
            z=geti();
            if(d)dis=(dis+n-z)%n;
            else dis=(dis+z)%n;
        }
        else if(*ts=='F') d=!d;
        else if(*ts=='P') {
            x=geti(),y=geti(),z=geti(); cal(x,y);
            if(x&gt;y) Update(1,1,n,x,n,z),Update(1,1,n,1,y,z);
            else Update(1,1,n,x,y,z);
        } else if(*ts=='S') {
            x=geti(),y=geti(); cal(x,y);
            cx=find(1,1,n,x),cy=find(1,1,n,y);
            Update(1,1,n,x,x,cy); Update(1,1,n,y,y,cx);
        } else if(ts[1]=='S') {
            x=geti(),y=geti(); cal(x,y);
            if(x&gt;y) printf(&quot;%d\n&quot;,(Query(1,1,n,x,n)+Query(1,1,n,1,y)).pa);
            else printf(&quot;%d\n&quot;,Query(1,1,n,x,y).pa);
        } else {
            z=Query(1,1,n,1,n).pa-(C[1].lc==C[1].rc); (z&lt;1)?z=1:0;
            printf(&quot;%d\n&quot;,z);
        }
    }return 0;
}<pre><h2>Problem1494</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const unsigned int mo=65521;
typedef unsigned int ui;
typedef ui mat[53][53];
inline ui qp(ui a,ui b){ui r=1;for(;b;b&gt;&gt;=1,a=a*a%mo)if(b&amp;1)r=r*a%mo;return r;}
inline void cmax(int&amp;a,const int&amp;b){if(a&lt;b)a=b;}

int ct,k,dig[5],cnt[5],mp[43211],st[53][5];
long long n; mat a,b;
ui f[53];
inline int mul(mat&amp;x,mat&amp;y) {
	static mat c;
	register int i,j,k;
	for(i=0;i&lt;ct;++i)
		for(j=0;j&lt;ct;++j) {
			c[i][j]=0;
			for(k=0;k&lt;ct;++k)
				for(c[i][j]+=x[i][k]*y[k][j]%mo;c[i][j]&gt;=mo;c[i][j]-=mo);
		}
	for(i=0;i&lt;ct;++i)for(j=0;j&lt;ct;++j)x[i][j]=c[i][j];
}
inline void expand(int x) {
	static int i,t;
	mp[x]=-1;
	for(i=0,t=x;i&lt;k;++i)
		if((dig[i]=t%10)&gt;=k) return;
		else t/=10;
	for(i=0,t=-1;i&lt;k;++i)
		if(dig[i]&gt;t+1) return;
		else cmax(t,dig[i]);
	memset(cnt,0,sizeof cnt);
	mp[x]=ct;
	for(i=0;i&lt;k;++i)
		st[ct][i]=dig[i],++cnt[dig[i]];
	t=1;
	for(i=0;i&lt;k;++i)
		if(cnt[i]&gt;1) t=(ui)t*qp(cnt[i],cnt[i]-2)%mo;
	f[ct++]=t;
}
int col[5],ora[5];
inline void buildmat(int x) {
	int*p=st[x];
	static int i,j,t;
	bool flag=true;
	for(i=1,t=0;i&lt;k;++i)cmax(t,p[i]),flag&amp;=(p[i]^*p);
	int ennum=1&lt;&lt;t+1,mark,tmp,now;
	ui C,cc;
	for(i=0;i&lt;ennum;++i) {
		if(flag &amp;&amp; !(i&amp;1))  continue;
		mark=-1;
		for(j=0;j&lt;k;++j)col[j]=j;
		for(j=0;j&lt;=t;++j) if(i&gt;&gt;j&amp;1)(~mark)?col[j]=mark:mark=j;
		memset(ora,-1,sizeof ora);
		tmp=-1;
		for(j=1;j&lt;k;++j)
			dig[j-1]=(~ora[col[p[j]]])?ora[col[p[j]]]:(ora[col[p[j]]]=++tmp);
		dig[k-1]=(~(mark)&amp;&amp;(~ora[mark]))?ora[mark]:++tmp;
		now=dig[k-1];
		for(j=k-2;~j;--j)now=(now&lt;&lt;3)+(now&lt;&lt;1)+dig[j];
		if(mp[now]&lt;0) continue;
		C=1;
		if(~mark)for(j=0;j&lt;k;++j)
					 if(col[j]==mark) {
						 cc=0;
						 for(tmp=0;tmp&lt;k;++tmp)
							 cc+=p[tmp]==j;
						 C=C*cc%mo;
					 }
		b[x][mp[now]]=C;
	}
}
int main() {
	scanf(&quot;%d%lld&quot;,&amp;k,&amp;n);
	if(k&gt;=n) return printf(&quot;%u\n&quot;,qp(n,n-2)),0;
	int t=0,i;
	for(i=k-1;~i;--i)t=(t&lt;&lt;3)+(t&lt;&lt;1)+i;
	for(i=0;i&lt;=t;++i)expand(i);
	for(i=0,n-=k;i&lt;ct;++i)buildmat(i);
	for(i=0;i&lt;ct;++i)a[i][i]=1;
	for(;n;n&gt;&gt;=1,mul(b,b))if(n&amp;1)mul(a,b);
	ui ans=0;
	for(i=0;i&lt;ct;++i)
		for(ans+=f[i]*a[i][0]%mo;ans&gt;=mo;ans-=mo);
	printf(&quot;%u\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1500</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
inline bool nn(const char &amp;a) {return a &lt; '0' || '9' &lt; a;}
inline int gi() {
    static int a; static char c, f;
    for (f = 0; nn(c = getchar()); f|= c == '-');
    for (a = c - '0'; !nn(c = getchar()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
    return f ? -a : a;
}
typedef int arr[500009];
arr pre, ch[2], key, sum, size, lx, rx, mx, trash, a;
bool same[500009], rev[500009];
int rt, tot, cnttrash;
int newnode(int v, int fa) {
    static int r;
    if (cnttrash) r = trash[cnttrash--];
    else r = ++tot;
    pre[r] = fa;
    ch[0][r] = ch[1][r] = 0;
    lx[r] = rx[r] = max(0,v);
    mx[r] = key[r] = sum[r] = v;
	same[r] = rev[r] = 0;
    size[r] = 1;
    return r;
}
void pushup(int u) {
    static int ls, rs;
    if (!u) return;
    ls = ch[0][u], rs = ch[1][u];
    sum[u] = sum[ls] + sum[rs] + key[u];
    size[u] = size[ls] + size[rs] + 1;
    lx[u] = max(lx[ls], sum[ls] + key[u] + lx[rs]);
    rx[u] = max(rx[rs], sum[rs] + key[u] + rx[ls]);
    mx[u] = rx[ls] + key[u] + lx[rs];
    if (ls) mx[u] = max(mx[u], mx[ls]);
    if (rs) mx[u] = max(mx[u], mx[rs]);
}
void change_value(int u, int v) {
    if (!u) return;
    key[u] = v;
    sum[u] = size[u] * v;
    mx[u] = max(v, sum[u]);
    lx[u] = rx[u] = max(0,sum[u]);
    same[u] = 1;
}
void make_rev(int u) {
    if (!u) return;
    swap(ch[0][u], ch[1][u]);
    swap(lx[u], rx[u]);
    rev[u] ^= 1;
}
void pushdown(int u) {
    if (!u) return;
    if (same[u]) {
        if (ch[0][u]) change_value(ch[0][u], key[u]);
        if (ch[1][u]) change_value(ch[1][u], key[u]);
        same[u] = 0;
    }
    if (rev[u]) {
        if (ch[0][u]) make_rev(ch[0][u]);
        if (ch[1][u]) make_rev(ch[1][u]);
        rev[u] = 0;
    }
}
bool type(int u) {return ch[1][pre[u]] == u;}
void rot(int u) {
    static int o, d;
    pushdown(o); pushdown(u);
    o = pre[u], d = type(u);
    if (ch[d][o] = ch[d^1][u]) pre[ch[d][o]] = o;
    if (pre[u] = pre[o]) ch[type(o)][pre[o]] = u;
    pre[o] = u, ch[d^1][u] = o;
    pushup(o); pushup(u);
}
void splay(int u, int target) {
    static int f;
    for (; pre[u] ^ target; rot(u))
        if ((pre[f = pre[u]] ^ target) &amp;&amp; type(u) == type(f)) rot(f);
    if (!target) rt = u;
}
int kth(int k) {
    static int u, t;
    for (u = rt; u;) {
        pushdown(u);
        t = size[ch[0][u]] + 1;
        if (t &lt; k) k -= t, u = ch[1][u];
        else if (k &lt; t) u = ch[0][u];
        else return u;
    }
}
void build(int &amp;u, int l, int r, int fa) {
    if (l &gt; r) return;
    int m = l + r &gt;&gt; 1;
    u = newnode(a[m], fa);
    build(ch[0][u], l, m - 1, u);
    build(ch[1][u], m + 1, r, u);
    pushup(u);
}
void erase(int u) {
    if (!u) return;
    erase(ch[0][u]);
    erase(ch[1][u]);
    trash[++cnttrash] = u;
}
void grange(int l, int r) {
    splay(kth(l), 0); splay(kth(r), rt);
}
void PRINT(int u) {
    if (!u) return;
    pushdown(u);
    printf(&quot;u = %3d sum = %3d key = %3d mx = %3d ls = %3d rs = %3d lx = %3d rx = %3d\n&quot;, u, sum[u], key[u], mx[u], ch[0][u], ch[1][u], lx[u], rx[u]);
    PRINT(ch[0][u]);
    PRINT(ch[1][u]);
}
int main() {
//    freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
//    freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);
    int n, m, i, pos, tot;
    char op[20];
    n = gi(), m = gi();
    for (i = 1; i &lt;= n; ++i) a[i] = gi();
    build(rt, 0, n + 1, 0);
    while (m--) {
        scanf(&quot;%s&quot;, op);
        if (*op == 'I') {
            pos = gi(), tot = gi();
            grange(pos + 1, pos + 2);
            for (i = 0; i &lt; tot; ++i) a[i] = gi();
            build(ch[0][ch[1][rt]], 0, tot - 1, ch[1][rt]);
            pushup(ch[1][rt]); pushup(rt);
        } else if (*op == 'D' ) {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            erase(ch[0][ch[1][rt]]);
            ch[0][ch[1][rt]] = 0;
            pushup(ch[1][rt]); pushup(rt);
        } else if (*op == 'M') {
            if (op[2] == 'K') {
                pos = gi(), tot = gi();
                grange(pos, pos + tot + 1);
                change_value(ch[0][ch[1][rt]], gi());
                pushup(ch[1][rt]); pushup(rt);
            } else {
                grange(1, size[rt]);
                printf(&quot;%d\n&quot;, mx[ch[0][ch[1][rt]]]);
            }
        } else if (*op == 'R') {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            make_rev(ch[0][ch[1][rt]]);
            pushup(ch[1][rt]); pushup(rt);
        } else {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            printf(&quot;%d\n&quot;, sum[ch[0][ch[1][rt]]]);
        }
        //puts(&quot;\n-----------------&quot;);
        //PRINT(rt); puts(&quot;&quot;);
    }
    return 0;
}
<pre><h2>Problem1500</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
inline bool nn(const char &amp;a) {return a &lt; '0' || '9' &lt; a;}
inline int gi() {
    static int a; static char c, f;
    for (f = 0; nn(c = getchar()); f|= c == '-');
    for (a = c - '0'; !nn(c = getchar()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
    return f ? -a : a;
}
typedef int arr[500009];
arr pre, ch[2], key, sum, size, lx, rx, mx, trash, a;
bool same[500009], rev[500009];
int rt, tot, cnttrash;
int newnode(int v, int fa) {
    static int r;
    if (cnttrash) r = trash[cnttrash--];
    else r = ++tot;
    pre[r] = fa;
    ch[0][r] = ch[1][r] = 0;
    lx[r] = rx[r] = max(0,v);
    mx[r] = key[r] = sum[r] = v;
	same[r] = rev[r] = 0;
    size[r] = 1;
    return r;
}
void pushup(int u) {
    static int ls, rs;
    if (!u) return;
    ls = ch[0][u], rs = ch[1][u];
    sum[u] = sum[ls] + sum[rs] + key[u];
    size[u] = size[ls] + size[rs] + 1;
    lx[u] = max(lx[ls], sum[ls] + key[u] + lx[rs]);
    rx[u] = max(rx[rs], sum[rs] + key[u] + rx[ls]);
    mx[u] = rx[ls] + key[u] + lx[rs];
    if (ls) mx[u] = max(mx[u], mx[ls]);
    if (rs) mx[u] = max(mx[u], mx[rs]);
}
void change_value(int u, int v) {
    key[u] = v;
    sum[u] = size[u] * v;
    mx[u] = max(v, sum[u]);
    lx[u] = rx[u] = max(0,sum[u]);
    same[u] = 1;
}
void make_rev(int u) {
    swap(ch[0][u], ch[1][u]);
    swap(lx[u], rx[u]);
    rev[u] ^= 1;
}
void pushdown(int u) {
    if (!u) return;
    if (same[u]) {
        if (ch[0][u]) change_value(ch[0][u], key[u]);
        if (ch[1][u]) change_value(ch[1][u], key[u]);
        same[u] = 0;
    }
    if (rev[u]) {
        if (ch[0][u]) make_rev(ch[0][u]);
        if (ch[1][u]) make_rev(ch[1][u]);
        rev[u] = 0;
    }
}
bool type(int u) {return ch[1][pre[u]] == u;}
void rot(int u) {
    static int o, d;
    pushdown(o); pushdown(u);
    o = pre[u], d = type(u);
    if (ch[d][o] = ch[d^1][u]) pre[ch[d][o]] = o;
    if (pre[u] = pre[o]) ch[type(o)][pre[o]] = u;
    pre[o] = u, ch[d^1][u] = o;
    pushup(o); pushup(u);
}
void splay(int u, int target) {
    static int f;
    for (; pre[u] ^ target; rot(u))
        if (pre[f = pre[u]] ^ target) rot((type(u)^type(f))?u:f);
    if (!target) rt = u;
}
int kth(int k) {
    static int u, t;
    for (u = rt; u;) {
        pushdown(u);
        t = size[ch[0][u]] + 1;
        if (t &lt; k) k -= t, u = ch[1][u];
        else if (k &lt; t) u = ch[0][u];
        else return u;
    }
}
void build(int &amp;u, int l, int r, int fa) {
    if (l &gt; r) return;
    int m = l + r &gt;&gt; 1;
    u = newnode(a[m], fa);
    build(ch[0][u], l, m - 1, u);
    build(ch[1][u], m + 1, r, u);
    pushup(u);
}
void erase(int u) {
    if (!u) return;
    erase(ch[0][u]);
    erase(ch[1][u]);
    trash[++cnttrash] = u;
}
void grange(int l, int r) {
    splay(kth(l), 0); splay(kth(r), rt);
}
void PRINT(int u) {
    if (!u) return;
    pushdown(u);
    printf(&quot;u = %3d sum = %3d key = %3d mx = %3d ls = %3d rs = %3d lx = %3d rx = %3d\n&quot;, u, sum[u], key[u], mx[u], ch[0][u], ch[1][u], lx[u], rx[u]);
    PRINT(ch[0][u]);
    PRINT(ch[1][u]);
}
int main() {
//    freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
//    freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);
    int n, m, i, pos, tot;
    char op[20];
    n = gi(), m = gi();
    for (i = 1; i &lt;= n; ++i) a[i] = gi();
    build(rt, 0, n + 1, 0);
    while (m--) {
        scanf(&quot;%s&quot;, op);
        if (*op == 'I') {
            pos = gi(), tot = gi();
            grange(pos + 1, pos + 2);
            for (i = 0; i &lt; tot; ++i) a[i] = gi();
            build(ch[0][ch[1][rt]], 0, tot - 1, ch[1][rt]);
            pushup(ch[1][rt]); pushup(rt);
        } else if (*op == 'D' ) {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            erase(ch[0][ch[1][rt]]);
            ch[0][ch[1][rt]] = 0;
            pushup(ch[1][rt]); pushup(rt);
        } else if (*op == 'M') {
            if (op[2] == 'K') {
                pos = gi(), tot = gi();
                grange(pos, pos + tot + 1);
                change_value(ch[0][ch[1][rt]], gi());
                pushup(ch[1][rt]); pushup(rt);
            } else {
                grange(1, size[rt]);
                printf(&quot;%d\n&quot;, mx[ch[0][ch[1][rt]]]);
            }
        } else if (*op == 'R') {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            make_rev(ch[0][ch[1][rt]]);
            pushup(ch[1][rt]); pushup(rt);
        } else {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            printf(&quot;%d\n&quot;, sum[ch[0][ch[1][rt]]]);
        }
        //puts(&quot;\n-----------------&quot;);
        //PRINT(rt); puts(&quot;&quot;);
    }
    return 0;
}<pre><h2>Problem1500</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
inline bool nn(const char &amp;a) {return a &lt; '0' || '9' &lt; a;}
inline int gi() {
    static int a; static char c, f;
    for (f = 0; nn(c = getchar()); f|= c == '-');
    for (a = c - '0'; !nn(c = getchar()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
    return f ? -a : a;
}
typedef int arr[500009];
arr pre, ch[2], key, sum, size, lx, rx, mx, trash, a;
bool same[500009], rev[500009];
int rt, tot, cnttrash;
int newnode(int v, int fa) {
    static int r;
    if (cnttrash) r = trash[cnttrash--];
    else r = ++tot;
    pre[r] = fa;
    ch[0][r] = ch[1][r] = 0;
    lx[r] = rx[r] = max(0,v);
    mx[r] = key[r] = sum[r] = v;
	same[r] = rev[r] = 0;
    size[r] = 1;
    return r;
}
void pushup(int u) {
    static int ls, rs;
    ls = ch[0][u], rs = ch[1][u];
    sum[u] = sum[ls] + sum[rs] + key[u];
    size[u] = size[ls] + size[rs] + 1;
    lx[u] = max(lx[ls], sum[ls] + key[u] + lx[rs]);
    rx[u] = max(rx[rs], sum[rs] + key[u] + rx[ls]);
    mx[u] = rx[ls] + key[u] + lx[rs];
    if (ls) mx[u] = max(mx[u], mx[ls]);
    if (rs) mx[u] = max(mx[u], mx[rs]);
}
void change_value(int u, int v) {
    key[u] = v;
    sum[u] = size[u] * v;
    mx[u] = max(v, sum[u]);
    lx[u] = rx[u] = max(0,sum[u]);
    same[u] = 1;
}
void make_rev(int u) {
    swap(ch[0][u], ch[1][u]);
    swap(lx[u], rx[u]);
    rev[u] ^= 1;
}
void pushdown(int u) {
    if (same[u]) {
        if (ch[0][u]) change_value(ch[0][u], key[u]);
        if (ch[1][u]) change_value(ch[1][u], key[u]);
        same[u] = 0;
    }
    if (rev[u]) {
        if (ch[0][u]) make_rev(ch[0][u]);
        if (ch[1][u]) make_rev(ch[1][u]);
        rev[u] = 0;
    }
}
bool type(int u) {return ch[1][pre[u]] == u;}
void rot(int u) {
    static int o, d;
    pushdown(o); pushdown(u);
    o = pre[u], d = type(u);
    if (ch[d][o] = ch[d^1][u]) pre[ch[d][o]] = o;
    if (pre[u] = pre[o]) ch[type(o)][pre[o]] = u;
    pre[o] = u, ch[d^1][u] = o;
    pushup(o); pushup(u);
}
void splay(int u, int target) {
    static int f;
    for (; pre[u] ^ target; rot(u))
        if (pre[f = pre[u]] ^ target) rot((type(u)^type(f))?u:f);
    if (!target) rt = u;
}
int kth(int k) {
    static int u, t;
    for (u = rt; u;) {
        pushdown(u);
        t = size[ch[0][u]] + 1;
        if (t &lt; k) k -= t, u = ch[1][u];
        else if (k &lt; t) u = ch[0][u];
        else return u;
    }
}
void build(int &amp;u, int l, int r, int fa) {
    if (l &gt; r) return;
    int m = l + r &gt;&gt; 1;
    u = newnode(a[m], fa);
    build(ch[0][u], l, m - 1, u);
    build(ch[1][u], m + 1, r, u);
    pushup(u);
}
void erase(int u) {
    if (!u) return;
    erase(ch[0][u]);
    erase(ch[1][u]);
    trash[++cnttrash] = u;
}
void grange(int l, int r) {
    splay(kth(l), 0); splay(kth(r), rt);
}
void PRINT(int u) {
    if (!u) return;
    pushdown(u);
    printf(&quot;u = %3d sum = %3d key = %3d mx = %3d ls = %3d rs = %3d lx = %3d rx = %3d\n&quot;, u, sum[u], key[u], mx[u], ch[0][u], ch[1][u], lx[u], rx[u]);
    PRINT(ch[0][u]);
    PRINT(ch[1][u]);
}
int main() {
//    freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
//    freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);
    int n, m, i, pos, tot;
    char op[20];
    n = gi(), m = gi();
    for (i = 1; i &lt;= n; ++i) a[i] = gi();
    build(rt, 0, n + 1, 0);
    while (m--) {
        scanf(&quot;%s&quot;, op);
        if (*op == 'I') {
            pos = gi(), tot = gi();
            grange(pos + 1, pos + 2);
            for (i = 0; i &lt; tot; ++i) a[i] = gi();
            build(ch[0][ch[1][rt]], 0, tot - 1, ch[1][rt]);
            pushup(ch[1][rt]); pushup(rt);
        } else if (*op == 'D' ) {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            erase(ch[0][ch[1][rt]]);
            ch[0][ch[1][rt]] = 0;
            pushup(ch[1][rt]); pushup(rt);
        } else if (*op == 'M') {
            if (op[2] == 'K') {
                pos = gi(), tot = gi();
                grange(pos, pos + tot + 1);
                change_value(ch[0][ch[1][rt]], gi());
                pushup(ch[1][rt]); pushup(rt);
            } else {
                grange(1, size[rt]);
                printf(&quot;%d\n&quot;, mx[ch[0][ch[1][rt]]]);
            }
        } else if (*op == 'R') {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            make_rev(ch[0][ch[1][rt]]);
            pushup(ch[1][rt]); pushup(rt);
        } else {
            pos = gi(), tot = gi();
            grange(pos, pos + tot + 1);
            printf(&quot;%d\n&quot;, sum[ch[0][ch[1][rt]]]);
        }
        //puts(&quot;\n-----------------&quot;);
        //PRINT(rt); puts(&quot;&quot;);
    }
    return 0;
}<pre><h2>Problem1588</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline int gi() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 100005
#define inf 0x7f7f7f7f
int pred[N],succ[N],a[N],b[N],r[N];
inline int gf(int u,int*f) {
	int r=u;while(f[r]^r)r=f[r];
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
inline void cmin(long long&amp;a,const long long&amp;b){if(b&lt;a)a=b;}
inline bool cmp(const int&amp;i,const int&amp;j){return a[i]&lt;a[j];}
int main() {
	int n=gi(),i,x;
	for(i=1;i&lt;=n;++i)b[i]=a[i]=gi(),r[i]=i;
	std::sort(r+1,r+n+1,cmp);
	for(i=1;i&lt;=n;++i) a[r[i]]=i;
	for(i=1;i&lt;=n;++i) r[i]=a[i],a[i]=b[i];
	std::sort(a+1,a+n+1);
	for(i=1;i&lt;=n;++i)pred[i]=i,succ[i]=i;
	succ[n+1]=n+1;
	long long ans=0,t;
	for(i=n;1&lt;i;--i) {
		t=inf;
		x=gf(r[i]-1,pred);
		if(x)cmin(t,b[i]-a[x]);
		pred[r[i]]=r[i]-1;
		x=gf(r[i]+1,succ);
		if(x&lt;=n)cmin(t,a[x]-b[i]);
		succ[r[i]]=r[i]+1;
		ans+=t;
	}
	ans+=b[1];
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem1798</h2><pre>#include &lt;cstdio&gt;
#define N 100003
int mo;
struct node {
	int sum, add, mul, l, r;
	bool noneed() const {
		return !(add || (mul ^ 1));
	}
	void modify(const int &amp;a, const int &amp;b) {
		add = ((long long)a * add + b) % mo;
		mul = (long long)mul * a % mo;
		sum = ((long long)sum * a + b * (r - l + 1LL)) % mo;
	}
	void done() {
		add = 0;
		mul = 1;
	}
}C[N&lt;&lt;2|1];
inline int gi() {
	static int a;
	static char c;
	while (c = getchar(), c &lt; '0'); a = c - '0';
	while (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
#define ls u &lt;&lt; 1
#define rs u &lt;&lt; 1 | 1
inline int mmo(const int &amp;x) {return x &lt; mo ? x : x - mo;}
inline void pu(const int &amp;u) {
	C[u].sum = mmo(C[u&lt;&lt;1].sum + C[u&lt;&lt;1|1].sum);
}
void build(int u, int l, int r) {
	if (l ^ r) {
		build(ls, l, (l + r) &gt;&gt; 1);
		build(rs, (l + r &gt;&gt; 1) + 1, r);
		C[u] = (node) {mmo(C[ls].sum + C[rs].sum), 0, 1, l, r};
	} else C[u] = (node) {gi() % mo, 0, 1, l, r};
}
inline void pd(const int &amp;u) {
	if (C[u].noneed()) return;
	C[ls].modify(C[u].mul, C[u].add);
	C[rs].modify(C[u].mul, C[u].add);
	C[u].done();
}
void upd(int u, const int &amp;x, const int &amp;y, const int &amp;a, const int &amp;b) {
	if (x &lt;= C[u].l &amp;&amp; C[u].r &lt;= y) return C[u].modify(a, b);
	int m = C[u].l + C[u].r &gt;&gt; 1; pd(u);
	if (x &lt;= m) upd(ls, x, y, a, b);
	if (y &gt;  m) upd(rs, x, y, a, b);
	pu(u);
}
int quy(int u, const int &amp;x, const int &amp;y, int &amp;v) {
	if (x &lt;= C[u].l &amp;&amp; C[u].r &lt;= y)
	  return v = mmo(v + C[u].sum);
	int m = C[u].l + C[u].r &gt;&gt; 1; pd(u);
	if (x &lt;= m) quy(ls, x, y, v);
	if (y &gt;  m) quy(rs, x, y, v);
}
int main() {
	int n, m, opt, t, g, c; 
	//scanf(&quot;%d%d&quot;, n, mo);
	n = gi(), mo = gi();
	build(1, 1, n);
	m = gi();
	while (m--) {
		opt = gi(), t = gi(), g = gi();
		if (opt &lt; 3) (opt &amp; 1) ? upd(1, t, g, gi() % mo, 0) : upd(1, t, g, 1, gi() % mo);
		else {
			c = 0;
			quy(1, t, g, c);
			printf(&quot;%d\n&quot;, c);
		}
	}
	return 0;
}<pre><h2>Problem1798</h2><pre>#include &lt;cstdio&gt;
#define N 100003
int mo;
struct node {
	int sum, add, mul, l, r;
	bool noneed() const {
		return !(add || (mul ^ 1));
	}
	void modify(const int &amp;a, const int &amp;b) {
		add = ((long long)a * add + b) % mo;
		mul = (long long)mul * a % mo;
		sum = ((long long)sum * a + b * (r - l + 1LL)) % mo;
	}
	void done() {
		add = 0;
		mul = 1;
	}
}C[N&lt;&lt;2|1];
inline int gi() {
	static int a;
	static char c;
	while (c = getchar(), c &lt; '0'); a = c - '0';
	while (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
#define ls u &lt;&lt; 1
#define rs u &lt;&lt; 1 | 1
inline int mmo(const int &amp;x) {return x &lt; mo ? x : x - mo;}
inline void pu(const int &amp;u) {
	C[u].sum = mmo(C[u&lt;&lt;1].sum + C[u&lt;&lt;1|1].sum);
}
void build(int u, int l, int r) {
	if (l ^ r) {
		build(ls, l, (l + r) &gt;&gt; 1);
		build(rs, (l + r &gt;&gt; 1) + 1, r);
		C[u] = (node) {mmo(C[ls].sum + C[rs].sum), 0, 1, l, r};
	} else C[u] = (node) {gi() % mo, 0, 1, l, r};
}
inline void pd(const int &amp;u) {
	if (C[u].noneed()) return;
	C[ls].modify(C[u].mul, C[u].add);
	C[rs].modify(C[u].mul, C[u].add);
	C[u].done();
}
void upd(int u, const int &amp;x, const int &amp;y, const int &amp;a, const int &amp;b) {
	if (x &lt;= C[u].l &amp;&amp; C[u].r &lt;= y) return C[u].modify(a, b);
	int m = C[u].l + C[u].r &gt;&gt; 1; pd(u);
	if (x &lt;= m) upd(ls, x, y, a, b);
	if (y &gt;  m) upd(rs, x, y, a, b);
	pu(u);
}
int quy(int u, const int &amp;x, const int &amp;y, int &amp;v) {
	if (x &lt;= C[u].l &amp;&amp; C[u].r &lt;= y)
	  return v = mmo(v + C[u].sum);
	int m = C[u].l + C[u].r &gt;&gt; 1; pd(u);
	if (x &lt;= m) quy(ls, x, y, v);
	if (y &gt;  m) quy(rs, x, y, v);
}
int main() {
	int n, m, opt, t, g, c; 
	n = gi(), mo = gi();
	build(1, 1, n);
	m = gi();
	while (m--) {
		opt = gi(), t = gi(), g = gi();
		if (opt &lt; 3) (opt &amp; 1) ? upd(1, t, g, gi() % mo, 0) : upd(1, t, g, 1, gi() % mo);
		else {
			c = 0;
			quy(1, t, g, c);
			printf(&quot;%d\n&quot;, c);
		}
	}
	return 0;
}<pre><h2>Problem1801</h2><pre>#include &lt;cstdio&gt;
#define mod 9999973LL
#define ll long long
#define add(a) (f[i][j][k]=(f[i][j][k]+(a)%mod)%mod)
ll f[105][105][105];
int main() {
	int n,m,i,j,k,ans=0;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	f[0][0][0]=1;
	for(i=1;i&lt;=n;++i)
	for(j=0;j&lt;=m;++j)
	for(k=0;k&lt;=m-j;++k) {
		f[i][j][k]=f[i-1][j][k];
		(k)?add(f[i-1][j+1][k-1]*(j+1)),add(f[i-1][j][k-1]*j*(m-k-j+1)):1;
		(j)?add(f[i-1][j-1][k]*(m-k-j+1)):1;
		(1&lt;k)?add(f[i-1][j+2][k-2]*(j+2)*(j+1)/2):1;
		(1&lt;j)?add(f[i-1][j-2][k]*(m-j-k+2)*(m-j-k+1)/2):1;
	}
	for(j=0;j&lt;=m;++j) for(k=0;k&lt;=m-j;++k)
	ans=(ans+f[n][j][k])%mod;
	return printf(&quot;%d\n&quot;,ans),0;
}
<pre><h2>Problem1821</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'-');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
struct pip{int u,v,w;}e[500000];
int x[1002],y[1002],f[1002];
bool operator &lt; (const pip&amp;a,const pip&amp;b){return a.w&lt;b.w;}
inline int gf(int u) {
	register int r;
	for(r=u;f[r]^r;r=f[r]);
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
#define p2(a) ((a)*(a))
int main() {
	register int n=geti(),k=geti(),i,j;
	pip*en=e,*st=e;
	for(i=0;i&lt;n;++i)x[i]=geti(),y[i]=geti(),f[i]=i;
	for(i=1;i&lt;n;++i)for(j=0;j&lt;i;++j) {
			en-&gt;u=i;en-&gt;v=j;
			en-&gt;w=p2(x[i]-x[j])+p2(y[i]-y[j]);
			++en;
		}
	std::sort(e,en);
	for(;st&lt;en;++st)
		if((i=gf(st-&gt;u))^(j=gf(st-&gt;v))) {
			if(k^n)--n,f[i]=j;
			else break;
		}
	printf(&quot;%.2lf\n&quot;,sqrt(st-&gt;w));
	return 0;
}
<pre><h2>Problem1833</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

typedef long long ll;

#define debug(...) // fprintf(stderr, __VA_ARGS__)

ll f[15][10][10], p[15];

void init() {
  p[0] = 1;
  for (int i = 1; i &lt; 15; ++i) {
    p[i] = p[i - 1] * 10;
  }

  for (int i = 0; i &lt; 10; ++i) {
    f[1][i][i] = 1;
  }
  for (int i = 2; i &lt; 15; ++i) {
    for (int j = 0; j &lt; 10; ++j) {
      for (int o = 0; o &lt; 10; ++o) {
        f[i][o][o] += p[i - 2];
        for (int k = 0; k &lt; 10; ++k) {
          f[i][j][o] += f[i - 1][k][o];
        }
        debug(&quot;%d %d :%lld\n&quot;, i, o, f[i][o][o]);
      }
    }
  }
}

ll res[10];
void gao(ll x, int sign) {
  static int dig[15], len;
  len = 0;
  ll tx = x;
  while (tx) {
    dig[++len] = tx % 10;
    tx /= 10;
  }
  for (int i = 1; i &lt; len; ++i) {
    for (int j = 1; j &lt; 10; ++j) {
      for (int k = 0; k &lt; 10; ++k) {
        res[k] += f[i][j][k] * sign;
      }
    }
  }
  for (int step = 1; step &lt;= len; ++step) {
    for (int i = step &lt; len ? 0 : 1; i &lt; dig[step]; ++i) {
      for (int j = 0; j &lt; 10; ++j) {
        res[j] += f[step][i][j] * sign;
      }
    }
    res[dig[step]] += (x % p[step - 1] + 1) * sign;
  }
}

int main() {
  ll a, b;
  scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b);

  init();
  gao(b, 1);
  gao(a - 1, -1);
  for (int i = 0; i &lt; 10; ++i) {
    printf(&quot;%lld%c&quot;, res[i], &quot; \n&quot;[i == 9]);
  }
  return 0;
}<pre><h2>Problem1834</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

#define inf 0x3f3f3f3f
typedef int edge[400003], vert[1003];

edge to, nt, c, w;
vert hd, la, d, dt;
int n, m, tote, k;

void adde(int x, int y, int z, int v) {
	to[tote] = y; nt[tote] = hd[x]; 
	c[tote] = z; w[tote] = v;
	hd[x] = tote++;
}

int dfs(int u, int flow) {
	if (u == n || !flow) return flow;
	int ret = 0, tmp;
	for (int &amp;i = la[u], v; ~i; i = nt[i]) 
	if (0 &lt; c[i] &amp;&amp; d[v = to[i]] + 1 == d[u]) {
		tmp = dfs(v, min(flow, c[i]));
		ret += tmp, flow -= tmp;
		c[i] -= tmp, c[i^1] += tmp;
		if (!flow || d[1] &gt;= n) return ret;
	}
	la[u] = hd[u];
	if (!(--dt[d[u]])) d[1] = n;
	++dt[++d[u]];
	return ret;
}

int SAP() {
	for (int i = 1; i &lt;= n; ++i) la[i] = hd[i];
	int ans = 0; d[0] = n;
	while (d[1] &lt; n) ans += dfs(1, inf);
	return ans;
}

vert from, fromedge;
bool inq[1003];

bool SPFA() {
	static queue&lt;int&gt; q;
	static int i, u, dis, v;
	memset(d, 63, sizeof d);
	d[0] = 0;
	q.push(0);
	while (!q.empty()) {
		u = q.front();
		q.pop();
		dis = d[u];
		inq[u] = false;
		for (i = hd[u]; i; i = nt[i]) 
			if (c[i] &gt; 0 &amp;&amp; d[v = to[i]] &gt; dis + w[i]) {
				d[v] = dis + w[i];
				from[v] = u;
				fromedge[v] = i;
				if (!inq[v]) inq[v] = 1, q.push(v);
			}
	}
	return d[n] &lt; inf;
}

int mcf() {
	static int f, p, ans;
	f = inf, p = n;
	for (; p; p = from[p])
		f = min(f, c[fromedge[p]]);
	for (ans = 0, p = n; p; p = from[p]) {
		ans += f * w[fromedge[p]];
		c[fromedge[p]] -= f;
		c[fromedge[p]^1] += f;
	}
	return ans;
}

int expand() {
	memset(hd, -1, sizeof hd);
	//puts(&quot;&quot;);
	int u, v, t, i, ret;
	for (i = tote - 1; ~i; i -= 2) {
		u = to[i], v = to[i^1];
		if (c[i^1] &gt; 0) {
			adde(u, v, c[i^1], 0);
			adde(v, u, c[i], 0);
		}
		adde(u, v, inf, w[i^1]);
		adde(v, u, 0, -w[i^1]);
	//	printf(&quot;%3d -&gt; %3d c = %3d w = %3d\n&quot;, u, v, c[i^1], w[i^1]);
	}
	adde(0, 1, k, 0);
	adde(1, 0, 0, 0);
	for (ret = 0; SPFA();) ret += mcf();
	return ret;
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	//freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	memset(hd, -1, sizeof hd);
	for (int x, y, z, v; m; --m) {
		scanf(&quot;%d%d%d%d&quot;, &amp;x, &amp;y, &amp;z, &amp;v);
		adde(x, y, z, v);
		adde(y, x, 0, 0);
	}
	printf(&quot;%d &quot;, SAP());
	printf(&quot;%d\n&quot;, expand());
	return 0;
}
<pre><h2>Problem1853</h2><pre>#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int MaxN = 10001;
typedef long long i64;
i64 gcd(i64 a, i64 b) {
	for (static i64 t; b; t = b, b = a % b, a = t);
	return a;
}
int  n, m;
bool vis[MaxN];
i64 l, r, ans, a[MaxN], b[MaxN];
void pre(i64 x) {
	if (x &gt; r) return;
	a[++m] = x;
	pre((x &lt;&lt; 3) + (x &lt;&lt; 1) + 6);
	pre((x &lt;&lt; 3) + (x &lt;&lt; 1) + 8);
}
void dfs(int x, int y, i64 z) {
	if (x &gt; n) {
		if (y &amp; 1) ans += r / z - (l - 1) / z;
		else if (y) ans -= r / z - (l - 1) / z;
		return;
	}
	dfs(x + 1, y, z);
	i64 t = z / gcd(b[x], z);
	if ((double)b[x] * t &lt;= r)
	  dfs(x + 1, y + 1, b[x] * t);
}
int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r);
	pre(6), pre(8);
	std::sort(a + 1, a + m + 1);
	for (int i = 1; i &lt;= m; ++i)
	  if (!vis[i]) {
		  b[++n] = a[i];
		  //printf(&quot;%lld\n&quot;, a[i]);
		  for (int j = i + 1; j &lt;= m; ++j)
			if (a[j] % a[i] == 0)
			  vis[j] = true;
	  }
	for (int i = 1, j = n; i &lt; j; ++i, --j)
	  std::swap(b[i], b[j]);
	//printf(&quot;%.3lf\n&quot;, (double)clock() / CLOCKS_PER_SEC);
	dfs(1, 0, 1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem1854</h2><pre>#include &lt;cstdio&gt;
inline int gi() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define M 10000
#define N 1000000
int vis[N],link[N],_vis;
struct edge{int to;edge*nt;}medge[N&lt;&lt;1],*hd[M],*cedge=medge;
inline void adde(int a,int b){cedge-&gt;to=b,cedge-&gt;nt=hd[a],hd[a]=cedge++;}
bool dfs(int u) {
	int v;
	for(edge*it=hd[u];it;it=it-&gt;nt)
		if(vis[v=it-&gt;to]^_vis) {
			vis[v]=_vis;
			if(!(~link[v])||dfs(link[v]))
				return link[v]=u,true;
		}return false;
}
int main() {
	register int n=gi();
	while(n--) adde(gi()-1,n),adde(gi()-1,n),link[n]=-1;
	for(n=0;n&lt;M;++n) if(++_vis,!dfs(n))break;
	printf(&quot;%d\n&quot;,n);
	return 0;
}
<pre><h2>Problem1855</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 2005
int ap,bp,as,bs,dp[N][N],q[N];
inline void cmax(int&amp;a,const int&amp;b){if(a&lt;b)a=b;}
/*
  I:nothing
  dp[i][j]=dp[i-1][j]
  II:selling
  dp[i][j]=max{dp[i-w-1][k]+(k-j)*bp[i]|k&lt;=max(j+bs[i],mp)}
  III:buying
  dp[i][j]=max{dp[i-w-1][k]-(j-k)*ap[i]|k&gt;=j-as[i]}
 */
int main() {
	int n=gi(),mp=gi(),w=gi();
	register int i,j,*l,*r;
	memset(dp,-63,sizeof dp);
	dp[0][0]=0;
	for(i=1;i&lt;=n;++i) {
		ap=gi(),bp=gi(),as=gi(),bs=gi();
		for(j=0;j&lt;=as;++j)dp[i][j]=-j*ap;
		for(j=0;j&lt;=mp;++j)cmax(dp[i][j],dp[i-1][j]);
		if(w&lt;i) {
			l=r=q;
			for(j=mp;~j;--j) {
				while(l&lt;r&amp;&amp;*l&gt;j+bs)++l;
				while(l&lt;r&amp;&amp;dp[i-w-1][j]+j*bp&gt;=dp[i-w-1][*(r-1)]+*(r-1)*bp)--r;
				*r++=j;cmax(dp[i][j],dp[i-w-1][*l]+(*l-j)*bp);
			}
			l=r=q;
			for(j=0;j&lt;=mp;++j) {
				while(l&lt;r&amp;&amp;*l&lt;j-as)++l;
				while(l&lt;r&amp;&amp;dp[i-w-1][j]+j*ap&gt;=dp[i-w-1][*(r-1)]+*(r-1)*ap)--r;
				*r++=j;cmax(dp[i][j],dp[i-w-1][*l]-(j-*l)*ap);
			}
		}
	}
	int ans=0;
	for(i=0;i&lt;=mp;++i)cmax(ans,dp[n][i]);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
<pre><h2>Problem1856</h2><pre>#include &lt;cstdio&gt;

int main() {
	static int n, m, ans, mod(20100403), fac[2000005], inv[2000005], fac_inv[2000005];
	fac[0] = fac_inv[0] = 1;
	fac[1] = inv[1] = fac_inv[1] = 1;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (register int i = 2, t = n + m + 1; i &lt; t; ++i) {
		fac[i] = 1ll * fac[i - 1] * i % mod;
		inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
		fac_inv[i] = 1ll * fac_inv[i - 1] * inv[i] % mod;
	}
	ans = 1ll * fac[n + m] * fac_inv[n] % mod * fac_inv[m] % mod - 1ll * fac[n + m] * fac_inv[n + 1] % mod * fac_inv[m - 1] % mod;
	if (ans &lt; 0) ans += mod;
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem1857</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
double p, q, r;
pair&lt;double, double&gt;pp[4];
const double eps = 1e-9;

inline double sqr(const double &amp;a) {
	return a * a;
}
inline double dist(const pair&lt;double, double&gt; &amp;a, const pair&lt;double, double&gt; &amp;b) {
	return sqrt(sqr(a.first - b.first) + sqr(a.second - b.second));
}
inline pair&lt;double, double&gt; cal(const int &amp;i, const int &amp;j, const double &amp;r) {
	return make_pair(pp[i].first + (pp[j].first - pp[i].first) * r, pp[i].second + (pp[j].second - pp[i].second) * r);
}
inline double g(const pair&lt;double, double&gt; &amp;x, const pair&lt;double, double&gt; &amp;y) {
	return dist(pp[0], x) / p + dist(x, y) / r + dist(y, pp[3]) / q;
}
inline double solve(const pair&lt;double, double&gt; &amp;x) {
	static double L, R, seg, m1, m2;
	static pair&lt;double, double&gt; t1, t2;
	for (L = 0.0, R = 1.0; L + eps &lt; R; ) {
		seg = (R - L) / 3.0;
		m1 = L + seg, m2 = R - seg;
		t1 = cal(2, 3, m1), t2 = cal(2, 3, m2);
		if (g(x, t1) &lt; g(x, t2)) R = m2; else L = m1;
	}
	return g(x, cal(2, 3, L));
}
int main() {
	for (int i = 0, t1, t2; i &lt; 4; ++i) {
		scanf(&quot;%d%d&quot;, &amp;t1, &amp;t2);
		pp[i] = make_pair((double)t1, (double)t2);
	}
	int t;
	scanf(&quot;%d&quot;, &amp;t); p = t;
	scanf(&quot;%d&quot;, &amp;t); q = t;
	scanf(&quot;%d&quot;, &amp;t); r = t;
	double L = 0.0, R = 1.0, seg, m1, m2;
	pair&lt;double, double&gt; t1, t2;
	while (L + eps &lt; R) {
		seg = (R - L) / 3.0;
		m1 = L + seg, m2 = R - seg;
		t1 = cal(0, 1, m1), t2 = cal(0, 1, m2);
		if (solve(t1) &lt; solve(t2)) R = m2; else L = m1;
	}
	printf(&quot;%.2lf\n&quot;, solve(cal(0, 1, L)));
	return 0;
}
<pre><h2>Problem1857</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
double p, q, r;
pair&lt;double, double&gt;pp[4];
const double eps = 1e-5;

inline double sqr(const double &amp;a) {
	return a * a;
}
inline double dist(const pair&lt;double, double&gt; &amp;a, const pair&lt;double, double&gt; &amp;b) {
	return sqrt(sqr(a.first - b.first) + sqr(a.second - b.second));
}
inline pair&lt;double, double&gt; cal(const int &amp;i, const int &amp;j, const double &amp;r) {
	return make_pair(pp[i].first + (pp[j].first - pp[i].first) * r, pp[i].second + (pp[j].second - pp[i].second) * r);
}
inline double g(const pair&lt;double, double&gt; &amp;x, const pair&lt;double, double&gt; &amp;y) {
	return dist(pp[0], x) / p + dist(x, y) / r + dist(y, pp[3]) / q;
}
inline double solve(const pair&lt;double, double&gt; &amp;x) {
	static double L, R, seg, m1, m2;
	static pair&lt;double, double&gt; t1, t2;
	for (L = 0.0, R = 1.0; L + eps &lt; R; ) {
		seg = (R - L) / 3.0;
		m1 = L + seg, m2 = R - seg;
		t1 = cal(2, 3, m1), t2 = cal(2, 3, m2);
		if (g(x, t1) &lt; g(x, t2)) R = m2; else L = m1;
	}
	return g(x, cal(2, 3, L));
}
int main() {
	for (int i = 0, t1, t2; i &lt; 4; ++i) {
		scanf(&quot;%d%d&quot;, &amp;t1, &amp;t2);
		pp[i] = make_pair((double)t1, (double)t2);
	}
	int t;
	scanf(&quot;%d&quot;, &amp;t); p = t;
	scanf(&quot;%d&quot;, &amp;t); q = t;
	scanf(&quot;%d&quot;, &amp;t); r = t;
	double L = 0.0, R = 1.0, seg, m1, m2;
	pair&lt;double, double&gt; t1, t2;
	while (L + eps &lt; R) {
		seg = (R - L) / 3.0;
		m1 = L + seg, m2 = R - seg;
		t1 = cal(0, 1, m1), t2 = cal(0, 1, m2);
		if (solve(t1) &lt; solve(t2)) R = m2; else L = m1;
	}
	printf(&quot;%.2lf\n&quot;, solve(cal(0, 1, L)));
	return 0;
}
<pre><h2>Problem1857</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
double p, q, r;
pair&lt;double, double&gt;pp[4];
const double eps = 1e-5;
inline double sqr(const double &amp;a) {
	return a * a;
}
inline double dist(const pair&lt;double, double&gt; &amp;a, const pair&lt;double, double&gt; &amp;b) {
	return sqrt(sqr(a.first - b.first) + sqr(a.second - b.second));
}
inline pair&lt;double, double&gt; cal(const int &amp;i, const int &amp;j, const double &amp;r) {
	return pair&lt;double, double&gt;(pp[i].first + (pp[j].first - pp[i].first) * r, pp[i].second + (pp[j].second - pp[i].second) * r);
}
inline double g(const pair&lt;double, double&gt; &amp;x, const pair&lt;double, double&gt; &amp;y) {
	return dist(pp[0], x) / p + dist(x, y) / r + dist(y, pp[3]) / q;
}
inline double solve(const pair&lt;double, double&gt; &amp;x) {
	static double L, R, seg, m1, m2;
	static pair&lt;double, double&gt; t1, t2;
	for (L = 0.0, R = 1.0; L + eps &lt; R; ) {
		seg = (R - L) / 3.0;
		m1 = L + seg, m2 = R - seg;
		t1 = cal(2, 3, m1), t2 = cal(2, 3, m2);
		if (g(x, t1) &lt; g(x, t2)) R = m2; else L = m1;
	}
	return g(x, cal(2, 3, L));
}
int main() {
	for (int i = 0, t1, t2; i &lt; 4; ++i) {
		scanf(&quot;%d%d&quot;, &amp;t1, &amp;t2);
		pp[i] = make_pair((double)t1, (double)t2);
	}
	int t;
	scanf(&quot;%d&quot;, &amp;t); p = t;
	scanf(&quot;%d&quot;, &amp;t); q = t;
	scanf(&quot;%d&quot;, &amp;t); r = t;
	double L = 0.0, R = 1.0, seg, m1, m2;
	pair&lt;double, double&gt; t1, t2;
	while (L + eps &lt; R) {
		seg = (R - L) / 3.0;
		m1 = L + seg, m2 = R - seg;
		t1 = cal(0, 1, m1), t2 = cal(0, 1, m2);
		if (solve(t1) &lt; solve(t2)) R = m2; else L = m1;
	}
	printf(&quot;%.2lf\n&quot;, solve(cal(0, 1, L)));
	return 0;
}
<pre><h2>Problem1858</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline char gc() {
	static char buf[1&lt;&lt;16], *s = buf, *e = buf;
	if (s == e) e = (s = buf) + fread(buf, 1, 1&lt;&lt;16, stdin);
	return *s++;
}
inline int gi() {
	static int a; static char c;
	while ((c = gc()) &lt; '0'); a = c - '0';
	while ('-' &lt; (c = gc())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
int C[400003], ans, cur;
#define UP(u) ((C[u&lt;&lt;1]==C[u&lt;&lt;1|1]&amp;&amp;C[u]==-1)?C[u]=C[u&lt;&lt;1]:1)
#define DOWN(u) ((~C[u])?C[u&lt;&lt;1]=C[u&lt;&lt;1|1]=C[u],C[u]=-1:1)
void update(int u, int l, int r, const int &amp;x, const int &amp;y, const int &amp;opt) {
	if (x &lt;= l &amp;&amp; r &lt;= y) {
		if (opt &lt; 2) return (void)(C[u] = opt);
		else if (~C[u]) return (void)(C[u] ^= 1);
	}DOWN(u);
	int m = l + r &gt;&gt; 1;
	if (x &lt;= m) update(u&lt;&lt;1, l, m, x, y, opt);
	if (y &gt;  m) update(u&lt;&lt;1|1, m + 1, r, x, y, opt);
}
int qsum(int u, int l, int r, const int &amp;x, const int &amp;y) {
	if (x &lt;= l &amp;&amp; r &lt;= y)
		if (~C[u]) return C[u] ? r - l + 1 : 0;
	DOWN(u);
	int m = l + r &gt;&gt; 1, ret = 0;
	if (x &lt;= m) ret += qsum(u&lt;&lt;1, l, m, x, y);
	if (y &gt;  m) ret += qsum(u&lt;&lt;1|1, m + 1, r, x, y);
	return ret;
}
void q(int u, int l, int r, const int &amp;x, const int &amp;y) {
	if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; (~C[u])) {
		if (C[u]) cur += r - l + 1;
		else cur = 0;
		if (ans &lt; cur) ans = cur;
		return;
	}DOWN(u);
	int m = l + r &gt;&gt; 1;
	if (x &lt;= m) q(u&lt;&lt;1, l, m, x, y);
	if (y &gt; m) q(u&lt;&lt;1|1, m + 1, r, x, y);
}
int main() {
	int n, m, l, r, opt;
	n = gi(), m = gi(); r = n - 1;
	for (l = 0; l &lt; n; ++l) update(1, 0, r, l, l, gi());
	--n;
	while (m--) {
		opt = gi(), l = gi(), r = gi();
		if (opt &lt; 3) update(1, 0, n, l, r, opt);
		else if (opt &lt; 4) printf(&quot;%d\n&quot;, qsum(1, 0, n, l, r));
		else {
			ans = cur = 0;
			q(1, 0, n, l, r);
			printf(&quot;%d\n&quot;, ans);
		}
	}
	return 0;
}<pre><h2>Problem1878</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 50005, M = 200005, MaxNum = 1000005;
struct query {
	int l, r, id;
}q[M];
bool operator &lt; (const query&amp;a, const query&amp;b) {
	return a.r &lt; b.r;
}
int last[MaxNum], pre[MaxNum], C[N], n, m, ans[M];
int sum(int x) {
	static int r;
	for (r = 0; x; x -= x &amp; -x)
		r += C[x];
	return r;
}
void add(int x, int v) {
	for (; x &lt;= n; x += x &amp; -x)
		C[x] += v;
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1, a; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a);
		pre[i] = last[a];
		last[a] = i;
	}
	scanf(&quot;%d&quot;, &amp;m);
	for (int i = 1, l, r; i &lt;= m; ++ i) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		q[i] = (query){l, r, i};
	}
	std::sort(q + 1, q + m + 1);
	for (int i = 1,j = 1; i &lt;= n; ++i) {
		if (pre[i]) add(pre[i], -1);
		add(i, 1);
		while (q[j].r == i) {
			ans[q[j].id] = sum(q[j].r) - sum(q[j].l - 1);
			if (++j &gt; m) i = n;
		}
	}
	for (int i = 1; i &lt;= m; ++i)
		printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}
<pre><h2>Problem1879</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int mod = 1e6 + 3;
const int MaxN = 16, MaxL = 55, MaxS = (1 &lt;&lt; 16) | 1;

int f[MaxL][MaxS], g[MaxL][26], cnt[MaxS];
char s[MaxN][MaxL];

#define rep(i, l, r) for (i = l; i &lt; r; ++i)

inline void inc(int &amp;a, const int &amp;b) {
	a += b;
	if (a &gt;= mod) a -= mod;
	//printf(&quot;%d\n&quot;, a);
}

int main() {
	int _, n, K, len, i, j, k, all, ans;
	rep(i, 1, MaxS) cnt[i] = cnt[i &amp; (i - 1)] + 1;
	scanf(&quot;%d&quot;, &amp;_);
	while (_--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;K);
		rep(i, 0, n) scanf(&quot;%s&quot;, s[i]);
		len = strlen(s[0]);
		rep(i, 0, len) rep(j, 0, n) {
			if (s[j][i] ^ '?')
			  g[i][s[j][i] - 'a'] ^= 1 &lt;&lt; j;
			else
			  rep(k, 0, 26) g[i][k] ^= 1 &lt;&lt; j;
		}
		all = 1 &lt;&lt; n;
		f[0][all - 1] = 1;
		rep(i, 0, len) rep(j, 0, all) if (f[i][j]) 
			rep(k, 0, 26) inc(f[i + 1][j &amp; g[i][k]], f[i][j]);
		ans = 0;
		rep(j, 0, all) if (cnt[j] == K) inc(ans, f[len][j]);
		printf(&quot;%d\n&quot;, ans);
		if (_) {
			memset(f, 0, sizeof f);
			memset(g, 0, sizeof g);
		}
	}
	return 0;
}<pre><h2>Problem1911</h2><pre>#include &lt;cstdio&gt;
inline int gi() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
typedef long long i64;
const int MaxN=1000005;
i64 s[MaxN],dp[MaxN],y[MaxN];
int que[MaxN];
#define f(x) a*(x)*(x)+b*(x)+c
inline long double gk(int i,int j) {
	return (long double)(y[i]-y[j])/(long double)(s[i]-s[j]);
}
int main() {
	register int n=gi(),a=gi(),b=gi(),c=gi(),i;
	int *l=que,*r=que; *r=0;
	for(i=1;i&lt;=n;++i) {
		s[i]=s[i-1]+gi();
		while(l&lt;r&amp;&amp;gk(*l,l[1])&gt;2*a*s[i])++l;
		dp[i]=dp[*l]+f(s[i]-s[*l]);
		y[i]=dp[i]+a*s[i]*s[i]-b*s[i];
		while(l&lt;r&amp;&amp;gk(r[-1],*r)&lt;gk(*r,i))--r;
		*++r=i;
	}
	printf(&quot;%lld\n&quot;,dp[n]);
	return 0;
}<pre><h2>Problem1923</h2><pre>#include &lt;cstdio&gt;
#include &lt;bitset&gt;
using namespace std;
inline int rd() {
	register char c;
	while(c=getchar(),c&lt;'0');
	return c-'0';
}
bitset&lt;1002&gt;a[2003];
int n,m;
inline int guass() {
	int r=0;
	for(register int i=0,j;i&lt;n;++i) {
		for(j=i;j&lt;m&amp;&amp;!a[j][i];++j);
		if(j==m)return -1;
		if(r&lt;j)r=j;
		if(i^j)swap(a[i],a[j]);
		for(j=0;j&lt;m;++j)
			if((i^j)&amp;&amp;a[j][i])a[j]^=a[i];
	}return r;
}
int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(register int i=0,j;i&lt;m;++i)
		for(j=0;j&lt;=n;++j)
			a[i][j]=rd();
	int k=guass();
	if(~k) {
		printf(&quot;%d\n&quot;,k+1);
		for(register int i=0;i&lt;n;++i)
			puts(a[i][n]?&quot;?y7M#&quot;:&quot;Earth&quot;);
	}else puts(&quot;Cannot Determine&quot;);
	return 0;
}<pre><h2>Problem1951</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

typedef long long i64;
const i64 mo = 999911659, m2 = 999911658;
//mo - 1 = 999911658
// = 2 x 3 x 4679 x 35617

inline i64 pw(i64 a, i64 b, i64 c) {
	static i64 r;
	for (r = 1; b; a = (i64)a * a % c, b &gt;&gt;=1)
		if (b &amp; 1) r = (i64)a * r % c;
	return r;
}

void exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y, i64 &amp;g) {
	if (!b) return (void)(x = 1, y = 0, g = a);
	exgcd(b, a % b, y, x, g);
	y -= a / b * x;
}

i64 pr[5] = {2, 3, 4679, 35617, 0};
i64 inv[5], fac[5][400000];

inline void init() {
	for (i64 i = 0, j, y, g; i &lt; 4; ++i) {
		exgcd(m2 / pr[i], pr[i], inv[i], y, g);
		for (fac[i][0] = j = 1; j &lt; pr[i]; ++j)
			fac[i][j] = fac[i][j - 1] * j % pr[i];
	}
}

i64 Lucas(i64 n, i64 m, i64 mod, i64 *f) {
	static i64 ret, nn, mm;
	for (ret = 1; n &amp;&amp; m; n /= mod, m /= mod) {
		nn = n % mod, mm = m % mod;
		if (nn &lt; mm) return 0;
		ret = ret * f[nn] % mod * pw((i64)(f[mm] * f[nn - mm] % mod), mod - 2, mod) % mod;
	}
	return ret;
}

inline i64 C(i64 n, i64 m) {
	static i64 t, i, ret, M;
	for (ret = i = 0; i &lt; 4; ++i) {
		t = Lucas(n, m, pr[i], fac[i]);
		M = m2 / pr[i];
		ret = (ret + M * inv[i] * t) % m2;
	}
	if (ret &lt; 0) ret += m2;
	return ret;
}

int main() {
	i64 N, G, i, sum = 0, end;
	scanf(&quot;%lld%lld&quot;, &amp;N, &amp;G);
	end = sqrt(N) + 0.5;
	init();
	for (i = 1; i &lt;= end; ++i)
		if (!(N % i)) {
			sum += C(N, i);
			if (sum &gt;= m2) sum -= m2;
			if (N / i != i) sum += C(N, N / i);
			if (sum &gt;= m2) sum -= m2;
		}
	printf(&quot;%lld\n&quot;, pw(G, sum ? sum : m2, mo));
	return 0;
}<pre><h2>Problem1966</h2><pre>#include &lt;cstdio&gt;
inline char gc() {
	static char b[1&lt;&lt;16], *s=b, *e=b;
	if (s &gt;= e) e = (s = b) + fread(b, 1, 1&lt;&lt;16, stdin);
	return (s &gt;= e) ? 0 : *s++;
}
inline void gi(int &amp;a) {
	char c;
	while (c = gc(), c &lt; '0'); a = c - '0';
	while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}
#define nsc(c) ((c &lt; 'A' || 'Z' &lt; c) &amp;&amp; (c ^ '*') &amp;&amp; (c ^ '?'))
inline void gs(char *s, int &amp;len) {
	for (len = 0; *s = gc(), nsc(*s); );
	for (*(s + 1) = *s, *s = 0, ++s, len = 1; *++s = gc(), !nsc(*s); ++len);
}
char dp[1003][503], a[1003], b[503];
int main() {
	//freopen(&quot;1966.in&quot;, &quot;r&quot;, stdin);
	int n, m, _, __ = 0, i, j;
	gs(a, n);
	gi(_);
	if (a[1] == '*') dp[1][0] = 1;
	dp[0][0] = 1;
	while (_--) {
		gs(b, m);
		for (i = 1; i &lt;= n; ++i)
			for (j = 1; j &lt;= m; ++j)
				if (a[i] == '*') dp[i][j] = dp[i - 1][j - 1] | dp[i][j - 1] | dp[i - 1][j];
				else if (!(a[i] ^ b[j]) || !(a[i] ^ '?')) dp[i][j] = dp[i - 1][j - 1];
				else dp[i][j] = 0;
		__ += !dp[n][m];
	}
	printf(&quot;%d\n&quot;, __);
}<pre><h2>Problem1968</h2><pre>#include &lt;cstdio&gt;
int n, i, j, k, ans;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 1; i &lt;= n; i = j + 1) {
		k = n / i;
		j = n / k;
		ans += k * (j - i + 1);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem2001</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int MaxN(20007), MaxM(50007), MaxL(16), inf(0x7fffffff), MaxQ(MaxM);

struct edge {
	int u, v, w, id;
	edge() {}
	edge(int u, int v, int w, int id) :
		u(u), v(v), w(w), id(id) {}
} e[MaxL][MaxM], d[MaxM], t[MaxM];

bool operator &lt; (const edge &amp;a, const edge &amp;b) {
	return a.w &lt; b.w;
}

struct ask {
	int k, d;
} quer[MaxQ];

int f[MaxN], size[MaxN], weight[MaxM], idx[MaxM];
long long ans[MaxQ];

inline int gf(int u) {
	while (f[u] ^ u) u = f[u] = f[f[u]];
	return u;
	//return u == f[u] ? u : f[u] = gf(f[u]);
}

inline void merge(int u, int v) {
	u = gf(u), v = gf(v);
	if (size[u] &lt; size[v]) std::swap(u, v);
	f[v] = u, size[u] += size[v];
}

inline void reset(const int &amp;n, const edge *e) {
	for (register int i = 0; i &lt; n; ++i) {
		f[e[i].u] = e[i].u;
		f[e[i].v] = e[i].v;
		size[e[i].u] = size[e[i].v] = 1;
	}
}


inline long long contraction(int &amp;n) { /// delete the necessary edges
	static int tmp;
	static long long ret;
	
	tmp = 0;
	std::sort(d, d + n);
	for (register int i = 0; i &lt; n; ++i)
		if (gf(d[i].u) != gf(d[i].v)) {
			merge(d[i].u, d[i].v);
			t[tmp++] = d[i];
		}
	
	reset(tmp, t);
	ret = 0LL;
	for (register int i = 0; i &lt; tmp; ++i)
		if (t[i].w != -inf &amp;&amp; gf(t[i].u) != gf(t[i].v)) {
			merge(t[i].u, t[i].v);
			ret += t[i].w;
		}
	
	tmp = 0;
	for (register int i = 0; i &lt; n; ++i)
		if (gf(d[i].u) != gf(d[i].v)) {
			t[tmp] = edge(gf(d[i].u), gf(d[i].v), d[i].w, d[i].id);
			idx[d[i].id] = tmp++;
		}
	
	reset(n, d);
	n = tmp;
	for (register int i = 0; i &lt; n; ++i)
		d[i] = t[i];
	return ret;
}

inline void redoction(int &amp;n) { /// delete the unnecessary edges
	
	static int tmp;
	tmp = 0;
	std::sort(d, d + n);

	for (register int i = 0; i &lt; n; ++i)
		if (gf(d[i].u) != gf(d[i].v)) {
			merge(d[i].u, d[i].v);
			t[tmp] = d[i];
			idx[d[i].id] = tmp++;
		} else if (d[i].w == inf) {
			t[tmp] = d[i];
			idx[d[i].id] = tmp++;
		}
	
	reset(n, d);
	n = tmp;
	for (register int i = 0; i &lt; n; ++i)
		d[i] = t[i];
}

inline void divide(int step, int n, int l, int r, long long v) {
	if (l == r) weight[quer[l].k] = quer[l].d;
	
	for (register int i = 0; i &lt; n; ++i) {
		e[step][i].w = weight[e[step][i].id];
		d[i] = e[step][i];
		idx[d[i].id] = i;
	}

	if (l == r) {
		long long &amp;x = ans[l] = v;
		std::sort(d, d + n);
		for (register int i = 0; i &lt; n; ++i)
			if (gf(d[i].u) != gf(d[i].v)) {
				merge(d[i].u, d[i].v);
				x += d[i].w;
			}
		return reset(n, d);
	}

	for (register int i = l; i &lt;= r; ++i)
		d[idx[quer[i].k]].w = -inf;
	v += contraction(n);

	for (register int i = l; i &lt;= r; ++i)
		d[idx[quer[i].k]].w = inf;
	redoction(n);

	/// smaller the graph
	
	for (register int i = 0; i &lt; n; ++i)
		e[step + 1][i] = d[i];

	int mid = (l + r) &gt;&gt; 1;
	
	divide(step + 1, n, l, mid, v);
	divide(step + 1, n, mid + 1, r, v);
}


int main() {
	
	int n, m, q, u, v, w;

	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);
	
	for (register int i = 1; i &lt;= n; ++i)
		f[i] = i, size[i] = 1;

	for (register int i = 0; i &lt; m; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		e[0][i] = edge(u, v, w, i);
		weight[i] = w;
	}

	for (register int i = 0; i &lt; q; ++i) {
		scanf(&quot;%d%d&quot;, &amp;quer[i].k, &amp;quer[i].d);
		--quer[i].k;
	}

	divide(0, m, 0, q - 1, 0);
	
	for (register int i = 0; i &lt; q; ++i)
		printf(&quot;%lld\n&quot;, ans[i]);
	
	return 0;
}<pre><h2>Problem2002</h2><pre>/* ***********************************************
Author        :kuangbin
Created Time  :2013-9-4 7:41:21
File Name     :BZOJ2002弹飞绵羊.cpp
************************************************ */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
using namespace std;

const int MAXN = 200010;
int ch[MAXN][2],pre[MAXN];
int size[MAXN];
bool rt[MAXN];
void push_down(int r)
{
    
}
void push_up(int r)
{
    size[r] = size[ch[r][0]] + size[ch[r][1]] + 1;
}
void Rotate(int x)
{
    int y = pre[x], kind = ch[y][1]==x;
    ch[y][kind] = ch[x][!kind];
    pre[ch[y][kind]] = y;
    pre[x] = pre[y];
    pre[y] = x;
    ch[x][!kind] = y;
    if(rt[y])
        rt[y] = false, rt[x] = true;
    else
        ch[pre[x]][ch[pre[x]][1]==y] = x;
    push_up(y);
}
void P(int r)
{
    if(!rt[r])P(pre[r]);
    push_down(r);
}
void Splay(int r)
{
    P(r);
    while( !rt[r] )
    {
        int f = pre[r], ff = pre[f];
        if(rt[f])
            Rotate(r);
        else if( (ch[ff][1]==f)==(ch[f][1]==r) )
            Rotate(f), Rotate(r);
        else
            Rotate(r), Rotate(r);
    }
    push_up(r);
}
int Access(int x)
{
    int y = 0;
    for( ; x ; x = pre[y=x])
    {
        Splay(x);
        rt[ch[x][1]] = true, rt[ch[x][1]=y] = false;
        push_up(x);
    }
    return y;
}
int a[MAXN];
int main()
{
    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    
    int n,m;
    while(scanf(&quot;%d&quot;,&amp;n) == 1)
    {
        for(int i = 1;i &lt;= n;i++)
            scanf(&quot;%d&quot;,&amp;a[i]);
        for(int i = 0;i &lt;= n+1;i++)
        {
            pre[i] = 0;
            ch[i][0] = ch[i][1] = 0;
            rt[i] = true;
            size[i] = 1;
        }
        size[0] = 0;
        for(int i = 1;i &lt;= n;i++)
        {
            int t = i + a[i];
            if( t &gt; n+1) t = n+1;
            pre[i] = t;
        }
        int op;
        int u,v;
        scanf(&quot;%d&quot;,&amp;m);
        while(m--)
        {
            scanf(&quot;%d&quot;,&amp;op);
            if(op == 1)
            {
                scanf(&quot;%d&quot;,&amp;u);
                u++;
                Access(u);
                Splay(u);
                printf(&quot;%d\n&quot;,size[ch[u][0]]);
            }
            else
            {
                scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
                u++;
                Access(u);
                Splay(u);
                pre[ch[u][0]] = pre[u];
                pre[u] = 0;
                rt[ch[u][0]] = true;
                ch[u][0] = 0;
                push_up(u);
                int t = u + v;
                if(t &gt; n+1) t = n+1;
                pre[u] = t;
            }
        }
    }
    return 0;
}<pre><h2>Problem2002</h2><pre>#include &lt;cstdio&gt;

const int N = 2e5 + 9;
int ch[2][N], pre[N], size[N];
bool rt[N];

void update(const int &amp;u) {
	size[u] = size[ch[0][u]] + size[ch[1][u]] + 1;
}

void rot(int u) {
	int o = pre[u], d = ch[1][o] == u;
	if (ch[d][o] = ch[d^1][u]) pre[ch[d][o]] = o;
	pre[u] = pre[o]; pre[o] = u;
	ch[d^1][u] = o;
	if (rt[o]) rt[o] = false, rt[u] = true;
	else ch[o==ch[1][pre[u]]][pre[u]] = u;
	update(o), update(u);
}

void splay(int u) {
	for (int o; !rt[u]; rot(u))
		if (!rt[o = pre[u]])
			rot(((ch[1][pre[o]]==o)==(ch[1][o]==u))?o:u);
}

void access(int u) {
	static int o;
	for (o = 0; u; u = pre[o =  u]) {
		splay(u);
		rt[ch[1][u]] = true;
		rt[ch[1][u] = o] = false;
		update(u);
	}
}
int main() {
	int n, m, i, x, y;
	scanf(&quot;%d&quot;, &amp;n);
	rt[0] = true;
	rt[n + 1] = true;
	size[n + 1] = 1;
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		x += i;
		if (x &gt; n) x = n + 1;
		pre[i] = x;
		size[i] = 1;
		rt[i] = true;
	}
	scanf(&quot;%d&quot;, &amp;m);
	while (m--) {
		scanf(&quot;%d&quot;, &amp;i);
		if (i &lt; 2) {
			scanf(&quot;%d&quot;, &amp;x);
			++x;
			access(x);
			splay(x);
			printf(&quot;%d\n&quot;, size[ch[0][x]]);
		} else {
			scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
			++x;
			access(x);
			splay(x);
			pre[ch[0][x]] = pre[x];
			pre[x] = 0;
			rt[ch[0][x]] = true;
			ch[0][x] = 0;
			update(x);
			y += x;
			if (y &gt; n) y = n + 1;
			pre[x] = y;
		}
	}
	return 0;
}

<pre><h2>Problem2005</h2><pre>#include &lt;cstdio&gt;

int main() {
	int n, m, i, j;
	long long ans = 0, f[100003];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if (m &lt; n) n ^= m ^= n ^= m;
	for (i = n; i; --i) {
		f[i] = (long long)(n / i) * (m / i);
		for (j = i &lt;&lt; 1; j &lt;= n; j += i)
			f[i] -= f[j];
		ans += f[i] * (2 * i - 1);
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}
<pre><h2>Problem2005</h2><pre>#include &lt;cstdio&gt;

int main() {
	unsigned int n, m;
	register unsigned int i, j;
	register unsigned long long ans = 0;
	unsigned long long f[100003];
	scanf(&quot;%u%u&quot;, &amp;n, &amp;m);
	if (m &lt; n) n ^= m ^= n ^= m;
	for (i = n; i; --i) {
		f[i] = (long long)(n / i) * (m / i);
		for (j = i &lt;&lt; 1; j &lt;= n; j += i)
			f[i] -= f[j];
		ans += f[i] * ((i &lt;&lt; 1) - 1);
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem2006</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c,f;
	for(f=0;(c=getchar())&lt;'0';f|=c=='-');a=c-'0';
	while('-'&lt;(c=getchar()))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 500005
#define MS 10000000
int s[N],rt[N],MP[N],mcnt;
inline int g(const int&amp;x) {return lower_bound(MP+1,MP+mcnt+1,x)-MP;}
int ls[MS],rs[MS],cnt[MS],cnd;
struct node {
	int y,kth,delta;
	node(int _y,int _k,int _delta) : y(_y),kth(_k),delta(_delta){}
	bool operator &lt; (const node&amp;a) const {return delta &lt; a.delta;}
};
priority_queue&lt;node&gt;heap;
void insert(int&amp;x,int y,int l,int r,const int&amp;v) {
	x=++cnd; ls[x]=ls[y],rs[x]=rs[y],cnt[x]=cnt[y]+1;
	if(l &gt;= r) return; int m=l+r&gt;&gt;1;
	(v&lt;=m)?(insert(ls[x],ls[y],l,m,v),0):(insert(rs[x],rs[y],m+1,r,v),0);
}
inline int query(int ln,int rn,int k) {
	int l=1,r=mcnt,t,md;
	if(ln)ln=rt[ln-1];else ln=0;
	rn=rt[rn];
	while(l^r) {
		md=l+r&gt;&gt;1;
		t=cnt[ls[rn]]-cnt[ls[ln]];
		if(t&gt;=k)ln=ls[ln],rn=ls[rn],r=md;
		else k-=t,ln=rs[ln],rn=rs[rn],l=md+1;
	}return l;
}
int main() {
	int n=gi(),K=gi(),L=gi(),R=gi(),i,k,tmp,l,r;
	long long ans=0;
	node lala(0,0,0);
	MP[++mcnt]=s[0]=0;
	for(i=1;i&lt;=n;++i)MP[++mcnt]=s[i]=s[i-1]+gi();
	sort(MP+1,MP+mcnt+1);
	mcnt=unique(MP+1,MP+mcnt+1)-MP-1;
	insert(rt[0],0,1,mcnt,g(s[0]));
	for(i=1;i&lt;n;++i)insert(rt[i],rt[i-1],1,mcnt,g(s[i]));
	for(i=L;i&lt;=n;++i) {
		l=max(0,i-R),r=i-L;
		heap.push(node(i,1,s[i]-MP[query(l,r,1)]));
	}
	while(K) {
		lala=heap.top(); heap.pop();
		i = lala.y,k=lala.kth;
		ans+=lala.delta;
		--K; l=max(0,i-R),r=i-L;
		if(k&lt;r-l+1) heap.push(node(i,k+1,s[i]-MP[query(l,r,k+1)]));
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem2006</h2><pre>#include &lt;cstdio&gt;
#include &lt;queue&gt;
using namespace std;
#define N 500005
int s[N],lg[N],st[20][N];
inline int gi() {
	static int a; static char c,f;
	for(f=0;(c=getchar())&lt;'0';f|=c=='-');a=c-'0';
	while('-'&lt;(c=getchar()))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
struct node {int i,l,r,m;};
bool operator &lt; (const node&amp;a,const node&amp;b) {
	return s[a.i]-s[a.m] &lt; s[b.i]-s[b.m];
}
priority_queue&lt;node&gt;heap;
inline int ms(const int&amp;a,const int&amp;b) {return s[a]&lt;s[b]?a:b;}
inline int rmq(int i,int j) {
	int t=lg[j-i+1];
	return ms(st[t][i],st[t][j-(1&lt;&lt;t)+1]);
}
int main() {
	int n=gi(),K=gi(),L=gi(),R=gi(),i,j,k,t;
	node lala; long long ans=0;
	for(i=1;i&lt;=n;++i)s[i]=s[i-1]+gi();
	for(i=2,t=n+2;i&lt;t;++i)lg[i]=lg[i&gt;&gt;1]+1;
	for(i=0;i&lt;=n;++i)(*st)[i]=i;
	for(i=1,t=lg[n+1]+1;i&lt;t;++i)
		for(j=0,k=n-(1&lt;&lt;i)+2;j&lt;k;++j)
			st[i][j]=ms(st[i-1][j],st[i-1][j+(1&lt;&lt;i-1)]);
	for(i=L;i&lt;=n;++i) {
		j=(i-R)&lt;0?0:(i-R),k=i-L;
		heap.push((node){i,j,k,rmq(j,k)});
	}
	while(K--) {
		lala=heap.top(); heap.pop();
		i=lala.i,j=lala.l,k=lala.r,t=lala.m;
		ans+=s[i]-s[t];
		if(j^t) heap.push((node){i,j,t-1,rmq(j,t-1)});
		if(t^k) heap.push((node){i,t+1,k,rmq(t+1,k)});
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
<pre><h2>Problem2038</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int N = 50003;

struct node {int l, r, ln, id;}a[N];
int up[N], down[N], cnt[N], col[N];

int gcd(int a, int b) {
	for (static int t; b; t = a % b, a = b, b = t);
	return a;
}

bool operator &lt; (const node &amp;a, const node &amp;b) {
	return (a.ln ^ b.ln) ? (a.ln &lt; b.ln) : ((a.ln &amp; 1) ? b.r &lt; a.r : a.r &lt; b.r);
}

void giveans(int a, int b, int c) {
	if (!a) up[c] = 0, down[c] = 1;
	else {
		static int g;
		b = (long long)b * (b - 1) / 2;
		g = gcd(a, b);
		up[c] = a / g;
		down[c] = b / g;
	}
}

int main() {
	int n, m, l, r, i, rightchose = 0, tl, tr, t;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, col + i);
	t = sqrt(n + 0.5);
	for (i = 0; i &lt; m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		a[i] = (node){l, r, l / t, i};
	}
	std::sort(a, a + m);
	for (l = 1, r = 0, i = 0; i &lt; m; ++i) {
		tl = a[i].l, tr = a[i].r;
		while (r &lt; tr) {
			rightchose += cnt[col[++r]];
			++cnt[col[r]];
		}
		while (l &gt; tl) {
			rightchose += cnt[col[--l]];
			++cnt[col[l]];
		}
		while (r &gt; tr) {
			rightchose -= cnt[col[r]] - 1;
			--cnt[col[r--]];
		}
		while (l &lt; tl) {
			rightchose -= cnt[col[l]] - 1;
			--cnt[col[l++]];
		}
		//printf(&quot;%d %d %d\n&quot;, tl, tr, rightchose);
		giveans(rightchose, tr - tl + 1, a[i].id);
	}
	for (i = 0; i &lt; m; ++i) printf(&quot;%d/%d\n&quot;, up[i], down[i]);
	return 0;
}
<pre><h2>Problem2049</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 100005
inline void gi(int &amp;a) {
	static char c;
	while (c = getchar(), c &lt; '0'); a = c - '0';
	while (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}
int fa[N], ch[2][N];
bool rev[N];
//LCT
inline bool isrt(int u) {
	return (ch[0][fa[u]] ^ u) &amp;&amp; (ch[1][fa[u]] ^ u);
}
inline void updr(int u) {
	if (!u) return;
	std::swap(ch[0][u], ch[1][u]);
	rev[u] ^= 1;
}
inline void pd(int u) {
	if (!rev[u]) return;
	updr(ch[0][u]);
	updr(ch[1][u]);
	rev[u] = false;
}
inline void rot(int u) {
	static int f, d;
	f = fa[u], d = u == ch[1][f];
	if (ch[d][f] = ch[d^1][u]) fa[ch[d][f]] = f;
	if (!isrt(f)) ch[f == ch[1][fa[f]]][fa[f]] = u;
	fa[u] = fa[f], fa[f] = u;
	ch[d^1][u] = f;
}
void P(int u) {
	if (!isrt(u)) P(fa[u]);
	pd(u);
}
inline void splay(int u) {
	static int f;
	for (P(u); !isrt(u); rot(u))
		if (!isrt(f = fa[u]))
			rot(((f == ch[1][fa[f]]) ^ (u == ch[1][f])) ? u : f);
}
inline void access(int u) {
	static int v;
	for (v = 0; u; u = fa[v = u])
		splay(u), ch[1][u] = v;
}
inline void mrt(int u) {
	access(u);
	splay(u);
	updr(u);
}
inline int frt(int u) {
	while (fa[u]) u = fa[u];
	return u;
}
inline void link(int u, int v) {
	mrt(u);
	fa[u] = v;
}
inline void cut(int u, int v) {
	mrt(u);
	splay(v);
	fa[ch[0][v]] = fa[v];
	fa[v] = 0;
	ch[0][v] = 0;
}

int main() {
	int n, m, u, v;
	char ops[10];
	gi(n), gi(m);
	while (m--) {
		scanf(&quot;%s&quot;, ops);
		gi(u), gi(v);
		if (*ops == 'C') link(u, v);
		else if (*ops == 'D') cut(u, v);
		else puts((frt(u) ^ frt(v)) ? &quot;No&quot; : &quot;Yes&quot;);
	}
	return 0;
}<pre><h2>Problem2049</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 10003
#define wlp while
#define cit const int
inline void gi(int &amp;a) {
	static char c;
	wlp (c = getchar(), c &lt; '0'); a = c - '0';
	wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}
struct node {
	int fa, ch[2];
	bool rev;
}C[N];
inline bool isrt(cit &amp;u) {
	return (C[C[u].fa].ch[0] ^ u) &amp;&amp; (C[C[u].fa].ch[1] ^ u);
}
inline void updr(cit &amp;u) {
	if (!u) return;
	std::swap(C[u].ch[0], C[u].ch[1]);
	C[u].rev ^= 1;
}
inline void pd(cit &amp;u) {
	if (!C[u].rev) return;
	updr(C[u].ch[0]);
	updr(C[u].ch[1]);
	C[u].rev = false;
}
inline void rot(cit &amp;u) {
	static int f, d;
	f = C[u].fa, d = u == C[f].ch[1];
	if (C[f].ch[d] = C[u].ch[d ^ 1]) C[C[f].ch[d]].fa = f;
	if (!isrt(f)) C[C[f].fa].ch[f == C[C[f].fa].ch[1]] = u;
	C[u].fa = C[f].fa, C[f].fa = u;
	C[u].ch[d ^ 1] = f;
}
void P(cit &amp;u) {
	if (!isrt(u)) P(C[u].fa);
	pd(u);
}
inline bool type(cit &amp;u) {
	return u ^ C[C[u].fa].ch[0];
}
inline void splay(cit &amp;u) {
	static int f;
	for (P(u); !isrt(u); rot(u))
	  if (!isrt(f = C[u].fa))
		rot(type(f) == type(u) ? f : u);
}
inline void access(int u) {
	static int v;
	for (v = 0; u; u = C[v = u].fa)
	  splay(u), C[u].ch[1] = v;
}
inline void mrt(cit &amp;u) {
	access(u);
	splay(u);
	updr(u);
}
inline int frt(int u) {
	wlp (C[u].fa) u = C[u].fa;
	return u;
}
inline void link(cit &amp;u, cit &amp;v) {
	mrt(u);
	C[u].fa = v;
}
inline void cut(cit &amp;u, cit &amp;v) {
	mrt(u);
	splay(v);
	C[C[v].ch[0]].fa = C[v].fa;
	C[v].fa = C[v].ch[0] = 0;
}
int main() {
	int n, m, u, v;
	char ops[11];
	gi(n), gi(m);
	wlp (m--) {
		scanf(&quot;%s&quot;, ops);
		gi(u), gi(v);
		if (*ops == 'C') link(u, v);
		else if (*ops == 'D') cut(u, v);
		else puts((frt(u) ^ frt(v)) ? &quot;No&quot; : &quot;Yes&quot;);
	}
	return 0;
}<pre><h2>Problem2115</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline long long getll() {
	register long long a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
struct E{int to;long long v;E*nt;}CD[200002],*cd=CD,*hd[50002];
#define adde(a,b,c) (cd-&gt;to=b,cd-&gt;v=c,cd-&gt;nt=hd[a],hd[a]=cd++)
long long xv[50002],a[70];
bool vis[50002];
inline void addval(long long x) {
	for(register int i=62;(~i)&amp;&amp;x;--i)
		if(x&gt;&gt;i&amp;1) (a[i])?(x^=a[i]):(a[i]=x,x=0);
}
void dfs(int u) {
	vis[u]=true;
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(vis[it-&gt;to])addval(xv[u]^it-&gt;v^xv[it-&gt;to]);
		else {
			xv[it-&gt;to]=xv[u]^it-&gt;v;
			dfs(it-&gt;to);
		}
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;2115.in&quot;,&quot;r&quot;,stdin);
#endif
	register int n=geti(),m=geti(),i,j;
	long long c;
	while(m--) {
		i=geti(),j=geti(),c=getll();
		adde(i,j,c);adde(j,i,c);
	}
	dfs(1); c=xv[n];
	for(i=62;~i;--i)if((c^a[i])&gt;c)c^=a[i];
	printf(&quot;%lld\n&quot;,c);
	return 0;
}<pre><h2>Problem2115</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline long long getll() {
	register long long a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
struct E{int to;long long v;E*nt;}CD[200002],*cd=CD,*hd[50002];
#define adde(a,b,c) (cd-&gt;to=b,cd-&gt;v=c,cd-&gt;nt=hd[a],hd[a]=cd++)
long long xv[50002],a[62];
bool vis[50002];
inline void addval(long long x) {
	for(register int i=60;(~i)&amp;&amp;x;--i)
		if(x&gt;&gt;i&amp;1) (a[i])?(x^=a[i]):(a[i]=x,x=0);
}
void dfs(const int&amp;u) {
	vis[u]=true;
	for(E*it=hd[u];it;it=it-&gt;nt)
		if(vis[it-&gt;to])addval(xv[u]^it-&gt;v^xv[it-&gt;to]);
		else {
			xv[it-&gt;to]=xv[u]^it-&gt;v;
			dfs(it-&gt;to);
		}
}
int main() {
	register int n=geti(),m=geti(),i,j;
	long long c;
	while(m--) {
		i=geti(),j=geti(),c=getll();
		adde(i,j,c);adde(j,i,c);
	}
	dfs(1);c=xv[n];
	for(i=60;~i;--i)if((c^a[i])&gt;c)c^=a[i];
	printf(&quot;%lld\n&quot;,c);
	return 0;
}<pre><h2>Problem2117</h2><pre>#include &lt;map&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 100005
struct edge {
	int t, v;
	edge *n;
} me[N &lt;&lt; 1], *ce = me, *g[N];
#define adde(a, b, c) (*ce = (edge){b, c, g[a]}, g[a] = ce++)
typedef int arr[N];
arr dep, dis, siz, son, tp, fa, dq, in;
int dfn, n, K;
void d1(int u) {
	siz[u] = 1;
	for (edge *it = g[u]; it; it = it-&gt;n)
	  if (it-&gt;t ^ fa[u]) {
		  fa[it-&gt;t] = u;
		  dep[it-&gt;t] = dep[u] + 1;
		  dis[it-&gt;t] = dis[u] + it-&gt;v;
		  d1(it-&gt;t);
		  siz[u] += siz[it-&gt;t];
		  if (siz[it-&gt;t] &gt; siz[son[u]])
			son[u] = it-&gt;t;
	  }
}
void d2(int u, int anc) {
	dq[in[u] = ++dfn] = u;
	tp[u] = anc;
	if (son[u]) d2(son[u], anc);
	for (edge *it = g[u]; it; it = it-&gt;n)
	  if (!tp[it-&gt;t]) d2(it-&gt;t, it-&gt;t);
}
int Lca(int u, int v) {
	while (tp[u] ^ tp[v]) dep[tp[u]] &lt; dep[tp[v]] ? v = fa[tp[v]] : u = fa[tp[u]];
	return dep[u] &lt; dep[v] ? u : v;
}
int disc(int u, int v) {
	return dis[u] + dis[v] - (dis[Lca(u, v)] &lt;&lt; 1);
}
int jump(int u, int d) {
	while (dep[tp[u]] &gt; d) u = fa[tp[u]];
	return dq[in[u] - (dep[u] - d)];
}
int Getadj(int c, int u) {
	return (Lca(u, c) ^ c) ? fa[c] : jump(u, dep[c] + 1);
}
arr f, Dis;
int SZ, rt;
bool vis[N];
inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}
typedef vector&lt;int&gt; vii;
struct node {
	int pre;
	vii vec;
	map&lt;int, vii&gt; adj_vec;
} dc[N];
void grt(int u, int fa) {
	f[u] = 0, siz[u] = 1;
	for (edge *it = g[u]; it; it = it-&gt;n) 
	  if (!vis[it-&gt;t] &amp;&amp; (it-&gt;t ^ fa)) {
		  grt(it-&gt;t, u);
		  cmax(f[u], siz[it-&gt;t]);
		  siz[u] += siz[it-&gt;t];
	  }
	cmax(f[u], SZ - siz[u]);
	if (f[u] &lt; f[rt]) rt = u;
}
void dfs(int u, int fa, vii &amp;v1, vii &amp;v2) {
	v1.push_back(Dis[u]);
	v2.push_back(Dis[u]);
	siz[u] = 1;
	for (edge *it = g[u]; it; it = it -&gt;n) 
	  if ((it-&gt;t ^ fa) &amp;&amp; !vis[it-&gt;t]) {
		  Dis[it-&gt;t] = Dis[u] + it-&gt;v;
		  dfs(it-&gt;t, u, v1, v2);
		  siz[u] += siz[it-&gt;t];
	  }
}
void solve(int u) {
	vis[u] = 1;
	dc[u].vec.push_back(0);
	for (edge *it = g[u]; it; it = it-&gt;n) 
	  if (!vis[it-&gt;t]) {
		  Dis[it-&gt;t] = it-&gt;v;
		  vii &amp;v0 = dc[u].adj_vec[it-&gt;t];
		  dfs(it-&gt;t, u, dc[u].vec, v0);
		  sort(v0.begin(), v0.end());
	  }
	sort(dc[u].vec.begin(), dc[u].vec.end());
	for (edge *it = g[u]; it; it = it-&gt;n) 
	if (!vis[it-&gt;t]){
		f[rt = 0] = SZ = siz[it-&gt;t];
		grt(it-&gt;t, u);
		dc[rt].pre = u;
		solve(rt);
	}
}
int GetLess(vii &amp;v, const int &amp;x) {
	if (v.empty() || x &lt; *v.begin())
	  return 0;
	if (x &gt;= *v.rbegin())
	  return v.size();
	return upper_bound(v.begin(), v.end(), x) - v.begin();
}
int cal(int u, const int &amp;v, const int &amp;d) {
	int ret = 0;
	if (dc[u].pre)
	  ret = cal(dc[u].pre, v, d);
	if (ret &gt; K)
	  return ret;
	vii &amp;v1 = dc[u].vec;
	int x = disc(u, v);
	ret += GetLess(v1, d - x);
	if (u ^ v) {
		int t = Getadj(u, v);
		ret -= GetLess(dc[u].adj_vec[t], d - x);
	}
	return ret;
}
int R;
void GetAns(int u) {
	int l = 0, r = R, mid;
	while (l &lt;= r)
	  if (cal(u, u, mid = (l + r) &gt;&gt; 1) &lt;= K)
		l = mid + 1;
	else
	  r = mid - 1;
	printf(&quot;%d\n&quot;, r + 1);
}
int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%*s%d%d&quot;, &amp;n, &amp;K);
	int u, v, w;
	for (int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		adde(u, v, w);
		adde(v, u, w);
		R += w;
	}
	d1(1);
	d2(1, 1);
	f[rt = 0] = n;
	SZ = n;
	rt = 0;
	grt(1, 0);
	solve(rt);
	for (int i = 1; i &lt;= n; ++i) GetAns(i);
	return 0;
}<pre><h2>Problem2125</h2><pre>    #include&lt;iostream&gt;  
    #include&lt;cstdio&gt;  
    #include&lt;cstring&gt;  
    #include&lt;cmath&gt;  
    #include&lt;queue&gt;  
    #include&lt;vector&gt;  
    #include&lt;stack&gt;  
    #include&lt;algorithm&gt;  
    using namespace std;  
      
    const int maxn = 2E5 + 10;  
      
    struct E{  
        int x,y,w; E(){}  
        E(int x,int y,int w): x(x),y(y),w(w){}  
    };  
      
    struct E2{  
        int to,w; E2(){}  
        E2(int to,int w): to(to),w(w){}  
    };  
      
    int n,m,q,dfs_clock,fx,fy,scc,dis[maxn],bel[maxn],dfn[maxn]  
        ,low[maxn],dist[maxn],tot[maxn],fa[maxn][15],L[maxn];  
    bool Mark[maxn];  
      
    vector &lt;E2&gt; v[maxn];  
    vector &lt;E2&gt; v2[maxn];  
    stack &lt;E&gt; s;  
    queue &lt;int&gt; Q;  
      
    void Build_scc(int A,int B)  
    {  
        ++scc; Mark[A] = 1;  
        while (s.top().x != A &amp;&amp; s.top().y != B) {  
            E e = s.top(); s.pop();  
            bel[e.x] = scc; tot[scc] += e.w;  
            dist[e.x] = dist[e.y] + e.w;  
            Q.push(e.x);   
        }  
        E e = s.top(); s.pop(); tot[scc] += e.w;  
        if (Q.empty()) v2[A].push_back(E2(B,tot[scc]));  
          
        while (!Q.empty()) {  
            int k = Q.front(); Q.pop();  
            int w = min(dist[k],tot[scc] - dist[k]);  
            v2[A].push_back(E2(k,w));  
        }  
    }  
      
    void Dfs1(int x,int from)  
    {  
        dfn[x] = low[x] = ++dfs_clock;  
        for (int i = 0; i &lt; v[x].size(); i++) {  
            E2 e = v[x][i];  
            if (!dfn[e.to]) {  
                s.push(E(x,e.to,e.w));   
                Dfs1(e.to,x);  
                if (dfn[x] &lt;= low[e.to]) Build_scc(x,e.to);  
                low[x] = min(low[x],low[e.to]);  
            }  
            else if (e.to != from &amp;&amp; dfn[e.to] &lt; low[x]) low[x] = dfn[e.to],s.push(E(x,e.to,e.w));   
        }  
    }  
      
    void Dfs2(int x,int from)  
    {  
        for (int i = 1; i &lt; 15; i++) fa[x][i] = fa[fa[x][i-1]][i-1];  
        for (int i = 0; i &lt; v2[x].size(); i++) {  
            E2 e = v2[x][i];  
            L[e.to] = L[x] + 1; fa[e.to][0] = x;  
            dis[e.to] = dis[x] + e.w;  
            Dfs2(e.to,x);  
        }  
    }  
      
    int LCA(int p,int q)  
    {  
        fx = fy = 0;  
        if (L[p] &lt; L[q]) swap(p,q);  
        for (int j = 14; j &gt;= 0; j--)  
            if (L[p] - (1&lt;&lt;j) &gt;= L[q])  
                p = fa[p][j];  
        if (p == q) return p;  
        for (int j = 14; j &gt;= 0; j--)  
            if (fa[p][j] != fa[q][j])  
                p = fa[p][j],q = fa[q][j];  
        fx = p; fy = q;  
        return fa[p][0];  
    }  
      
    int main()  
    {  
        #ifdef DMC  
            freopen(&quot;DMC.txt&quot;,&quot;r&quot;,stdin);  
        #endif  
          
        cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;  
        while (m--) {  
            int x,y,w; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);  
            v[x].push_back(E2(y,w));  
            v[y].push_back(E2(x,w));  
        }  
        Dfs1(1,0);  
        L[1] = 1; Dfs2(1,0);  
        while (q--) {  
            int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y);  
            int lca = LCA(x,y);  
            if (Mark[lca] &amp;&amp; bel[fx] == bel[fy] &amp;&amp; bel[fx]) {  
                int G = abs(dist[fx] - dist[fy]);  
                G = min(G,tot[bel[fx]] - G);  
                printf(&quot;%d\n&quot;,dis[x] + dis[y] - dis[fx] - dis[fy] + G);  
            }  
            else printf(&quot;%d\n&quot;,dis[x] + dis[y] - 2*dis[lca]);  
        }  
        return 0;  
    }  <pre><h2>Problem2125</h2><pre>#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

struct edge {
	int u, v, w;
	edge(int u, int v, int w) :
		u(u), v(v), w(w) {}
};


struct eg {
	int to, w;
	eg(int to, int w) :
		to(to), w(w) {}
};

const int MaxN = 2e5 + 9;
typedef int arr[MaxN];
typedef vector&lt;eg&gt;::iterator veit;
int dfs_clock, scc_cnt;
arr dis, bel, dfn, low, dist, tot, fa[15], dep;

bool mark[MaxN];
vector&lt;eg&gt; g[MaxN], G[MaxN];
stack&lt;edge&gt; s;
queue&lt;int&gt; q;

inline void build_scc(int A, int B) {
	static edge e(0, 0, 0);
	static int k, w;
	++scc_cnt;
	mark[A] = true;
	while ((s.top().u ^ A) &amp;&amp; (s.top().v ^ B)) {
		e = s.top();
		s.pop();
		bel[e.u] = scc_cnt;
		tot[scc_cnt] += e.w;
		dist[e.u] = dist[e.v] + e.w;
		q.push(e.u);
	}
	tot[scc_cnt] += s.top().w;
	s.pop();
	if (q.empty())
		G[A].push_back(eg(B, tot[scc_cnt]));
	while (!q.empty()) {
		k = q.front();
		q.pop();
		w = min(dist[k], tot[scc_cnt] - dist[k]);
		G[A].push_back(eg(k, w));
	}
}

void dfs1(int u, int father) {
	dfn[u] = low[u] = ++dfs_clock;
	for (veit it = g[u].begin(); it != g[u].end(); ++it) {
		if (!dfn[it-&gt;to]) {
			s.push(edge(u, it-&gt;to, it-&gt;w));
			dfs1(it-&gt;to, u);
			if (dfn[u] &lt;= low[it-&gt;to])
				build_scc(u, it-&gt;to);
			if (low[it-&gt;to] &lt; low[u])
				low[u] = low[it-&gt;to];
		} else if ((it-&gt;to ^ father) &amp;&amp; dfn[it-&gt;to] &lt; low[u]) {
			low[u] = dfn[it-&gt;to];
			s.push(edge(u, it-&gt;to, it-&gt;w));
		}
	}
}

void dfs2(int u) {
	for (int i = 1; fa[i][u] = fa[i - 1][fa[i - 1][u]]; ++i);
	for (veit it = G[u].begin(); it != G[u].end(); ++it) {
		dep[it-&gt;to] = dep[u] + 1;
		fa[0][it-&gt;to] = u;
		dis[it-&gt;to] = dis[u] + it-&gt;w;
		dfs2(it-&gt;to);
	}
}

inline int Lca(int u, int v, int &amp;fu, int &amp;fv) {
	fu = fv = 0;
	if (dep[u] &lt; dep[v])
		swap(u, v);
	for (int i = 0, j = dep[u] - dep[v]; j; ++i, j &gt;&gt;= 1)
		if (j &amp; 1) u = fa[i][u];
	if (u == v)
		return u;
	for (int i = 14; ~i; --i)
		if (fa[i][u] ^ fa[i][v]) {
			u = fa[i][u];
			v = fa[i][v];
		}
	fu = u, fv = v;
	return fa[0][u];
}

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
#endif
	int n, m, q, u, v, w, lca, fu, fv;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);
	while (m--) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		g[u].push_back(eg(v, w));
		g[v].push_back(eg(u, w));
	}
	dfs1(1, 0);
	dfs2(1);
	while (q--) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		lca = Lca(u, v, fu, fv);
		if (mark[lca] &amp;&amp; bel[fu] &amp;&amp; bel[fu] == bel[fv]) {
			w = abs(dist[fu] - dist[fv]);
			w = min(w, tot[bel[fu]] - w);
			printf(&quot;%d\n&quot;, dis[u] + dis[v] - dis[fu] - dis[fv] + w);
		} else
			printf(&quot;%d\n&quot;, dis[u] + dis[v] - 2 * dis[lca]);
	}
	return 0;
}
<pre><h2>Problem2141</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define N 20005
#define SIZE 145

int C[SIZE][N], rk[N], h[N], n;
inline void Add(int *tr, int x, const int &amp;val) {
	for (; x &lt;= ::n; x += x &amp; -x)
		tr[x] += val;
}
inline int Sum(int *tr, int x) {
	static int ret;
	for (ret = 0; x; x -= x &amp; -x)
		ret += tr[x];
	return ret;
}

inline bool cmp(const int &amp;a, const int &amp;b) {
	return ::h[a] &lt; ::h[b];
}

#define belong(pos) ((pos - 1) / block)

int main() {
	int m, block, i, j, last, tot = 0, idx, idy, x, y;
	scanf(&quot;%d&quot;, &amp;::n);
	block = sqrt(::n) + 0.5;
	for (i = 1; i &lt;= ::n; ++i)
		scanf(&quot;%d&quot;, ::h + i), ::rk[i] = i;
	std::sort(::rk + 1, ::rk + ::n + 1, cmp);
	last = ::h[::rk[1]];
	::h[::rk[1]] = j = 1;
	::rk[1] = 0;
	for (i = 2; i &lt;= ::n; ++i) {
		if (::h[::rk[i]] ^ last) last = ::h[::rk[i]], ++j;
		::h[::rk[i]] = j;
		::rk[i] = 0;
	}

	i = ::n;
	::n = j;
	
	for (; i; --i) {
		tot += Sum(::rk, ::h[i] - 1);
		Add(::rk, ::h[i], 1);
		Add(::C[belong(i)], ::h[i], 1);
	}
	
	printf(&quot;%d\n&quot;, tot);
	
	scanf(&quot;%d&quot;, &amp;m);
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		if (x &gt; y) x ^= y ^= x ^= y;
		idx = belong(x) + 1, idy = belong(y) - 1;
		if (idx &lt;= idy) {
			for (i = idx; i &lt;= idy; ++i) {
				tot -= Sum(::C[i], ::h[x] - 1);
				tot += Sum(::C[i], ::n) - Sum(::C[i], ::h[x]);
				tot += Sum(::C[i], ::h[y] - 1);
				tot -= Sum(::C[i], ::n) - Sum(::C[i], ::h[y]);
			}
			for (i = x + 1, j = idx * block + 1; i &lt; j; ++i) {
				tot -= ::h[i] &lt; ::h[x];
				tot += ::h[i] &gt; ::h[x];
				tot += ::h[i] &lt; ::h[y];
				tot -= ::h[i] &gt; ::h[y];
			}
			for (i = (idy + 1) * block + 1; i &lt; y; ++i) {
				tot -= ::h[i] &lt; ::h[x];
				tot += ::h[i] &gt; ::h[x];
				tot += ::h[i] &lt; ::h[y];
				tot -= ::h[i] &gt; ::h[y];
			}
		} else {
			for (i = x + 1; i &lt; y; ++i) {
				tot -= ::h[i] &lt; ::h[x];
				tot += ::h[i] &gt; ::h[x];
				tot += ::h[i] &lt; ::h[y];
				tot -= ::h[i] &gt; ::h[y];
			}
		}
		if (::h[x] &lt; ::h[y]) ++tot;
		else if (::h[x] &gt; ::h[y]) --tot;
		--idx, ++idy;
		Add(::C[idx], ::h[x], -1);
		Add(::C[idy], ::h[y], -1);
		::h[x] ^= ::h[y] ^= ::h[x] ^= ::h[y];
		Add(::C[idx], ::h[x], 1);
		Add(::C[idy], ::h[y], 1);

		printf(&quot;%d\n&quot;, tot);
	}
	return 0;
}
<pre><h2>Problem2141</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

inline char gc() {
	static char b[1 &lt;&lt; 16], *s = b, *e = b;
	if (s == e) e = (s = b) + fread(b, 1, 1 &lt;&lt; 16, stdin);
	return (s == e) ? EOF : *s++;
}

inline void gi(int &amp;a) {
	static char c;
	while (c = gc(), c &lt; '0'); a = c - '0';
	while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

#define N 20005
#define SIZE 145

int C[SIZE][N], rk[N], h[N], n;
inline void Add(int *tr, int x, const int &amp;val) {
	for (; x &lt;= ::n; x += x &amp; -x)
		tr[x] += val;
}
inline int Sum(int *tr, int x) {
	static int ret;
	for (ret = 0; x; x -= x &amp; -x)
		ret += tr[x];
	return ret;
}

inline bool cmp(const int &amp;a, const int &amp;b) {
	return ::h[a] &lt; ::h[b];
}

#define belong(pos) ((pos - 1) / block)

int main() {
	int m, block, i, j, last, tot = 0, idx, idy, x, y;
	gi(::n);
	block = sqrt(::n) + 0.5;
	for (i = 1; i &lt;= ::n; ++i)
		gi(::h[i]), ::rk[i] = i;
	std::sort(::rk + 1, ::rk + ::n + 1, cmp);
	last = ::h[::rk[1]];
	::h[::rk[1]] = j = 1;
	::rk[1] = 0;
	for (i = 2; i &lt;= ::n; ++i) {
		if (::h[::rk[i]] ^ last) last = ::h[::rk[i]], ++j;
		::h[::rk[i]] = j;
		::rk[i] = 0;
	}

	i = ::n;
	::n = j;
	
	for (; i; --i) {
		tot += Sum(::rk, ::h[i] - 1);
		Add(::rk, ::h[i], 1);
		Add(::C[belong(i)], ::h[i], 1);
	}
	
	printf(&quot;%d\n&quot;, tot);
	
	gi(m);
	while (m--) {
		gi(x); gi(y);
		if (x &gt; y) x ^= y ^= x ^= y;
		idx = belong(x) + 1, idy = belong(y) - 1;
		if (idx &lt;= idy) {
			for (i = idx; i &lt;= idy; ++i) {
				tot -= Sum(::C[i], ::h[x] - 1);
				tot += Sum(::C[i], ::n) - Sum(::C[i], ::h[x]);
				tot += Sum(::C[i], ::h[y] - 1);
				tot -= Sum(::C[i], ::n) - Sum(::C[i], ::h[y]);
			}
			for (i = x + 1, j = idx * block + 1; i &lt; j; ++i) {
				tot -= ::h[i] &lt; ::h[x];
				tot += ::h[i] &gt; ::h[x];
				tot += ::h[i] &lt; ::h[y];
				tot -= ::h[i] &gt; ::h[y];
			}
			for (i = (idy + 1) * block + 1; i &lt; y; ++i) {
				tot -= ::h[i] &lt; ::h[x];
				tot += ::h[i] &gt; ::h[x];
				tot += ::h[i] &lt; ::h[y];
				tot -= ::h[i] &gt; ::h[y];
			}
		} else {
			for (i = x + 1; i &lt; y; ++i) {
				tot -= ::h[i] &lt; ::h[x];
				tot += ::h[i] &gt; ::h[x];
				tot += ::h[i] &lt; ::h[y];
				tot -= ::h[i] &gt; ::h[y];
			}
		}
		if (::h[x] &lt; ::h[y]) ++tot;
		else if (::h[x] &gt; ::h[y]) --tot;
		--idx, ++idy;
		Add(::C[idx], ::h[x], -1);
		Add(::C[idy], ::h[y], -1);
		::h[x] ^= ::h[y] ^= ::h[x] ^= ::h[y];
		Add(::C[idx], ::h[x], 1);
		Add(::C[idy], ::h[y], 1);

		printf(&quot;%d\n&quot;, tot);
	}
	return 0;
}
<pre><h2>Problem2141</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

inline char gc() {
	static char b[1 &lt;&lt; 16], *s = b, *e = b;
	if (s == e) e = (s = b) + fread(b, 1, 1 &lt;&lt; 16, stdin);
	return (s == e) ? EOF : *s++;
}

inline void gi(int &amp;a) {
	static char c;
	while (c = gc(), c &lt; '0'); a = c - '0';
	while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

#define N 20005
#define SIZE 145

int C[SIZE][N], rk[N], h[N], n;
inline void Add(int *tr, int x, const int &amp;val) {
	for (; x &lt;= ::n; x += x &amp; -x)
		tr[x] += val;
}
inline int Sum(int *tr, int x) {
	static int ret;
	for (ret = 0; x; x -= x &amp; -x)
		ret += tr[x];
	return ret;
}

inline bool cmp(const int &amp;a, const int &amp;b) {
	return ::h[a] &lt; ::h[b];
}

#define belong(pos) ((pos - 1) / block)

int main() {
	int m, last, idx, idy, x, y;
	register int i, j, block, tot = 0;
	gi(::n);
	block = sqrt(::n) + 0.5;
	for (i = 1; i &lt;= ::n; ++i)
		gi(::h[i]), ::rk[i] = i;
	std::sort(::rk + 1, ::rk + ::n + 1, cmp);
	last = ::h[::rk[1]];
	::h[::rk[1]] = j = 1;
	::rk[1] = 0;
	for (i = 2; i &lt;= ::n; ++i) {
		if (::h[::rk[i]] ^ last) last = ::h[::rk[i]], ++j;
		::h[::rk[i]] = j;
		::rk[i] = 0;
	}

	i = ::n;
	::n = j;
	
	for (; i; --i) {
		tot += Sum(::rk, ::h[i] - 1);
		Add(::rk, ::h[i], 1);
		Add(::C[belong(i)], ::h[i], 1);
	}
	
	printf(&quot;%d\n&quot;, tot);
	
	gi(m);
	while (m--) {
		gi(x); gi(y);
		if (x &gt; y) x ^= y ^= x ^= y;
		idx = belong(x) + 1, idy = belong(y) - 1;
		if (idx &lt;= idy) {
			for (i = idx; i &lt;= idy; ++i) {
				tot -= Sum(::C[i], ::h[x] - 1);
				tot += Sum(::C[i], ::n) - Sum(::C[i], ::h[x]);
				tot += Sum(::C[i], ::h[y] - 1);
				tot -= Sum(::C[i], ::n) - Sum(::C[i], ::h[y]);
			}
			for (i = x + 1, j = idx * block + 1; i &lt; j; ++i) {
				if (::h[i] &lt; ::h[x]) --tot;
				else if (::h[i] &gt; ::h[x]) ++tot;
				if (::h[i] &lt; ::h[y]) ++tot;
				else if (::h[i] &gt; ::h[y]) --tot;
			}
			for (i = (idy + 1) * block + 1; i &lt; y; ++i) {
				if (::h[i] &lt; ::h[x]) --tot;
				else if (::h[i] &gt; ::h[x]) ++tot;
				if (::h[i] &lt; ::h[y]) ++tot;
				else if (::h[i] &gt; ::h[y]) --tot;
			}
		} else {
			for (i = x + 1; i &lt; y; ++i) {
				if (::h[i] &lt; ::h[x]) --tot;
				else if (::h[i] &gt; ::h[x]) ++tot;
				if (::h[i] &lt; ::h[y]) ++tot;
				else if (::h[i] &gt; ::h[y]) --tot;
			}
		}
		if (::h[x] &lt; ::h[y]) ++tot;
		else if (::h[x] &gt; ::h[y]) --tot;
		--idx, ++idy;
		Add(::C[idx], ::h[x], -1);
		Add(::C[idy], ::h[y], -1);
		::h[x] ^= ::h[y] ^= ::h[x] ^= ::h[y];
		Add(::C[idx], ::h[x], 1);
		Add(::C[idy], ::h[y], 1);

		printf(&quot;%d\n&quot;, tot);
	}
	return 0;
}
<pre><h2>Problem2141</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

inline char gc() {
	static char b[1 &lt;&lt; 16], *s = b, *e = b;
	if (s == e) e = (s = b) + fread(b, 1, 1 &lt;&lt; 16, stdin);
	return (s == e) ? EOF : *s++;
}

inline void gi(int &amp;a) {
	static char c;
	while (c = gc(), c &lt; '0'); a = c - '0';
	while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

#define N 20005
#define SIZE 145

int C[SIZE][N], rk[N], h[N], n;
inline void Add(int *tr, int x, const int &amp;val) {
	for (; x &lt;= ::n; x += x &amp; -x)
		tr[x] += val;
}
inline int Sum(int *tr, int x) {
	static int ret;
	for (ret = 0; x; x -= x &amp; -x)
		ret += tr[x];
	return ret;
}

inline bool cmp(const int &amp;a, const int &amp;b) {
	return ::h[a] &lt; ::h[b];
}

#define belong(pos) ((pos - 1) / block)

int main() {
	int m, last, idx, idy, x, y;
	register int i, j, block, tot;
	gi(::n);
	block = sqrt(::n) + 0.5;
	for (i = 1; i &lt;= ::n; ++i)
		gi(::h[i]), ::rk[i] = i;
	std::sort(::rk + 1, ::rk + ::n + 1, cmp);
	last = ::h[::rk[1]];
	::h[::rk[1]] = j = 1;
	::rk[1] = 0;
	for (i = 2; i &lt;= ::n; ++i) {
		if (::h[::rk[i]] ^ last) last = ::h[::rk[i]], ++j;
		::h[::rk[i]] = j;
		::rk[i] = 0;
	}

	i = ::n;
	::n = j;
	
	for (tot = 0; i; --i) {
		tot += Sum(::rk, ::h[i] - 1);
		Add(::rk, ::h[i], 1);
		Add(::C[belong(i)], ::h[i], 1);
	}
	
	printf(&quot;%d\n&quot;, tot);
	
	gi(m);
	while (m--) {
		gi(x); gi(y);
		if (x &gt; y) x ^= y ^= x ^= y;
		idx = belong(x) + 1, idy = belong(y) - 1;
		if (idx &lt;= idy) {
			for (i = idx; i &lt;= idy; ++i) {
				tot -= Sum(::C[i], ::h[x] - 1);
				tot += Sum(::C[i], ::n) - Sum(::C[i], ::h[x]);
				tot += Sum(::C[i], ::h[y] - 1);
				tot -= Sum(::C[i], ::n) - Sum(::C[i], ::h[y]);
			}
			for (i = x + 1, j = idx * block + 1; i &lt; j; ++i) {
				if (::h[i] &lt; ::h[x]) --tot;
				else if (::h[i] &gt; ::h[x]) ++tot;
				if (::h[i] &lt; ::h[y]) ++tot;
				else if (::h[i] &gt; ::h[y]) --tot;
			}
			for (i = (idy + 1) * block + 1; i &lt; y; ++i) {
				if (::h[i] &lt; ::h[x]) --tot;
				else if (::h[i] &gt; ::h[x]) ++tot;
				if (::h[i] &lt; ::h[y]) ++tot;
				else if (::h[i] &gt; ::h[y]) --tot;
			}
		} else {
			for (i = x + 1; i &lt; y; ++i) {
				if (::h[i] &lt; ::h[x]) --tot;
				else if (::h[i] &gt; ::h[x]) ++tot;
				if (::h[i] &lt; ::h[y]) ++tot;
				else if (::h[i] &gt; ::h[y]) --tot;
			}
		}
		if (::h[x] &lt; ::h[y]) ++tot;
		else if (::h[x] &gt; ::h[y]) --tot;
		--idx, ++idy;
		Add(::C[idx], ::h[x], -1);
		Add(::C[idy], ::h[y], -1);
		::h[x] ^= ::h[y] ^= ::h[x] ^= ::h[y];
		Add(::C[idx], ::h[x], 1);
		Add(::C[idy], ::h[y], 1);

		printf(&quot;%d\n&quot;, tot);
	}
	return 0;
}
<pre><h2>Problem2142</h2><pre>#include &lt;cstdio&gt;

const int maxm(10), maxs(1e5 + 7);
typedef long long ll;


inline void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) {
	if (b) {
		exgcd(b, a % b, y, x);
		y -= a / b * x;
	} else
		x = 1, y = 0;
}

inline ll fast_pow(ll a, int b, int mod) {
	static ll r;
	for (r = 1; b; b &gt;&gt;= 1, a = a * a % mod)
		if (b &amp; 1) r = r * a % mod;
	return r;
}

inline ll inv(ll a, ll p) {
	static ll x, y;
	exgcd(a, p, x, y);
	while (x &lt; 0) x += p;
	return x;
}

inline ll china(int n, int *a, int *m) {
	ll M = 1, t, ans = 0;
	for (register int i = 0; i &lt; n; ++i) M *= m[i];
	for (register int i = 0; i &lt; n; ++i) {
		t = M / m[i];
		ans += t * inv(t, m[i]) * a[i];
		ans %= M;
	}
	return ans;
}

int a[maxm], _m[maxm], fac[maxs], w[maxm], p, n, m;

inline ll mod_fac(int n, const int &amp;P, const int &amp;p, int &amp;e) {
	if (n &lt; p) return fac[n];
	e += n / p;
	return fast_pow(fac[P - 1], n / P, P) * fac[n % P] % P * mod_fac(n / p, P, p, e) % P;
}

inline int calc(int P, int p) {
	static ll m1, m2;
	static int e1, e2;
	m2 = fac[0] = fac[1] = 1;
	for (register int i = 2; i &lt; P; ++i) fac[i] = (ll)fac[i - 1] * (i % p ? i : 1) % P;
	e1 = e2 = 0;
	m1 = mod_fac(::n, P, p, e1);
	for (register int i = 0; i &lt; ::m; ++i)
		m2 = m2 * mod_fac(::w[i], P, p, e2) % P;
	return m1 * inv(m2, P) % P * fast_pow(p, e1 - e2, P) % P;
}

int main() {
	int cnt = 0, sum = 0;
	scanf(&quot;%d%d%d&quot;, &amp;p, &amp;n, &amp;m);
	for (register int i = 0; i &lt; m; ++i) {
		scanf(&quot;%d&quot;, w + i);
		sum += w[i];
	}
	if (sum &gt; n)
		return puts(&quot;Impossible&quot;), 0;
	if (sum &lt; n)
		w[m++] = n - sum;
	for (register int i = 2; i * i &lt;= p; ++i)
		if (p % i == 0) {
			static int t;
			for (t = 1; p % i == 0; p /= i)
				t *= i;
			_m[cnt] = t;
			a[cnt] = calc(t, i);
			++cnt;
		}
	if (p &gt; 1)
		_m[cnt] = p, a[cnt++] = calc(p, p);
	//for (register int i = 0; i &lt; cnt; ++i)
	//	printf(&quot;%d %d\n&quot;, _m[i], a[i]);
	printf(&quot;%d\n&quot;, (int)china(cnt, a, _m));
	return 0;
}<pre><h2>Problem2145</h2><pre>    #include&lt;iostream&gt;  
    #include&lt;algorithm&gt;  
    #include&lt;cstdio&gt;  
    #include&lt;cstring&gt;  
    #include&lt;cctype&gt;  
    #include&lt;map&gt;  
    #define rep(i,a,b) for(int i=a;i&lt;=b;++i)  
    #define erp(i,a,b) for(int i=a;i&gt;=b;--i)  
    using namespace std;  
    typedef unsigned long long u64;  
      
    char buf[10000], s[10000], word[10000], d[10000], ss[10000];  
    bool yuan[26];  
    map&lt;u64, int&gt; ha;  
      
    char dict[1000][30] = {  
    &quot;am&quot;,&quot;is&quot;,&quot;are&quot;,&quot;was&quot;,&quot;were&quot;,&quot;been&quot;,  
    &quot;a&quot;,&quot;an&quot;,&quot;the&quot;,&quot;this&quot;,&quot;that&quot;,&quot;these&quot;,&quot;those&quot;,&quot;there&quot;,&quot;even&quot;,  
    &quot;i&quot;,&quot;me&quot;,&quot;my&quot;,&quot;you&quot;,&quot;your&quot;,&quot;he&quot;,&quot;his&quot;,&quot;him&quot;,&quot;she&quot;,&quot;her&quot;,&quot;hers&quot;,&quot;we&quot;,&quot;our&quot;,&quot;ours&quot;,&quot;it&quot;,&quot;its&quot;,  
    &quot;up&quot;,&quot;to&quot;,&quot;for&quot;,&quot;in&quot;,&quot;out&quot;,&quot;of&quot;,&quot;on&quot;,&quot;above&quot;,&quot;below&quot;,&quot;over&quot;,&quot;under&quot;,&quot;into&quot;,&quot;after&quot;,&quot;before&quot;,  
    &quot;what&quot;,&quot;where&quot;,&quot;when&quot;,&quot;how&quot;,&quot;why&quot;,&quot;if&quot;,&quot;then&quot;,&quot;else&quot;,&quot;begin&quot;,&quot;end&quot;,&quot;while&quot;,&quot;break&quot;,&quot;continue&quot;,  
    &quot;yes&quot;,&quot;no&quot;,&quot;never&quot;,&quot;ever&quot;,&quot;sure&quot;,&quot;thank&quot;,&quot;thanks&quot;,&quot;welcome&quot;,&quot;sorry&quot;,&quot;and&quot;,&quot;or&quot;,&quot;but&quot;,&quot;though&quot;,&quot;although&quot;,  
    &quot;morning&quot;,&quot;afternoon&quot;,&quot;evening&quot;,&quot;nignt&quot;,&quot;please&quot;,&quot;file&quot;  
    };  
      
    char noun[1000][30] = {  
    &quot;tom&quot;,&quot;bob&quot;,&quot;alice&quot;,&quot;david&quot;,&quot;james&quot;,&quot;peter&quot;,&quot;tony&quot;,&quot;friend&quot;,&quot;wife&quot;,&quot;husband&quot;,&quot;aunt&quot;,&quot;uncle&quot;,  
    &quot;book&quot;,&quot;desk&quot;,&quot;table&quot;,&quot;computer&quot;,&quot;bed&quot;,&quot;pen&quot;,&quot;man&quot;,&quot;woman&quot;,&quot;women&quot;,&quot;men&quot;,&quot;boy&quot;,&quot;girl&quot;,&quot;people&quot;,&quot;time&quot;,&quot;kid&quot;,&quot;child&quot;,  
    &quot;cat&quot;,&quot;dog&quot;,&quot;cow&quot;,&quot;pig&quot;,&quot;mouse&quot;,&quot;mice&quot;,&quot;rice&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;,&quot;ten&quot;,  
    &quot;son&quot;,&quot;daughter&quot;,&quot;shower&quot;,&quot;rain&quot;,&quot;weather&quot;,&quot;sun&quot;,&quot;sunny&quot;,&quot;wind&quot;,&quot;snow&quot;,&quot;fire&quot;,&quot;water&quot;,&quot;river&quot;,&quot;sea&quot;,  
    &quot;window&quot;,&quot;floor&quot;,&quot;house&quot;,&quot;room&quot;,&quot;door&quot;,&quot;way&quot;,&quot;road&quot;,&quot;street&quot;,&quot;light&quot;,&quot;word&quot;,  
    &quot;car&quot;,&quot;bike&quot;,&quot;bus&quot;,&quot;truck&quot;,&quot;plane&quot;,&quot;air&quot;,&quot;king&quot;,&quot;queen&quot;,&quot;sodier&quot;,  
    &quot;dollars&quot;,&quot;money&quot;,&quot;cake&quot;,&quot;bread&quot;,&quot;math&quot;,&quot;chinese&quot;,&quot;english&quot;,&quot;hand&quot;,&quot;eye&quot;,&quot;head&quot;,&quot;body&quot;,&quot;mouth&quot;,  
    &quot;apple&quot;,&quot;banana&quot;,&quot;orange&quot;,&quot;pear&quot;,&quot;tree&quot;,&quot;grass&quot;,&quot;melon&quot;,&quot;bush&quot;,  
    &quot;city&quot;,&quot;country&quot;,&quot;nation&quot;,&quot;flag&quot;,&quot;breakfast&quot;,&quot;lunch&quot;,&quot;dinner&quot;  
    };  
      
    char ad[1000][30] = {  
    &quot;good&quot;,&quot;well&quot;,&quot;bad&quot;,&quot;nice&quot;,&quot;beautiful&quot;,&quot;better&quot;,&quot;worse&quot;,&quot;happy&quot;,&quot;glad&quot;,&quot;sad&quot;,&quot;other&quot;,&quot;recent&quot;  
    &quot;green&quot;,&quot;white&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;red&quot;,&quot;purple&quot;,&quot;big&quot;,&quot;large&quot;,&quot;small&quot;,&quot;again&quot;,&quot;just&quot;,  
    &quot;lot&quot;,&quot;lots&quot;,&quot;some&quot;,&quot;many&quot;,&quot;so&quot;,&quot;first&quot;,&quot;second&quot;,&quot;last&quot;,&quot;early&quot;,&quot;late&quot;,&quot;sweet&quot;,&quot;new&quot;,&quot;old&quot;,&quot;young&quot;  
    };  
      
    char verb[1000][30] = {  
    &quot;must&quot;,&quot;might&quot;,&quot;should&quot;,&quot;can&quot;,&quot;could&quot;,&quot;may&quot;,  
    &quot;do&quot;,&quot;did&quot;,&quot;play&quot;,&quot;like&quot;,&quot;want&quot;,&quot;love&quot;,&quot;go&quot;,&quot;went&quot;,&quot;gone&quot;,&quot;say&quot;,&quot;said&quot;,&quot;sais&quot;,&quot;test&quot;,&quot;make&quot;,&quot;get&quot;,&quot;getting&quot;,&quot;got&quot;,  
    &quot;have&quot;,&quot;has&quot;,&quot;had&quot;,&quot;will&quot;,&quot;shall&quot;,&quot;use&quot;,&quot;try&quot;,&quot;read&quot;,&quot;write&quot;,&quot;see&quot;,&quot;saw&quot;,&quot;seen&quot;,&quot;look&quot;,&quot;smell&quot;,&quot;smelt&quot;,&quot;hear&quot;,&quot;heard&quot;,  
    &quot;exciting&quot;,&quot;intersting&quot;,&quot;came&quot;,&quot;find&quot;,&quot;found&quot;,&quot;wash&quot;,&quot;clean&quot;,&quot;sleep&quot;,&quot;eat&quot;,&quot;drink&quot;,&quot;take&quot;,&quot;took&quot;,&quot;taken&quot;,&quot;fly&quot;,&quot;cook&quot;  
    &quot;give&quot;,&quot;gave&quot;,&quot;given&quot;,&quot;hide&quot;,&quot;hid&quot;,&quot;hidden&quot;,&quot;swim&quot;,&quot;swam&quot;,&quot;run&quot;,&quot;walk&quot;,&quot;walked&quot;,&quot;pay&quot;,&quot;paid&quot;  
    };  
      
    char suffix[1000][30] = {  
    &quot;s&quot;,&quot;es&quot;,&quot;ing&quot;,&quot;ed&quot;,&quot;ies&quot;,&quot;ly&quot;,&quot;ty&quot;,&quot;teen&quot;,&quot;er&quot;,&quot;ers&quot;,&quot;tant&quot;,&quot;tent&quot;,&quot;ists&quot;,&quot;ve&quot;,  
    &quot;ever&quot;,&quot;room&quot;,&quot;ious&quot;,&quot;ish&quot;,&quot;tion&quot;,&quot;age&quot;,&quot;ache&quot;,&quot;ster&quot;,&quot;ant&quot;,&quot;nal&quot;,&quot;tal&quot;,&quot;cal&quot;,&quot;sal&quot;,&quot;ple&quot;  
    };  
      
    char prefix[1000][30] = {  
    &quot;dis&quot;,&quot;des&quot;,&quot;pre&quot;,&quot;in&quot;,&quot;im&quot;,&quot;un&quot;,&quot;anti&quot;,&quot;sub&quot;,&quot;con&quot;,&quot;com&quot;,&quot;under&quot;,&quot;over&quot;,&quot;ex&quot;,  
    &quot;re&quot;,&quot;ist&quot;,&quot;ists&quot;,&quot;en&quot;,&quot;trans&quot;,&quot;bi&quot;,&quot;mono&quot;,&quot;tri&quot;,&quot;octo&quot;,&quot;inter&quot;,&quot;ele&quot;,&quot;tele&quot;  
    };  
      
    bool rec_upper[10000];  
    int val[30];  
      
    int trans(char c, int v)  
    {  
        if (!isalpha(c)) return c;  
        int a = c;  
        if (islower(c)) { a += v; if (a&gt;'z') a-=26; }  
        else { a += v; if (a&gt;'Z') a-=26; }  
        return a;  
    }  
      
    int sum[26], bd[26];  
    void deal_word(int len, int totwd)  
    {  
        memset(d,0,sizeof d);  
        for (int x = 0; x&lt;26; ++x)  
        {  
            int xflag = 0;  
            for (int i = 0; i&lt;len; ++i) d[i] = trans(word[i], x);  
            if (rec_upper[0] &amp;&amp; len==1 &amp;&amp; d[0]!='i') { val[x]-=99999; continue; }   
            for (int i = 0; dict[i][0]; ++i)  
                if (strcmp(dict[i], d)==0)  
                {  
                    if (len==1) val[x] += 5;  
                    else if (len&gt;5) val[x] += 99999;  
                    else if (len&gt;=5) val[x] += len*len*len*15;  
                    else val[x] += len*20;  
                    sum[x]++;  
                }  
            for (int i = 0; ad[i][0]; ++i)  
                if (strcmp(ad[i], d)==0)  
                {  
                    if (len==1) val[x] += 5;  
                    else if (len&gt;5) val[x] += 99999;  
                    else if (len&gt;=5) val[x] += len*len*len*15;  
                    else val[x] += len*20;  
                    sum[x]++;  
                }  
            for (int i = 0; noun[i][0]; ++i)  
                if (strcmp(noun[i], d)==0)  
                {  
                    if (len==1) val[x] += 5;  
                    else if (len&gt;5) val[x] += 99999;  
                    else if (len&gt;=5) val[x] += len*len*len*15;  
                    else val[x] += len*20;  
                    sum[x]++;  
                }  
            for (int i = 0; verb[i][0]; ++i)  
                if (strcmp(verb[i], d)==0)  
                {  
                    if (len==1) val[x] += 5;  
                    else if (len&gt;5) val[x] += 99999;  
                    else if (len&gt;=5) val[x] += len*len*len*15;  
                    else val[x] += len*20;  
                    sum[x]++;  
                }  
            for (int i = 0; prefix[i][0]; ++i)  
            {  
                bool flag = 1;  
                for (int j = 0; prefix[i][j]; ++j) if (d[j]!=prefix[i][j]){flag=0;break;}  
                if (flag) val[x] += strlen(prefix[i])*strlen(prefix[i])*strlen(prefix[i])*6;  
            }  
            for (int i = 1, t; suffix[i][0]; --i)  
            {  
                bool flag = 1; t=strlen(suffix[i]);  
                for (int j = 0; j&lt;len&amp;&amp;j&lt;t&amp;&amp;t&lt;=len; ++j) if (d[len-i-1]!=suffix[i][t-j-1]) {flag=0;break;}  
                if (flag) val[x] += t*t*t*6;  
            }  
            for (int i = 0; d[i]; ++i)  
            {  
                u64 h = 0;  
                for (int j = i, k; d[j]; ++j)  
                {  
                    h = h*31+d[j]-'a'+1;  
                    if ((k=ha[h])&gt;4) val[x] += k*k*k*8;  
                }  
            }  
            for (int i = 0; d[i]&amp;&amp;d[i+1]; ++i)  
            {  
                if (rec_upper[i]) continue;  
                if (yuan[d[i]-'a']^yuan[d[i+1]-'a'])  
                    val[x] ++;  
                if (d[i+2] &amp;&amp; yuan[d[i]-'a']==yuan[d[i+1]-'a']&amp;&amp;yuan[d[i]-'a']==yuan[d[i+2]-'a'])  
                {  
                    if(d[i]=='g'&amp;&amp;d[i+1]=='h'&amp;&amp;d[i+2]=='t')continue;  
                    if (yuan[d[i]-'a']) bd[x]+=2;  
                    else bd[x]++;  
                    if (bd[x]&gt;=5) val[x] -= 99999;  
                }  
            }  
        }  
    }  
      
    void deal_string(int len, int xn)  
    {  
        bool flag = 0;  
        for (int i = 0; i&lt;len; ++i)  
            if (isalpha(s[i])) flag = 1;  
        if (!flag) return;  
        int t = 0;  
        for (int i = 0; i&lt;=len; ++i)  
        {  
            if (!isalpha(s[i])) word[t]='\0', deal_word(t, xn), t = 0, memset(word,0,sizeof word);  
            else {  
                if (isupper(s[i])) word[t] = tolower(s[i]), rec_upper[t] = 1, t++;  
                else word[t] = s[i], rec_upper[t] = 0, t++;  
            }  
        }  
    }  
      
    void solve()  
    {  
        memset(buf, 0, sizeof buf);  
        memset(s, 0, sizeof s);  
        memset(sum,0,sizeof sum);  
        memset(bd, 0, sizeof bd);  
        gets(buf);  
        memset(val, 0, sizeof val);  
        int i = 0, j = 0, len = strlen(buf), xn = 1;  
        for (i = 0; i&lt;len; ++i) if(buf[i]==' ') xn++;  
        for (i = j = 0; i&lt;len; i+=j)  
        {  
            while ((buf[i]==' '||buf[i]=='\n'||buf[i]=='\t'||buf[i]=='\r')&amp;&amp;i&lt;len) ++i;  
            for (j = 0; buf[i+j]!=' '&amp;&amp;buf[i+j]!='\n'&amp;&amp;buf[i+j]!='\r'&amp;&amp;buf[i+j]!='\t'&amp;&amp;buf[i+j]; j++) s[j] = buf[i+j];  
            deal_string(j, xn); memset(s, 0, sizeof s);  
        }  
        for (int i = 0; i&lt;26; ++i) if (xn&gt;=10?(sum[i]&gt;=xn/3):(sum[i]&gt;=xn/2)) val[i]+=1234;  
        int opt = 0;  
        for (int i = 1; i&lt;26; ++i) if(val[i]&gt;val[opt]) opt = i;  
        for (i = 0; i&lt;len; ++i) if (isalpha(buf[i])) putchar(trans(buf[i], opt)); else putchar(buf[i]);  
        puts(&quot;&quot;);  
    }  
      
    void GlobalHash()  
    {  
        for (int i = 0; dict[i][0]; ++i)  
        {  
            u64 h = 0;  
            if (strlen(dict[i])&lt;3) continue;  
            for (int j = 0; dict[i][j]; ++j) h = h*31+dict[i][j]-'a'+1;  
            ha[h] = strlen(dict[i]);  
        }  
        for (int i = 0; noun[i][0]; ++i)  
        {  
            u64 h = 0;  
            if (strlen(noun[i])&lt;3) continue;  
            for (int j = 0; noun[i][j]; ++j) h = h*31+noun[i][j]-'a'+1;  
            ha[h] = strlen(noun[i]);  
        }  
        for (int i = 0; verb[i][0]; ++i)  
        {  
            u64 h = 0;  
            if (strlen(verb[i])&lt;3) continue;  
            for (int j = 0; verb[i][j]; ++j) h = h*31+verb[i][j]-'a'+1;  
            ha[h] = strlen(verb[i]);  
        }  
        for (int i = 0; ad[i][0]; ++i)  
        {  
            u64 h = 0;  
            if (strlen(ad[i])&lt;3) continue;  
            for (int j = 0; ad[i][j]; ++j) h = h*31+ad[i][j]-'a'+1;  
            ha[h] = strlen(ad[i]);  
        }  
    }  
      
    int main()  
    {  
        yuan[0]=yuan['e'-'a']=yuan['i'-'a']=yuan['o'-'a']=yuan['u'-'a']=1;  
        GlobalHash();  
        rep(i, 1, 10)  
            solve();  
        return 0;  
    }  <pre><h2>Problem2154</h2><pre>#include &lt;cstdio&gt;

#define mod 20101009
#define N 10000007
int mu[N], prime[N], s[N];
bool vis[N];

inline long long mmo(long long x) {
	x %= mod;
	if (x &lt; 0) x += mod;
	return x;
}

inline long long mi(long long a, long long b) {
	return a &lt; b ? a : b;
}

void Init(int n) {
	int *ep = prime, i, *j, t;
	mu[1] = 1;
	for (i = 2; i &lt;= n; ++i) {
		if (!vis[i])
			mu[*ep++ = i] = -1;
		for (j = prime; j &lt; ep; ++j) {
			if ((long long)i * (*j) &gt; n)
				break;
			t = i * (*j);
			vis[t] = true;
			if (i % *j)
				mu[t] = -mu[i];
			else {
				mu[t] = 0;
				break;
			}
		}
	}
	for (i = 1; i &lt;= n; ++i)
		s[i] = mmo(s[i - 1] + (long long)i * i * mu[i] % mod);
}

long long Sum(long long x, long long y) {
	return ( (x * ( x + 1 ) / 2) % mod ) *( ( y * ( y + 1 ) / 2 ) % mod ) % mod;
}

long long F(long long x, long long y) {
	static long long ret, i, j;
	static long long _x, _y;
	if (y &lt; x)
		x ^= y ^= x ^= y;
	for (i = 1, ret = 0; i &lt;= x; i = j + 1) {
		_x = x / i, _y = y / i;
		j = mi(x / _x, y / _y);
		ret = mmo(ret + (s[j] - s[i - 1]) * Sum(_x, _y) % mod);
	}
	return ret;
}

int main() {
	long long _n, _m;
	long long i, j, ans = 0, n, m;
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	if (m &lt; n) n ^= m ^= n ^= m;
	Init(n);
	for (i = 1; i &lt;= n; i = j + 1) {
		_n = n / i, _m = m / i;
		j = mi(n / _n, m / _m);
		ans = mmo(ans + (i + j) * (j - i + 1LL) / 2 % mod * F(_n, _m) % mod);
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem2190</h2><pre>#include &lt;cstdio&gt;
const int N = 40003;
int main() {
	static unsigned int n, i, j, fac[N], phi[N];
	static unsigned long long ans;
	scanf(&quot;%u&quot;, &amp;n);
	for (i = 2; i &lt; n; ++i)
		if (!fac[i]) for (j = i; j &lt; n; j += i)
			fac[j] = i;
	phi[1] = 1;
	for (i = 2; i &lt; n; ++i)
		if (fac[i] ^ fac[j = i / fac[i]])
			phi[i] = phi[j] * (fac[i] - 1);
		else phi[i] = phi[j] * fac[i];
	for (i = 1; i &lt; n; ++i)
		ans += phi[i];
	ans = ans * 2 + 1;
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}
<pre><h2>Problem2208</h2><pre>#include &lt;cstdio&gt;

struct edge {
	int to;
	edge *nxt;
} edge_mset[2000 * 2000 + 3], *g[2002], *cedge = edge_mset;

int main() {

	int n;
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 0; i &lt; n; ++i) {
		static char s[2002];
		scanf(&quot;%s&quot;, s);
		for (int j = 0; j &lt; n; ++j)
			if (s[j] == '1') {
				*cedge = (edge) {j, g[i]};
				g[i] = cedge++;
			}
	}

	int ans = 0;
	for (int i = 0; i &lt; n; ++i) {
		static int q[2002], *l, *r, v[2002], _v = 0, u;
		v[i] = ++_v;
		l = r = q;
		*r++ = i;
		while (l &lt; r) {
			u = *l++;
			++ans;
			for (edge *it = g[u]; it; it = it-&gt;nxt)
				if (v[it-&gt;to] ^ _v) v[*r++ = it-&gt;to] = _v;
		}
		//printf(&quot;%d\n&quot;, ans);
	}

	printf(&quot;%d\n&quot;, ans);

	return 0;
}
<pre><h2>Problem2226</h2><pre>#include &lt;cstdio&gt;
#define N 1000003
int main() {
	static int n, __, i, j, k;
	static long long ans[N], phi[N];
	for (i = 2; i &lt; N; ++i)
		if (!phi[i]) for (j = i; j &lt; N; j += i) {
				if (!phi[j]) phi[j] = j;
				phi[j] = phi[j] / i * (i - 1);
			}
	ans[1] = 1LL;
	for (i = 2; i &lt; N; ++i)
		ans[i] = ((long long)i * i * phi[i] &gt;&gt; 1) + i;
	for (i = 2; ; ++i) {
		j = i * i;
		if (j &gt; N) break;
		ans[j] += (long long)j * i * phi[i] &gt;&gt; 1;
		for (j += i, k = i + 1; j &lt; N; j += i, ++k)
			ans[j] += ((long long)j * phi[i] * i &gt;&gt; 1) + ((long long)j * phi[k] * k &gt;&gt; 1);
	}
	scanf(&quot;%d&quot;, &amp;__);
	while (__--) scanf(&quot;%d&quot;, &amp;n), printf(&quot;%lld\n&quot;, ans[n]);
	return 0;
}
<pre><h2>Problem2242</h2><pre>#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
typedef long long ll;
const char *NO = &quot;Orz, I cannot find x!&quot;;
void exgcd(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;g) {
	if (!b) x = 1, y = 0, g = a;
	else {
		exgcd(b, a%b, y, x, g);
		y -= a / b * x;
	}
}
ll pw(ll a, ll b, ll p) {
	static ll r;
	for (r = 1; b; b &gt;&gt;= 1, a = a * a % p)
		if (b &amp; 1) r = r * a % p;
	return r;
}
map &lt; ll, ll &gt; hash;
#define WW while(__--)
int main() {
	ll y, z, p, i, j, g, x, m, inv, e;
	int __, type;
	scanf(&quot;%d%d&quot;, &amp;__, &amp;type);
	if (type == 1) WW {
		scanf(&quot;%lld%lld%lld&quot;, &amp;y, &amp;z, &amp;p);
		printf(&quot;%lld\n&quot;, pw(y, z, p));
	} else if (type == 2) WW {
		scanf(&quot;%lld%lld%lld&quot;, &amp;y, &amp;z, &amp;p);
		exgcd(y, p, i, j, g);
		if (z % g) puts(NO);
		else {
			x = z / g * i, p /= g;
			printf(&quot;%lld\n&quot;, (x % p + p) % p);
		}
	} else WW {
		scanf(&quot;%lld%lld%lld&quot;, &amp;y, &amp;z, &amp;p);
		y %= p, z %= p;
		if (!y &amp;&amp; !z) puts(&quot;1&quot;);
		else if (!y) puts(NO);
		else {
			m = sqrt(p);
			inv = pw(y, p - m - 1, p);
			e = 1LL;
			hash.clear();
			hash[1] = m + 1;
			for (i = 1; i &lt;= m; ++i) {
				e = e * y % p;
				hash[e] = i;
			}
			for (x = -1, i = 0; i &lt; m &amp;&amp; x &lt; 0; ++i) {
				if (j = hash[z]) {
					if (m &lt; j) 
						j = 0;
					x = i * m + j;
				}
				z = z * inv % p;
			}
			if (~x) 
				printf(&quot;%lld\n&quot;, x);
			else puts(NO);
		}
	}
	return 0;
}<pre><h2>Problem2242</h2><pre>#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
typedef long long ll;
const char *NO = &quot;Orz, I cannot find x!&quot;;
void exgcd(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;g) {
	if (!b) x = 1, y = 0, g = a;
	else {
		exgcd(b, a%b, y, x, g);
		y -= a / b * x;
	}
}
ll pw(ll a, ll b, ll p) {
	static ll r;
	for (r = 1; b; b &gt;&gt;= 1, a = a * a % p)
		if (b &amp; 1) r = r * a % p;
	return r;
}
map &lt; ll, ll &gt; hash;
#define WW while(__--)
int main() {
	ll y, z, p, i, j, g, x, m, inv, e;
	int __, type;
	scanf(&quot;%d%d&quot;, &amp;__, &amp;type);
	if (type == 1) WW {
		scanf(&quot;%lld%lld%lld&quot;, &amp;y, &amp;z, &amp;p);
		printf(&quot;%lld\n&quot;, pw(y, z, p));
	} else if (type == 2) WW {
		scanf(&quot;%lld%lld%lld&quot;, &amp;y, &amp;z, &amp;p);
		exgcd(y, p, i, j, g);
		if (z % g) puts(NO);
		else {
			x = z / g * i, p /= g;
			printf(&quot;%lld\n&quot;, (x % p + p) % p);
		}
	} else WW {
		scanf(&quot;%lld%lld%lld&quot;, &amp;y, &amp;z, &amp;p);
		y %= p, z %= p;
		if (!y &amp;&amp; !z) puts(&quot;1&quot;);
		else if (!y) puts(NO);
		else {
			m = sqrt(p);
			inv = pw(y, p - m - 1, p);
			e = 1LL;
			hash.clear();
			hash[1] = m + 1;
			for (i = 1; i &lt;= m; ++i) {
				e = e * y % p;
				hash[e] = i;
			}
			for (x = -1, i = 0; i &lt; m &amp;&amp; x &lt; 0; ++i) {
				if (j = hash[z]) {
					if (m &lt; j) 
						j = 0;
					x = i * m + j;
				}
				z = z * inv % p;
			}
			if (~x) 
				printf(&quot;%lld\n&quot;, x);
			else puts(NO);
		}
	}
	return 0;
}
<pre><h2>Problem2242</h2><pre>#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
using namespace std;
#define ll long long
#define ni (c&lt;'0'|'9'&lt;c)
inline ll geti() {
	register ll a; register char c;
	while(c=getchar(),ni);a=c-'0';
	while(c=getchar(),!ni)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
char buf[20];
template&lt;class T&gt;
inline void output(T a) {
	if(a==0) {puts(&quot;0&quot;); return;}
	register char *s=buf+18;
	while(a) *s--=a%10+'0',a/=10;
	puts(s+1);
}
/*template*/
#define CANT &quot;Orz, I cannot find x!&quot;
inline ll pow(ll a,ll b,ll p) {
	ll ret=1; a%=p;
	for(;b;a=a*a%p,b&gt;&gt;=1) if(b&amp;1) ret=ret*a%p;
	return ret;
}
void exgcd(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;g) {
	if(!b) {x=1,y=0,g=a; return;}
	exgcd(b,a%b,y,x,g); y-=a/b*x;
}
map&lt;ll,ll&gt;mp;
int main() {
	ll y,z,p,i,j,g,x,m,inv,e; int K,T;
	T=geti(),K=geti();
	if(K==1) while(T--) {
			y=geti(),z=geti(),p=geti();
			output(pow(y,z,p));
		}
	else if(K==2) while(T--) {
			y=geti(),z=geti(),p=geti();
			exgcd(y,p,i,j,g);
			if(z%g) {puts(CANT); continue;}
			x=z/g*i,p/=g;
			output((x%p+p)%p);
		}
	else while(T--){
		y=geti(),z=geti(),p=geti(); y%=p,z%=p;
		if(!y&amp;&amp;!z) {puts(&quot;1&quot;); continue;}
		if(!y) {puts(CANT); continue;}
		m=sqrt(p);inv=pow(y,p-m-1,p),e=1LL;
		mp.clear(); mp[1]=m+1;
		for(i=1;i&lt;=m;++i) mp[e=(ll)e*y%p]=i;
		for(x=-1,i=0;i&lt;m&amp;&amp;x&lt;0;++i) {
			if(j=mp[z]) {
				if(j&gt;m) j=0; x=i*m+j;
			} z=z*inv%p;
		}
		if(~x) output(x); else puts(CANT);
	}
	return 0;
}
<pre><h2>Problem2242</h2><pre>#include &lt;map&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;

typedef long long i64;

i64 ModPow(i64 a, i64 b, i64 mod) {
  i64 res = 1ll;
  a %= mod;
  while (b) {
    if (b &amp; 1) res = res * a % mod;
    a = a * a % mod;
    b &gt;&gt;= 1;
  }
  return res;
}

void exgcd(i64 a, i64 b, i64 &amp;x, i64 &amp;y, i64 &amp;g) {
  if (b == 0) {
    g = a;
    x = 1;
    y = 0;
  } else {
    exgcd(b, a % b, y, x, g);
    y -= a / b * x;
  }
}

#define CANT &quot;Orz, I cannot find x!&quot;

int main() {
  int T, K, y, z, p;
  scanf(&quot;%d%d&quot;, &amp;T, &amp;K);
  if (K == 1) {
    while (T--) {
      scanf(&quot;%d%d%d&quot;, &amp;y, &amp;z, &amp;p);
      printf(&quot;%lld\n&quot;, ModPow(y, z, p));
    }
  } else if (K == 2) {
    i64 i, j, g, x;
    while (T--) {
      scanf(&quot;%d%d%d&quot;, &amp;y, &amp;z, &amp;p);
      exgcd(y, p, i, j, g);
      if (z % g) {
        puts(CANT);
        continue;
      }
      x = z / g * i;
      p /= g;
      printf(&quot;%lld\n&quot;, (x % p + p) % p);
    }
  } else if (K == 3) {
    int x, i, j;
    i64 m, inv, e;
    std::map&lt;i64, i64&gt; f;
    while (T--) {
      scanf(&quot;%d%d%d&quot;, &amp;y, &amp;z, &amp;p);
      y %= p;
      z %= p;
      if (!y &amp;&amp; !z) {
        puts(&quot;1&quot;);
        continue;
      }
      if (!y) {
        puts(CANT);
        continue;
      }
      e = 1ll;
      m = (i64)sqrt(p);
      inv = ModPow(y, p - m - 1, p);
      f.clear();
      f[1] = m + 1;
      for (i = 1; i &lt;= m; i++)
        f[e = e * y % p] = i;
      for (x = -1, i = 0; i &lt; m &amp;&amp; x &lt; 0; i++) {
        j = f[z];
        if (j != 0) {
          if (j &gt; m)
            j = 0;
          x = i * m + j;
        }
        z = z * inv % p;
      }
      if (x == -1) puts(CANT);
      else printf(&quot;%d\n&quot;, x);
    }
  } else return -1;
  return 0;
}
<pre><h2>Problem2243</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define N 100005
struct edge {
	int t;
	edge *n;
	edge(int t = 0, edge *n = NULL) :
		t(t), n(n) {}
} me[N &lt;&lt; 1], *g[N], *ce = me;
#define FOR(u) for (edge *it = g[u]; it; it = it-&gt;n)
#define adde(a, b) (*ce = edge(b, g[a]), g[a] = ce++)

typedef int arr[N];
arr tp, fa, son, sz, dep, in, color, _color;
int dfn;
void d1(int u) {
	sz[u] = 1;
	FOR(u) if (it-&gt;t ^ fa[u]) {
		fa[it-&gt;t] = u;
		dep[it-&gt;t] = dep[u] + 1;
		d1(it-&gt;t);
		if (sz[son[u]] &lt; sz[it-&gt;t])
			son[u] = it-&gt;t;
		sz[u] += sz[it-&gt;t];
	}
}
void d2(int u, int anc) {
	tp[u] = anc;
	in[u] = ++dfn;
	if (son[u]) d2(son[u], anc);
	FOR(u) if (!tp[it-&gt;t])
		d2(it-&gt;t, it-&gt;t);
}

struct node {
	int l, r, lc, rc, sum, lyc;
	node(int l = 0, int r = 0, int lc = 0, int rc = 0, int sum = 0, int lyc = -1):
		l(l), r(r), lc(lc), rc(rc), sum(sum), lyc(lyc) {}
	bool inrange(const int &amp;x, const int &amp;y) const {
		return x &lt;= l &amp;&amp; r &lt;= y;
	}
}C[N &lt;&lt; 2];
#define ls u &lt;&lt; 1
#define rs u &lt;&lt; 1 | 1

inline void pu(int u) {
	C[u].sum = C[ls].sum + C[rs].sum - (C[ls].rc == C[rs].lc);
	C[u].lc = C[ls].lc, C[u].rc = C[rs].rc;
}

inline void pd(int u) {
	if (~C[u].lyc) {
		int &amp;c = C[u].lyc;
		C[ls].lc = C[ls].rc = C[ls].lyc = c;
		C[rs].lc = C[rs].rc = C[rs].lyc = c;
		C[ls].sum = C[rs].sum = 1;
		c = -1;
	}
}

void build(int u, int l, int r) {
	if (l ^ r) {
		C[u] = node(l, r);
		int mid = (l + r) &gt;&gt; 1;
		build(ls, l, mid);
		build(rs, mid + 1, r);
		pu(u);
	} else
		C[u] = node(l, r, _color[l], _color[l], 1);
}

void upd(int u, const int &amp;x, const int &amp;y, const int &amp;c) {
	if (C[u].inrange(x, y)) {
		C[u].lc = C[u].rc = C[u].lyc = c;
		C[u].sum = 1;
		return;
	}
	int mid = (C[u].l + C[u].r) &gt;&gt; 1;
	pd(u);
	if (x &lt;= mid) upd(ls, x, y, c);
	if (y &gt;  mid) upd(rs, x, y, c);
	pu(u);
}
int query(int u, const int &amp;x, const int &amp;y, int &amp;lc, int &amp;rc) {
	if (C[u].inrange(x, y) || (~C[u].lyc)) {
		lc = C[u].lc;
		rc = C[u].rc;
		return C[u].sum;
	}
	int mid = (C[u].l + C[u].r) &gt;&gt; 1;
	pd(u);
	if (y &lt;= mid) return query(ls, x, y, lc, rc);
	if (x &gt;  mid) return query(rs, x, y, lc, rc);
	int lrc, rlc, sum;
	sum = query(ls, x, y, lc, lrc) + query(rs, x, y, rlc, rc);
	return sum - (lrc == rlc);
}

void modify(int u, int v, const int &amp;c) {
	while (tp[u] ^ tp[v]) {
		if (dep[tp[u]] &lt; dep[tp[v]])
			u ^= v ^= u ^= v;
		upd(1, in[tp[u]], in[u], c);
		u = fa[tp[u]];
	}
	if (dep[u] &lt; dep[v])
		u ^= v ^= u ^= v;
	upd(1, in[v], in[u], c);
}
#define swp(a, b) a ^= b ^= a ^= b
int ask(int u, int v) {
	int sum = 0, ulc = -1, urc = -2, vlc = -3, vrc = -4, lc, rc;
	//query(1, in[v], in[v], vlc, vrc);
	//query(1, in[u], in[u], ulc, urc);
	
	while (tp[u] ^ tp[v]) 
		if (dep[tp[u]] &lt; dep[tp[v]]) {
			sum = sum + query(1, in[tp[v]], in[v], lc, rc);
			if (vlc == rc) --sum;
			vlc = lc;
			v = fa[tp[v]];
		} else {
			sum += query(1, in[tp[u]], in[u], lc, rc);
			if (ulc == rc) --sum;
			ulc = lc;
			u = fa[tp[u]];
		}
	if (dep[u] &lt; dep[v]) {
		swp(u, v);
		swp(ulc, vlc);
		swp(urc, vrc);
	}
	sum += query(1, in[v], in[u], lc, rc);
	if (rc == ulc) --sum;
	if (lc == vlc) --sum;
	return sum;
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, m;
	char ops[3];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; ++i)
		scanf(&quot;%d&quot;, color + i);
	for (int i = 1, u, v; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		adde(u, v);
		adde(v, u);
	}
	d1(1);
	d2(1, 1);
	for (int i = 1; i &lt;= n; ++i)
		_color[in[i]] = color[i];
	build(1, 1, n);
	for (int u, v, c; m; --m) {
		scanf(&quot;%s%d%d&quot;, ops, &amp;u, &amp;v);
		if (*ops == 'C') {
			scanf(&quot;%d&quot;, &amp;c);
			modify(u, v, c);
		} else
			printf(&quot;%d\n&quot;, ask(u, v));
	}
	return 0;
}















<pre><h2>Problem2286</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int maxn(250005);
typedef int arr[maxn];

struct edge {
	int to, cost;
	edge *nxt;
} edge_mset[maxn &lt;&lt; 1], *g[maxn], *cedge = edge_mset;

inline void add_edge(int u, int v, int w = 0) {
	*cedge = (edge) {v, w, g[u]};
	g[u] = cedge++;
}

int n, m, _clock;
bool mark[maxn];
long long dp[maxn], minw[maxn];
arr size, dep, son, fa, top, stk, h, in;

void d1(int u) {
	int v;
	size[u] = 1;
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if ((v = it-&gt;to) ^ fa[u]) {
			fa[v] = u;
			dep[v] = dep[u] + 1;
			minw[v] = std::min(minw[u], (long long)it-&gt;cost);
			d1(v);
			if (size[son[u]] &lt; size[v])
				son[u] = v;
			size[u] += size[v];
		}
}

void d2(int u, int anc) {
	top[u] = anc;
	in[u] = ++_clock;
	if (son[u]) d2(son[u], anc);
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if (!top[it-&gt;to]) d2(it-&gt;to, it-&gt;to);
}

inline int lca(int u, int v) {
	while (top[u] ^ top[v]) (dep[top[u]] &lt; dep[top[v]]) ? v = fa[top[v]] : u = fa[top[u]];
	return dep[u] &lt; dep[v] ? u : v;
}

inline bool cmp(const int &amp;a, const int &amp;b) {
	return in[a] &lt; in[b];
}

void dfs(int u) {
	if (mark[u]) {
		dp[u] = minw[u];
		for (edge *it = g[u]; it; it = it-&gt;nxt)
			dfs(it-&gt;to);
	} else {
		long long t(0);
		for (edge *it = g[u]; it; it = it-&gt;nxt) {
			dfs(it-&gt;to);
			t += dp[it-&gt;to];
		}
		dp[u] = t &lt; minw[u] ? t : minw[u];
	}
	g[u] = NULL;
}

inline void solve() {
	scanf(&quot;%d&quot;, &amp;m);
	for (register int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, h + i);
		mark[h[i]] = true;
	}
	cedge = edge_mset;
	std::sort(h + 1, h + m + 1, cmp);
	int top = 0;
	for (register int i = 1; i &lt;= m; ++i)
		if (top) {
			for (int u = h[i], x = lca(u, stk[top]); in[x] &lt; in[stk[top]]; )
				if (in[x] &gt;= in[stk[top - 1]]) {
					add_edge(x, stk[top--]);
					if (stk[top] ^ x) stk[++top] = x;
					break;
				} else
					add_edge(stk[top - 1], stk[top]), --top;
			stk[++top] = h[i];
		} else
			stk[++top] = h[i];
	while (top &gt; 1)
		add_edge(stk[top - 1], stk[top]), --top;
	dfs(stk[1]);
	for (register int i = 1; i &lt;= m; ++i)
		mark[h[i]] = false;
	printf(&quot;%lld\n&quot;, dp[stk[1]]);
}

int main() {
	int u, v, w;
	scanf(&quot;%d&quot;, &amp;n);
	for (register int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		add_edge(u, v, w);
		add_edge(v, u, w);
	}
	minw[1] = 1LL &lt;&lt; 61;
	d1(1), d2(1, 1);
	scanf(&quot;%d&quot;, &amp;w);
	memset(g, 0, sizeof g);
	while (w--) solve();
	return 0;
}<pre><h2>Problem2301</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int N = 5e4 + 10;
int s[N], mu[N], prime[N], cnp;
void init() {
	memset(s, 1, sizeof s);
	mu[1] = 1;
	int i, j, cnp = 0;
	long long t;
	for (i = 2; i &lt; N; ++i) {
		if (s[i]) mu[i] = -1, prime[cnp++] = i;
		for (j = 0; j &lt; cnp; ++j) {
			t = i * prime[j];
			if (t &gt; N) break;
			s[t] = 0;
			if (i % prime[j]) mu[t] = -mu[i];
			else mu[t] = 0, j = cnp;
		}
	}
	s[0] = 0;
	for (i = 1; i &lt; N; ++i) s[i] = s[i-1] + mu[i];
}
int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}
long long cal(int n, int m) {
	if (n &gt; m) n ^= m ^= n ^= m;
	static long long r;
	static int i, j;
	for (r = 0, i = 1; i &lt;= n; i = j + 1) {
		j = min(n / (n / i), m / (m / i));
		r += (long long)(s[j] - s[i - 1]) * (n / i) * (m / i);
	}
	return r;
}
int main() {
	init();
	int a, b, c, d, k, __;
	scanf(&quot;%d&quot;, &amp;__);
	while (__--) {
		scanf(&quot;%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k);
		a = (a - 1) / k;
		b = b / k;
		c = (c - 1) / k;
		d = d / k;
		printf(&quot;%lld\n&quot;, cal(b, d) + cal(a, c) - cal(a, d) - cal(b, c));
	}
	return 0;
}
<pre><h2>Problem2330</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline void cmin(int&amp;a,const int&amp;b) {if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b) {if(a&lt;b)a=b;}
#define N 100005
struct edge{int to;edge*nt;}ME[N&lt;&lt;1],*CE=ME,*h1[N],*h2[N];
inline void add1(int a,int b) {//a&lt;b
	CE-&gt;to=b,CE-&gt;nt=h1[a],h1[a]=CE++;
}
inline void add2(int a,int b) {//a&lt;=b
	CE-&gt;to=b,CE-&gt;nt=h2[a],h2[a]=CE++;
}
struct e{int to,v;e*nt;}me[N&lt;&lt;1],*ce=me,*he[N];
inline void adde(int a,int b,int c) {
	ce-&gt;to=b,ce-&gt;nt=he[a],ce-&gt;v=c,he[a]=ce++;
}
int dfn[N],bel[N],bcnt,Stack[N],tp,_clock,n,deg[N],size[N];
int tarjan(int u) {
	int low=dfn[u]=++_clock,v;
	Stack[++tp]=u;
	for(edge*it=h2[u];it;it=it-&gt;nt)
		if(!dfn[v=it-&gt;to]) cmin(low,tarjan(v));
		else if(!bel[v]) cmin(low,dfn[v]);
	if(low==dfn[u]) {
		++bcnt;
		do {
			v=Stack[tp--];
			bel[v]=bcnt;
			++size[bcnt];
		} while(u^v);
	}
	return low;
}
bool judge() {
	int cnt=0,i;
	edge*it;
	for(i=1;i&lt;=n;++i)
		if(!deg[i])Stack[++tp]=i,++cnt;
	while(tp)
		for(it=h1[Stack[tp--]];it;it=it-&gt;nt)
			if(!(--deg[it-&gt;to]))Stack[++tp]=it-&gt;to,++cnt;
	return cnt==n;
}
int val[N];
long long tpsort() {
	long long ret=0;
	int i,u,v,cnt=0; e*it;
	for(i=1;i&lt;=bcnt;++i)
		if(!deg[i])Stack[++tp]=i,val[i]=1;
	while(tp) {
		u=Stack[tp--]; ++cnt;
		ret+=(long long)val[u]*size[u];
		for(it=he[u];it;it=it-&gt;nt) {
			v=it-&gt;to;
			cmax(val[v],val[u]+it-&gt;v);
			if(!(--deg[v])) Stack[++tp]=v;
		}
	}
	if(cnt^bcnt) return -1LL;
	else return ret;
}
//1:a&lt;b 2:a&lt;=b;
int main() {
	int a,b,x,k;
	edge*it;
	n=gi(),k=gi();
	while(k--) {
		x=gi(),a=gi(),b=gi();
		if(x==1) add2(a,b),add2(b,a);
		else if(x==2) add1(a,b),++deg[b];
		else if(x==3) add2(b,a);
		else if(x==4) add1(b,a),++deg[a];
		else add2(a,b);
	}
	if(!judge()) return puts(&quot;-1&quot;),0;
	for(a=1;a&lt;=n;++a)if(!dfn[a])tarjan(a);
	for(a=1;a&lt;=n;++a) {
		for(it=h1[a];it;it=it-&gt;nt)
			if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],1),++deg[bel[b]];
		for(it=h2[a];it;it=it-&gt;nt)
			if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],0),++deg[bel[b]];
	}
	printf(&quot;%lld\n&quot;,tpsort());
	return 0;
}
<pre><h2>Problem2330</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline void cmin(int&amp;a,const int&amp;b) {if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b) {if(a&lt;b)a=b;}
#define N 100005
struct edge{int to;edge*nt;}ME[N&lt;&lt;1],*CE=ME,*h1[N],*h2[N];
inline void add1(int a,int b) {//a&lt;b
	CE-&gt;to=b,CE-&gt;nt=h1[a],h1[a]=CE++;
}
inline void add2(int a,int b) {//a&lt;=b
	CE-&gt;to=b,CE-&gt;nt=h2[a],h2[a]=CE++;
}
struct e{int to,v;e*nt;}me[N&lt;&lt;1],*ce=me,*he[N];
inline void adde(int a,int b,int c) {
	ce-&gt;to=b,ce-&gt;nt=he[a],ce-&gt;v=c,he[a]=ce++;
}
int dfn[N],bel[N],bcnt,Stack[N],tp,_clock,n,deg[N],size[N];
int tarjan(int u) {
	int low=dfn[u]=++_clock,v;
	Stack[++tp]=u;
	for(edge*it=h2[u];it;it=it-&gt;nt)
		if(!dfn[v=it-&gt;to]) cmin(low,tarjan(v));
		else if(!bel[v]) cmin(low,dfn[v]);
	if(low==dfn[u]) {
		++bcnt;
		do {
			v=Stack[tp--];
			bel[v]=bcnt;
			++size[bcnt];
		} while(u^v);
	}
	return low;
}
int val[N];
long long tpsort() {
	long long ret=0;
	int i,u,v,cnt=0; e*it;
	for(i=1;i&lt;=bcnt;++i)
		if(!deg[i])Stack[++tp]=i,val[i]=1;
	while(tp) {
		u=Stack[tp--]; ++cnt;
		ret+=(long long)val[u]*size[u];
		for(it=he[u];it;it=it-&gt;nt) {
			v=it-&gt;to;
			cmax(val[v],val[u]+it-&gt;v);
			if(!(--deg[v])) Stack[++tp]=v;
		}
	}
	if(cnt^bcnt) return -1LL;
	else return ret;
}
//1:a&lt;b 2:a&lt;=b;
int main() {
	int a,b,x,k;
	edge*it;
	n=gi(),k=gi();
	while(k--) {
		x=gi(),a=gi(),b=gi();
		if(x==1) add2(a,b),add2(b,a);
		else if(x==2) add1(a,b);
		else if(x==3) add2(b,a);
		else if(x==4) add1(b,a);
		else add2(a,b);
	}
	for(a=1;a&lt;=n;++a)if(!dfn[a])tarjan(a);
	for(a=1;a&lt;=n;++a) {
		for(it=h1[a];it;it=it-&gt;nt)
			if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],1),++deg[bel[b]];
			else return puts(&quot;-1&quot;),0;
		for(it=h2[a];it;it=it-&gt;nt)
			if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],0),++deg[bel[b]];
	}
	printf(&quot;%lld\n&quot;,tpsort());
	return 0;
}
<pre><h2>Problem2330</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline void cmin(int&amp;a,const int&amp;b) {if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b) {if(a&lt;b)a=b;}
#define N 100005
struct edge{int to;edge*nt;}ME[N&lt;&lt;1],*CE=ME,*h1[N],*h2[N];
inline void add1(int a,int b) {//a&lt;b
	CE-&gt;to=b,CE-&gt;nt=h1[a],h1[a]=CE++;
}
inline void add2(int a,int b) {//a&lt;=b
	CE-&gt;to=b,CE-&gt;nt=h2[a],h2[a]=CE++;
}
struct e{int to,v;e*nt;}me[N&lt;&lt;1],*ce=me,*he[N];
inline void adde(int a,int b,int c) {
	ce-&gt;to=b,ce-&gt;nt=he[a],ce-&gt;v=c,he[a]=ce++;
}
int dfn[N],bel[N],bcnt,Stack[N],tp,_clock,n,deg[N],size[N];
int tarjan(int u) {
	int low=dfn[u]=++_clock,v;
	Stack[++tp]=u;
	for(edge*it=h2[u];it;it=it-&gt;nt)
		if(!dfn[v=it-&gt;to]) cmin(low,tarjan(v));
		else if(!bel[v]) cmin(low,dfn[v]);
	if(low==dfn[u]) {
		++bcnt;
		do {
			v=Stack[tp--];
			bel[v]=bcnt;
			++size[bcnt];
		} while(u^v);
	}
	return low;
}
int val[N];
inline long long tpsort() {
	long long ret=0;
	int i,u,v,cnt=0; e*it;
	for(i=1;i&lt;=bcnt;++i)
		if(!deg[i])Stack[++tp]=i,val[i]=1;
	while(tp) {
		u=Stack[tp--]; ++cnt;
		ret+=(long long)val[u]*size[u];
		for(it=he[u];it;it=it-&gt;nt) {
			v=it-&gt;to;
			cmax(val[v],val[u]+it-&gt;v);
			if(!(--deg[v])) Stack[++tp]=v;
		}
	}
	if(cnt^bcnt) return -1LL;
	else return ret;
}
//1:a&lt;b 2:a&lt;=b;
int main() {
	int a,b,x,k;
	edge*it;
	n=gi(),k=gi();
	while(k--) {
		x=gi(),a=gi(),b=gi();
		if(x==1) add2(a,b),add2(b,a);
		else if(x==2) add1(a,b);
		else if(x==3) add2(b,a);
		else if(x==4) add1(b,a);
		else add2(a,b);
	}
	for(a=1;a&lt;=n;++a)if(!dfn[a])tarjan(a);
	for(a=1;a&lt;=n;++a) {
		for(it=h1[a];it;it=it-&gt;nt)
			if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],1),++deg[bel[b]];
			else return puts(&quot;-1&quot;),0;
		for(it=h2[a];it;it=it-&gt;nt)
			if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],0),++deg[bel[b]];
	}
	printf(&quot;%lld\n&quot;,tpsort());
	return 0;
}
<pre><h2>Problem2330</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
    static int a; static char c;
    while(c=getchar(),c&lt;'0');a=c-'0';
    while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return a;
}
inline void cmin(int&amp;a,const int&amp;b) {if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b) {if(a&lt;b)a=b;}
#define N 100005
struct edge{int to;edge*nt;}ME[N&lt;&lt;1],*CE=ME,*h1[N],*h2[N];
inline void add1(int a,int b) {//a&lt;b
    CE-&gt;to=b,CE-&gt;nt=h1[a],h1[a]=CE++;
}
inline void add2(int a,int b) {//a&lt;=b
    CE-&gt;to=b,CE-&gt;nt=h2[a],h2[a]=CE++;
}
struct e{int to,v;e*nt;}me[N&lt;&lt;1],*ce=me,*he[N];
inline void adde(int a,int b,int c) {
    ce-&gt;to=b,ce-&gt;nt=he[a],ce-&gt;v=c,he[a]=ce++;
}
int dfn[N],bel[N],bcnt,Stack[N],tp,_clock,n,deg[N],size[N];
int tarjan(int u) {
    int low=dfn[u]=++_clock,v;
    Stack[++tp]=u;
    for(edge*it=h2[u];it;it=it-&gt;nt)
        if(!dfn[v=it-&gt;to]) cmin(low,tarjan(v));
        else if(!bel[v]) cmin(low,dfn[v]);
    if(low==dfn[u]) {
        ++bcnt;
        do {
            v=Stack[tp--];
            bel[v]=bcnt;
            ++size[bcnt];
        } while(u^v);
    }
    return low;
}
int val[N];
long long tpsort() {
    long long ret=0;
    int i,u,v,cnt=0; e*it;
    for(i=1;i&lt;=bcnt;++i)
        if(!deg[i])Stack[++tp]=i,val[i]=1;
    while(tp) {
        u=Stack[tp--]; ++cnt;
        ret+=(long long)val[u]*size[u];
        for(it=he[u];it;it=it-&gt;nt) {
            v=it-&gt;to;
            cmax(val[v],val[u]+it-&gt;v);
            if(!(--deg[v])) Stack[++tp]=v;
        }
    }
    if(cnt^bcnt) return -1LL;
    else return ret;
}
//1:a&lt;b 2:a&lt;=b;
int main() {
    int a,b,x,k;
    edge*it;
    n=gi(),k=gi();
    while(k--) {
        x=gi(),a=gi(),b=gi();
        if(x==1) add2(a,b),add2(b,a);
        else if(x==2) {if(a^b)add1(a,b);else return puts(&quot;-1&quot;),0;}
        else if(x==3) add2(b,a);
        else if(x==4) {if(a^b)add1(b,a);else return puts(&quot;-1&quot;),0;}
        else add2(a,b);
    }
    for(a=1;a&lt;=n;++a)if(!dfn[a])tarjan(a);
    for(a=1;a&lt;=n;++a) {
        for(it=h1[a];it;it=it-&gt;nt)
            if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],1),++deg[bel[b]];
            else return puts(&quot;-1&quot;),0;
        for(it=h2[a];it;it=it-&gt;nt)
            if(bel[a]^bel[b=it-&gt;to]) adde(bel[a],bel[b],0),++deg[bel[b]];
    }
    printf(&quot;%lld\n&quot;,tpsort());
    return 0;
}
<pre><h2>Problem2331</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int mo=20110520,N=102,P=49373,M=200000;
int n,m,mp[N][N],now,pre,f[2][M],hash[2][M],tot[2],hd[P],nt[M],bin[N];
inline void init() {
	int i,j; char ch;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if(n&lt;m) {
		for(i=1;i&lt;=n;++i)
			for(j=1;j&lt;=m;mp[j++][i]=ch=='_')
				while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
		n^=m^=n^=m;
	} else for(i=1;i&lt;=n;++i)
			   for(j=1;j&lt;=m;mp[i][j++]=ch=='_')
				   while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
}
inline void add(int s,int value) {
	static int i,x;
	for(i=hd[x=s%P];i;i=nt[i])
		if(!(hash[now][i]^s)) {
			f[now][i]=(f[now][i]+value)%mo;
			return;
		}
	f[now][++tot[now]]=value;
	hash[now][tot[now]]=s;
	nt[tot[now]]=hd[x];
	hd[x]=tot[now];
}
inline void work() {
	/*register*/ int i,j,k,p,q,s,value;
	tot[now]=1; hash[now][1]=0;
	f[now][1]=1;
	for(i=0;i&lt;N;++i)bin[i]=i&lt;&lt;1;
	for(i=1;i&lt;=n;++i) {
		for(j=1;j&lt;=tot[now];++j)hash[now][j]=(hash[now][j]&lt;&lt;2)&amp;((1&lt;&lt;bin[m+1])-1);
		for(j=1;j&lt;=m;++j) {
			pre=now; now^=1;
			memset(hd,0,sizeof hd);
			memset(f[now],0,sizeof f[now]);
			tot[now]=0;
			for(k=1;k&lt;=tot[pre];++k)
				if(f[pre][k]) {
					s=hash[pre][k];
					value=f[pre][k];
					p=(s&gt;&gt;bin[j-1])&amp;3;
					q=(s&gt;&gt;bin[j])&amp;3;
					if(!mp[i][j]) (!p&amp;&amp;!q)?add(s,value),0:0;
					else if(!p&amp;&amp;!q) {
						if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
						if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						if(mp[i+1][j]&amp;&amp;mp[i][j+1]) add(s|(2&lt;&lt;bin[j-1])|(2&lt;&lt;bin[j]),value);
					} else if(!p) {
						s^=(1&lt;&lt;bin[j])*q;
						if(q&amp;1) {
							if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
						}
					} else if(!q) {
						s^=(1&lt;&lt;bin[j-1])*p;
						if(p&amp;1) {
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						}
					} else if((p&amp;1)&amp;&amp;(q&amp;1)) add(s^((1&lt;&lt;bin[j-1])|(1&lt;&lt;bin[j])),value);
				}
		}
	}
}
int main() {
	init(); work();
	printf(&quot;%d\n&quot;,f[now][1]);
	return 0;
}
<pre><h2>Problem2331</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int mo=20110520,N=102,P=1&lt;&lt;17,MP=P-1,M=200000;
int n,m,mp[N][N],now,pre,f[2][M],hash[2][M],tot[2],hd[P],nt[M],bin[N];
inline void init() {
	int i,j; char ch;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if(n&lt;m) {
		for(i=1;i&lt;=n;++i)
			for(j=1;j&lt;=m;mp[j++][i]=ch=='_')
				while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
		n^=m^=n^=m;
	} else for(i=1;i&lt;=n;++i)
			   for(j=1;j&lt;=m;mp[i][j++]=ch=='_')
				   while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
}
inline void add(int s,int value) {
	static int i,x;
	for(i=hd[x=s&amp;MP];i;i=nt[i])
		if(!(hash[now][i]^s)) {
			f[now][i]=(f[now][i]+value)%mo;
			return;
		}
	f[now][++tot[now]]=value;
	hash[now][tot[now]]=s;
	nt[tot[now]]=hd[x];
	hd[x]=tot[now];
}
inline void work() {
	register int i,j,k,p,q,s,value;
	tot[now]=1; hash[now][1]=0;
	f[now][1]=1;
	for(i=0;i&lt;N;++i)bin[i]=i&lt;&lt;1;
	for(i=1;i&lt;=n;++i) {
		for(j=1;j&lt;=tot[now];++j)hash[now][j]=(hash[now][j]&lt;&lt;2)&amp;((1&lt;&lt;bin[m+1])-1);
		for(j=1;j&lt;=m;++j) {
			pre=now; now^=1;
			memset(hd,0,sizeof hd);
			memset(f[now],0,sizeof f[now]);
			tot[now]=0;
			for(k=1;k&lt;=tot[pre];++k)
				if(f[pre][k]) {
					s=hash[pre][k];
					value=f[pre][k];
					p=(s&gt;&gt;bin[j-1])&amp;3;
					q=(s&gt;&gt;bin[j])&amp;3;
					if(!mp[i][j]) (!p&amp;&amp;!q)?add(s,value),0:0;
					else if(!p&amp;&amp;!q) {
						if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
						if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						if(mp[i+1][j]&amp;&amp;mp[i][j+1]) add(s|(2&lt;&lt;bin[j-1])|(2&lt;&lt;bin[j]),value);
					} else if(!p) {
						s^=(1&lt;&lt;bin[j])*q;
						if(q&amp;1) {
							if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
						}
					} else if(!q) {
						s^=(1&lt;&lt;bin[j-1])*p;
						if(p&amp;1) {
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						}
					} else if((p&amp;1)&amp;&amp;(q&amp;1)) add(s^((1&lt;&lt;bin[j-1])|(1&lt;&lt;bin[j])),value);
				}
		}
	}
}
int main() {
	init(); work();
	printf(&quot;%d\n&quot;,f[now][1]);
	return 0;
}
<pre><h2>Problem2331</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int mo=20110520,N=102,P=1&lt;&lt;16,MP=P-1,M=200000;
int n,m,mp[N][N],now,pre,f[2][M],hash[2][M],tot[2],hd[P],nt[M],bin[N];
inline void init() {
	int i,j; char ch;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if(n&lt;m) {
		for(i=1;i&lt;=n;++i)
			for(j=1;j&lt;=m;mp[j++][i]=ch=='_')
				while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
		n^=m^=n^=m;
	} else for(i=1;i&lt;=n;++i)
			   for(j=1;j&lt;=m;mp[i][j++]=ch=='_')
				   while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
}
inline void add(int s,int value) {
	static int i,x;
	for(i=hd[x=s&amp;MP];i;i=nt[i])
		if(!(hash[now][i]^s)) {
			f[now][i]=(f[now][i]+value)%mo;
			return;
		}
	f[now][++tot[now]]=value;
	hash[now][tot[now]]=s;
	nt[tot[now]]=hd[x];
	hd[x]=tot[now];
}
inline void work() {
	register int i,j,k,p,q,s,value;
	tot[now]=1; hash[now][1]=0;
	f[now][1]=1;
	for(i=0;i&lt;N;++i)bin[i]=i&lt;&lt;1;
	for(i=1;i&lt;=n;++i) {
		for(j=1;j&lt;=tot[now];++j)hash[now][j]=(hash[now][j]&lt;&lt;2)&amp;((1&lt;&lt;bin[m+1])-1);
		for(j=1;j&lt;=m;++j) {
			pre=now; now^=1;
			memset(hd,0,sizeof hd);
			memset(f[now],0,sizeof f[now]);
			tot[now]=0;
			for(k=1;k&lt;=tot[pre];++k)
				if(f[pre][k]) {
					s=hash[pre][k];
					value=f[pre][k];
					p=(s&gt;&gt;bin[j-1])&amp;3;
					q=(s&gt;&gt;bin[j])&amp;3;
					if(!mp[i][j]) (!p&amp;&amp;!q)?add(s,value),0:0;
					else if(!p&amp;&amp;!q) {
						if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
						if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						if(mp[i+1][j]&amp;&amp;mp[i][j+1]) add(s|(2&lt;&lt;bin[j-1])|(2&lt;&lt;bin[j]),value);
					} else if(!p) {
						s^=(1&lt;&lt;bin[j])*q;
						if(q&amp;1) {
							if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
						}
					} else if(!q) {
						s^=(1&lt;&lt;bin[j-1])*p;
						if(p&amp;1) {
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						}
					} else if((p&amp;1)&amp;&amp;(q&amp;1)) add(s^((1&lt;&lt;bin[j-1])|(1&lt;&lt;bin[j])),value);
				}
		}
	}
}
int main() {
	init(); work();
	printf(&quot;%d\n&quot;,f[now][1]);
	return 0;
}
<pre><h2>Problem2331</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int mo=20110520,N=102,P=54321,M=200000;
int n,m,mp[N][N],now,pre,f[2][M],hash[2][M],tot[2],hd[P],nt[M],bin[N];
inline void init() {
	int i,j; char ch;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	if(n&lt;m) {
		for(i=1;i&lt;=n;++i)
			for(j=1;j&lt;=m;mp[j++][i]=ch=='_')
				while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
		n^=m^=n^=m;
	} else for(i=1;i&lt;=n;++i)
			   for(j=1;j&lt;=m;mp[i][j++]=ch=='_')
				   while(ch=getchar(),(ch^'_')&amp;&amp;(ch^'*'));
}
inline void add(int s,int value) {
	static int i,x;
	for(i=hd[x=s%P];i;i=nt[i])
		if(!(hash[now][i]^s)) {
			f[now][i]=(f[now][i]+value)%mo;
			return;
		}
	f[now][++tot[now]]=value;
	hash[now][tot[now]]=s;
	nt[tot[now]]=hd[x];
	hd[x]=tot[now];
}
inline void work() {
	register int i,j,k,p,q,s,value;
	tot[now]=1; hash[now][1]=0;
	f[now][1]=1;
	for(i=0;i&lt;N;++i)bin[i]=i&lt;&lt;1;
	for(i=1;i&lt;=n;++i) {
		for(j=1;j&lt;=tot[now];++j)hash[now][j]=(hash[now][j]&lt;&lt;2)&amp;((1&lt;&lt;bin[m+1])-1);
		for(j=1;j&lt;=m;++j) {
			pre=now; now^=1;
			memset(hd,0,sizeof hd);
			memset(f[now],0,sizeof f[now]);
			tot[now]=0;
			for(k=1;k&lt;=tot[pre];++k)
				if(f[pre][k]) {
					s=hash[pre][k];
					value=f[pre][k];
					p=(s&gt;&gt;bin[j-1])&amp;3;
					q=(s&gt;&gt;bin[j])&amp;3;
					if(!mp[i][j]) (!p&amp;&amp;!q)?add(s,value),0:0;
					else if(!p&amp;&amp;!q) {
						if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
						if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						if(mp[i+1][j]&amp;&amp;mp[i][j+1]) add(s|(2&lt;&lt;bin[j-1])|(2&lt;&lt;bin[j]),value);
					} else if(!p) {
						s^=(1&lt;&lt;bin[j])*q;
						if(q&amp;1) {
							if(mp[i+1][j]) add(s|(1&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
						}
					} else if(!q) {
						s^=(1&lt;&lt;bin[j-1])*p;
						if(p&amp;1) {
							if(mp[i+1][j]) add(s|(2&lt;&lt;bin[j-1]),value);
							if(mp[i][j+1]) add(s|(1&lt;&lt;bin[j]),value);
						} else {
							add(s,value);
							if(mp[i][j+1]) add(s|(2&lt;&lt;bin[j]),value);
						}
					} else if((p&amp;1)&amp;&amp;(q&amp;1)) add(s^((1&lt;&lt;bin[j-1])|(1&lt;&lt;bin[j])),value);
				}
		}
	}
}
int main() {
	init(); work();
	printf(&quot;%d\n&quot;,f[now][1]);
	return 0;
}
<pre><h2>Problem2333</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
inline int gi() {
	static int a; static char c, f;
	for (f = 0; (c = getchar()) &lt; '0'; f |= c == '-');
	for (a = c - '0'; '-' &lt; (c = getchar()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
	return f ? -a : a;
}
#define N 300013
#define MS 1200013
struct edge {int t; edge *n;} me[N], *ce = me, *g[N];
inline void adde(int a, int b) {
	ce-&gt;t = b, ce-&gt;n = g[a], g[a] = ce++;
}
int f[N], a[N], b[N], opt[N], a1[N], a2[N], in[N], out[N], Add[MS], Max[MS], _dfn;
inline int gf(int u) {
	static int r, t;
	for (r = u; f[r] ^ r; r = f[r]);
	while (u ^ r) t = f[u], f[u] = r, u = t;
	return r;
}
void dfs(int u) {
	in[u] = out[u] = ++_dfn;
	for (edge *it = g[u]; it; it = it-&gt;n) dfs(it-&gt;t);
}
inline void pd(const int &amp;u) {
	if (!Add[u]) return;
	static int ls, rs;
	ls = u&lt;&lt;1, rs = u&lt;&lt;1|1;
	Add[ls] += Add[u], Max[ls] += Add[u];
	Add[rs] += Add[u], Max[rs] += Add[u];
	Add[u] = 0;
}
inline void pu(const int &amp;u) {
	Max[u] = std::max(Max[u&lt;&lt;1], Max[u&lt;&lt;1|1]);
}
void build(int u, int l, int r) {
	Add[u] = 0;
	if (l &gt;= r) return (void)(Max[u] = b[l]);
	int m = l + r &gt;&gt; 1;
	build(u &lt;&lt; 1, l, m);
	build(u &lt;&lt; 1 | 1, m + 1, r);
	pu(u);
}
void update(int u, int l, int r, const int &amp;x, const int &amp;y, const int &amp;delta) {
	if (x &lt;= l &amp;&amp; r &lt;= y) return (void)(Add[u] += delta, Max[u] += delta);
	int m = l + r &gt;&gt; 1; pd(u);
	if (x &lt;= m) update(u &lt;&lt; 1, l, m, x, y, delta);
	if (y &gt;  m) update(u &lt;&lt; 1 | 1, m + 1, r, x, y, delta);
	pu(u);
}
inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}
void query(int u, int l, int r, const int &amp;x, const int &amp;y, int &amp;v) {
	if (x &lt;= l &amp;&amp; r &lt;= y) return cmax(v, Max[u]);
	int m = l + r &gt;&gt; 1; pd(u);
	if (x &lt;= m) query(u &lt;&lt; 1, l, m, x, y, v);
	if (y &gt;  m) query(u &lt;&lt; 1 | 1, m + 1, r, x, y, v);
}
int main() {
	//freopen(&quot;2333.in&quot;, &quot;r&quot;, stdin);
	int n, m, i, x, y;
	char str[5];
	n = gi();
	for (i = 1; i &lt;= n; ++i) f[i] = i, a[i] = gi();
	m = gi();
	for (i = 1; i &lt;= m; ++i) {
		scanf(&quot;%s&quot;, str);
		if (*str == 'U') {
			x = gf(gi()), y = gf(gi());
			if (x == y) continue;
			f[y] = x;
			a1[i] = x, a2[i] = y;
			opt[i] = 1;
		} else if (*str == 'A') {
			if (str[1] == '1') {
				opt[i] = 2;
				a1[i] = gi(); a2[i] = gi();
			} else if (str[1] == '2') {
				opt[i] = 3;
				a1[i] = gf(gi()); a2[i] = gi();
			} else opt[i] = 4, a1[i] = gi();
		} else {
			if (str[1] == '1') opt[i] = 5, a1[i] = gi();
			else if (str[1] == '2') opt[i] = 6, a1[i] = gf(gi());
			else opt[i] = 7;
		}
	}
	for (i = m; i; --i) if (opt[i] == 1) adde(a1[i], a2[i]);
	for (i = 1; i &lt;= n; ++i) if (gf(i) == i) dfs(i);
	for (i = 1; i &lt;= n; ++i) b[in[i]] = a[i];
	build(1, 1, n);
	for (i = 1; i &lt;= m; ++i)
		if (opt[i] == 1) out[a1[i]] = out[a2[i]];
		else if (opt[i] == 2) update(1, 1, n, in[a1[i]], in[a1[i]], a2[i]);
		else if (opt[i] == 3) update(1, 1, n, in[a1[i]], out[a1[i]], a2[i]);
		else if (opt[i] == 4) update(1, 1, n, 1, n, a1[i]);
		else if (opt[i] == 5) {
			x = -0x7fffffff;
			query(1, 1, n, in[a1[i]], in[a1[i]], x);
			printf(&quot;%d\n&quot;, x);
		} else if (opt[i] == 6) {
			x = -0x7fffffff;
			query(1, 1, n, in[a1[i]], out[a1[i]], x);
			printf(&quot;%d\n&quot;, x);
		} else if (opt[i] == 7) {
			x = -0x7fffffff;
			query(1, 1, n, 1, n, x);
			printf(&quot;%d\n&quot;, x);
		}
	return 0;
}
<pre><h2>Problem2337</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
struct E{int to,v;E*nt;}CD[20001],*cd=CD,*hd[101];
#define adde(a,b,c) (cd-&gt;to=b,cd-&gt;v=c,cd-&gt;nt=hd[a],hd[a]=cd++)
double a[102][102];
int deg[102],n;
const double eps=1e-9;
inline void swap(double&amp;a,double&amp;b){double t=b;b=a,a=t;}
inline void guass() {
	register int i,j,k;
	double t;
	for(i=1;i&lt;=n;++i) {
		for(k=i;k&lt;=n&amp;&amp;fabs(a[k][i])&lt;eps;++k);
		if(k^i)for(j=i;j&lt;=n+1;++j)swap(a[k][j],a[i][j]);
		for(t=a[i][i],j=i+1;j&lt;=n+1;++j)a[i][j]/=t;
		for(j=1;j&lt;=n;++j)
			if((i^j)&amp;&amp;fabs(a[j][i])&gt;eps)
				for(t=a[j][i],k=1;k&lt;=n+1;++k)
					a[j][k]-=t*a[i][k];
	}
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;2337.in&quot;,&quot;r&quot;,stdin);
#endif
	n=geti();
	for(register int m=geti(),i,j,k;m;--m) {
		i=geti(),j=geti(),k=geti();
		if(i^j)adde(i,j,k),adde(j,i,k),++deg[i],++deg[j];
		else adde(i,i,k),++deg[i];
	}
	double ans=0; E*it;
	for(register int i,bit=1&lt;&lt;30;bit;bit&gt;&gt;=1) {
		memset(a,0,sizeof a);
		for(i=1;i&lt;n;++i) {
			a[i][i]=deg[i];
			for(it=hd[i];it;it=it-&gt;nt)
				if(it-&gt;v&amp;bit)
					a[i][n+1]+=1,a[i][it-&gt;to]+=1;
				else a[i][it-&gt;to]-=1;
			a[n][n]=1;
		}
		guass();
		ans+=bit*a[1][n+1];
	}
	printf(&quot;%.3lf\n&quot;,ans);
	return 0;
}<pre><h2>Problem2342</h2><pre>    #include &lt;iostream&gt;  
    #include &lt;cstdio&gt;  
    #include &lt;cmath&gt;  
    #include &lt;algorithm&gt;  
    #include &lt;cstring&gt;  
    #define MAXN 1000005  
    using namespace std;  
    int n, p[MAXN], f[MAXN], ans, now, fat[MAXN];  
    char s[MAXN];  
    int find(int x){return fat[x] == x ? x : fat[x] = find(fat[x]);}  
    int main()  
    {  
        scanf(&quot;%d&quot;, &amp;n);  
        scanf(&quot;%s&quot;, s + 1);  
        for(int i = n; i; i --)s[i * 2] = s[i], s[i * 2 - 1] = '*';  
        s[0] = '#'; s[2 * n + 1] = '*';  
        int k = 0;  
        for(int i = 2; i &lt;= 2 * n + 1; i ++){  
            if(k + p[k] - 1 &lt; i)p[i] = 1;  
            else p[i] = min(p[2 * k - i], k + p[k] - i);  
            while(s[i + p[i]] == s[i - p[i]])p[i] ++;  
            if(i + p[i] &gt; k + p[k])k = i;    
        }  
        for(int i = 1; i &lt;= n; i ++)f[i] = (p[i * 2 + 1] - 1) / 2;  
        for(int i = 1; i &lt;= n; i ++)fat[i] = i;  
        for(int i = 1; i &lt;= n; i ++){  
            for(now = find(i - f[i] / 2); now + f[now] &lt; i; now = fat[now])  
                fat[now] = find(now + 1);      
            ans = max(ans, i - now);  
        }  
        cout &lt;&lt; ans * 4&lt;&lt;endl;  
        return 0;  
    } <pre><h2>Problem2342</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 1000009;
typedef int arr[MaxN];
arr p, f, fa;
char s[MaxN];
int gf(int u) {
	return (fa[u] ^ u) ? fa[u] = gf(fa[u]) : u;
}
inline int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}
inline void cmax(int &amp;a, const int &amp; b) {
	if (a &lt; b) a = b;
}

int main() {
	int n, ans = 0, t, i, k;
	scanf(&quot;%d%s&quot;, &amp;n, s + 1);
	for (i = n; i; --i) s[i * 2] = s[i], s[ i * 2 - 1] = '*';
	s[0] = '#', s[n * 2 + 1] = '*';
	t = n * 2 + 1;
	for (i = 2, k = 0; i &lt;= t; ++i) {
		if (k + p[k] - 1 &lt; i) p[i] = 1;
		else p[i] = min(p[2 * k - i], k + p[k] - i);
		while (s[i + p[i]] == s[i - p[i]]) ++p[i];
		if (i + p[i] &gt; k + p[k]) k = i;
	}
	for (i = 1; i &lt;= n; ++i) f[i] = (p[i * 2 + 1] - 1) / 2;
	for (i = 1; i &lt;= n; ++i) fa[i] = i;
	for (i = 1; i &lt;= n; ++i) {
		for (t = gf(i - f[i] / 2); t + f[t] &lt; i; t = fa[t])
			fa[t] = gf(t + 1);
		cmax(ans, i - t);
	}
	printf(&quot;%d\n&quot;, ans * 4);
	return 0;
}
<pre><h2>Problem2434</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define SIZE 26
#define N 100005
int ch[SIZE][N],fail[N],fa[N],totnode;
int print_rank[N],print_array[N],print_id,que[N];
struct E{int to;E*nt;}CD[N],*cd=CD,*hd[N];
inline void adde(int a,int b){cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++;}
inline void build_fail() {
	int *l=que,*r=que,x,y,i,f;
	*r++=1;
	while(l&lt;r) {
		x=*l++;
		adde(fail[x],x);
		for(i=0;i&lt;SIZE;++i)
			if(y=ch[i][x]) {
				for(f=fail[x];f&amp;&amp;!ch[i][f];f=fail[f]);
				fail[y]=f?ch[i][f]:1;
				*r++=y;
			}
	}
}
//ac auto
int C[N];
inline int sum(int x){int r=0;for(;x;x-=x&amp;-x)r+=C[x];return r;}
inline void add(int x,int v){for(;x&lt;=totnode;x+=x&amp;-x)C[x]+=v;}
//BIT
struct Q{int x,id;Q*nt;}CQ[N],*cq=CQ,*hq[N];
inline void addq(int a,int b,int c) {
	cq-&gt;x=b,cq-&gt;id=c;
	cq-&gt;nt=hq[a],hq[a]=cq++;
}
int ANS[N];
//query
int in[N],out[N],dfs_clock;
void dfs(int u) {
	in[u]=++dfs_clock;
	for(E*it=hd[u];it;it=it-&gt;nt)
		dfs(it-&gt;to);
	out[u]=dfs_clock;
}
//dfs_number
char operatorstring[N];
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;2434.in&quot;,&quot;r&quot;,stdin);
#endif
	scanf(&quot;%s&quot;,operatorstring);
	int u=++totnode,i,j,k;
	for(char *s=operatorstring;*s;++s)
		if(*s=='P') print_array[print_rank[u]=++print_id]=u;
		else if(*s=='B') u=fa[u];
		else {
			i=*s-'a';
			if(!ch[i][u])fa[ch[i][u]=++totnode]=u;
			u=ch[i][u];
		}
	build_fail();
	dfs(1);
	int m=geti();
	for(i=0;i&lt;m;++i) {
		j=geti(),k=geti();
		addq(k,j,i);
	}
	u=1;
	for(char *s=operatorstring;*s;++s)
		if(*s=='P') for(Q*it=hq[print_rank[u]];it;it=it-&gt;nt)
						ANS[it-&gt;id]=sum(out[print_array[it-&gt;x]])-sum(in[print_array[it-&gt;x]]-1);
		else if(*s=='B') add(in[u],-1),u=fa[u];
		else add(in[u=ch[*s-'a'][u]],1);
	for(i=0;i&lt;m;++i)printf(&quot;%d\n&quot;,ANS[i]);
	return 0;
}<pre><h2>Problem2438</h2><pre>#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
#define N 100005
#define M 300005
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int Stack[N],dfn[N],stp,bcnt,bel[N],siz[N],_clock,deg[N];
struct edge{int to;edge*nt;}ME[M],*ce=ME,*he[N];
vector&lt;int&gt;g[N];
inline void adde(int a,int b){ce-&gt;to=b,ce-&gt;nt=he[a],he[a]=ce++;}
inline void cmin(int&amp;a,const int&amp;b){if(b&lt;a)a=b;}
int tarjan(int u) {
	Stack[++stp]=u;
	int low=dfn[u]=++_clock,v;
	for(edge*it=he[u];it;it=it-&gt;nt)
		if(dfn[v=it-&gt;to]) {if(!bel[v])cmin(low,dfn[v]);}
		else cmin(low,tarjan(v));
	if(low==dfn[u]) {
		++bcnt;
		do {
			v=Stack[stp--];
			bel[v]=bcnt;
			++siz[bcnt];
		} while(u^v);
	}
	return low;
}
int main() {
	int n=gi(),m=gi(),i,a,b;
	edge*it;
	while(m--) a=gi(),b=gi(),adde(a,b);
	for(i=1;i&lt;=n;++i)
		if(!dfn[i])tarjan(i);
	for(i=1;i&lt;=n;++i)
		for(a=bel[i],it=he[i];it;it=it-&gt;nt)
			if(a^(b=bel[it-&gt;to]))++deg[b],g[a].push_back(b);
	a=0;
	for(i=1;i&lt;=bcnt;++i)if(!deg[i])++a;
	for(i=1;i&lt;=bcnt;++i)
		if(siz[i]&lt;2&amp;&amp;!deg[i]) {
			m=1;
			for(b=0;b&lt;g[i].size();++b)
				if(deg[g[i][b]]&lt;2){m=0;break;}
			if(m){--a;break;}
		}
	printf(&quot;%.6lf&quot;,(double)(n-a)/n);
	return 0;
}
<pre><h2>Problem2440</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 5e4 + 10;

int mu[MaxN];

inline void Init() {
	static int pri[5200], *end = pri;
	static bool vis[MaxN];
	mu[1] = 1;
	for (int i = 2, *j, t; i &lt; MaxN; ++i) {
		if (!vis[i])
		  mu[*end++ = i] = -1;
		for (j = pri; (t = i * *j) &lt; MaxN; ++j) {
			vis[t] = true;
			if (i % *j)
			  mu[t] = -mu[i];
			else {
				mu[t] = 0;
				break;
			}
		}
	}
	//printf(&quot;%d\n&quot;, end - pri);
}

inline int rank(const int &amp;x) {
	int rk = 0;
	for (int i = 1;i * i &lt;= x; ++i)
	  if (mu[i] &lt; 0)
		rk -= x / i / i;
	  else if (0 &lt; mu[i])
		rk += x / i / i;
	return rk;
}

int main() {
	int _, k, l, r, mid;
	scanf(&quot;%d&quot;, &amp;_);
	Init();
	while (_--) {
		scanf(&quot;%d&quot;, &amp;k);
		for (l = 1, r = k &lt;&lt; 1; l &lt;= r;) {
			mid = ((long long)l + r) &gt;&gt; 1;
			if (rank(mid) &gt;= k) r = mid - 1;
			else l = mid + 1;
		}
		printf(&quot;%d\n&quot;, r + 1);
	}
	return 0;
}<pre><h2>Problem2460</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline long long geti() {
	register long long a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
int magic[1005],r[1005];
long long number[1005],ins[66];
inline bool cmp(const int&amp;i,const int&amp;j){return magic[j]&lt;magic[i];}
int main() {
	int n=geti(),ans=0;
	for(register int i=0;i&lt;n;++i)number[i]=geti(),magic[i]=geti(),r[i]=i;
	std::sort(r,r+n,cmp);
	for(register int i=0,j,k;i&lt;n;++i) {
		for(j=r[i],k=65;~k;--k)
			if((number[j]&gt;&gt;k)&amp;1) {
				if(!ins[k]){ins[k]=number[j];break;}
				else number[j]^=ins[k];
			}
		if(number[j])ans+=magic[j];
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
<pre><h2>Problem2460</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline long long geti() {
	register long long a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define pr pair&lt;int,long long&gt;
pr a[1005];
long long ins[66];
int main() {
	int n=geti(),ans=0;
	for(register int i=0;i&lt;n;++i)a[i].second=geti(),a[i].first=geti();
	sort(a,a+n);
	for(register int i=n-1,j;~i;--i) {
		for(j=65;~j;--j)
			if((a[i].second&gt;&gt;j)&amp;1) {
				if(!ins[j]){ins[j]=a[i].second;break;}
				else a[i].second^=ins[j];
			}
		if(a[i].second)ans+=a[i].first;
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
<pre><h2>Problem2463</h2><pre>#include &lt;cstdio&gt;
int main() {
	int n;
	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
		puts(n &amp; 1 ? &quot;Bob&quot; : &quot;Alice&quot;);
	return 0;
}
<pre><h2>Problem2555</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MaxS = 600000 * 2 + 13;

struct LCT {
	struct node {
		int val, add;
		node *fa, *ch[2];
		void modify(const int &amp;x) {
			val += x;
			add += x;
		}
	} node_mset[MaxS], *cnode, *null;
	LCT() {
		cnode = node_mset;
		null = cnode++;
		*null = (node){0, 0, null, {null, null}};
	}
	inline node *newnode() {
		*cnode = (node){0, 0, null, {null, null}};
		return cnode++;
	}
	inline bool isrt(node *u) const {
		return (u-&gt;fa-&gt;ch[0] != u) &amp;&amp; (u-&gt;fa-&gt;ch[1] != u);
	}
	inline bool which(node *u) const {
		return u-&gt;fa-&gt;ch[1] == u;
	}
	void pd(node *u) {
		if (!isrt(u))
			pd(u-&gt;fa);
		if (u-&gt;add) {
			u-&gt;ch[0]-&gt;modify(u-&gt;add);
			u-&gt;ch[1]-&gt;modify(u-&gt;add);
			u-&gt;add = 0;
		}
	}
	inline void rot(node *u) {
		node *f = u-&gt;fa;
		int d = which(u);
		f-&gt;ch[d] = u-&gt;ch[d ^ 1];
		f-&gt;ch[d]-&gt;fa = f;
		u-&gt;ch[d ^ 1] = f;
		u-&gt;fa = f-&gt;fa;
		if (!isrt(f))
			f-&gt;fa-&gt;ch[which(f)] = u;
		f-&gt;fa = u;
	}
	inline void splay(node *u) {
		pd(u);
		for (node *f; !isrt(u); rot(u))
			if (!isrt(f = u-&gt;fa)) rot(which(u) == which(f) ? f : u);
	}
	inline void access(node *x) {
		for (node *y = null; x != null; x = x-&gt;fa) {
			splay(x);
			x-&gt;ch[1] = y;
			y = x;
		}
	}
	inline void cut(node *u) {
		access(u);
		splay(u);
		u-&gt;ch[0]-&gt;fa = null;
		u-&gt;ch[0] = null;
	}
	inline void link(node *u, node *v) {
		cut(u);
		u-&gt;fa = v;
	}
} tree;

struct SAM {
	struct node {
		int step;
		node *pre, *ch[26];
		LCT::node *idx;
		void clear() {
			pre = NULL;
			memset(ch, 0, sizeof ch);
		}
	} node_mset[MaxS], *cnode, *root, *last;
	SAM() {
		cnode = node_mset;
		cnode-&gt;clear();
		cnode-&gt;step = 0;
		cnode-&gt;idx = tree.newnode();
		root = last = cnode++;
	}
	inline node *newnode(const int &amp;step) {
		cnode-&gt;clear();
		cnode-&gt;step = step;
		cnode-&gt;idx = tree.newnode();
		return cnode++;
	}
	inline void Insert(const int &amp;c) {
		node *p = last, *np = newnode(p-&gt;step + 1);
		for (; p &amp;&amp; !p-&gt;ch[c]; p = p-&gt;pre)
			p-&gt;ch[c] = np;
		if (!p) {
			np-&gt;pre = root;
			tree.link(np-&gt;idx, root-&gt;idx);
		} else {
			node *q = p-&gt;ch[c];
			if (q-&gt;step == p-&gt;step + 1) {
				np-&gt;pre = q;
				tree.link(np-&gt;idx, q-&gt;idx);
			} else {
				node *nq = newnode(p-&gt;step + 1);
				memcpy(nq-&gt;ch, q-&gt;ch, sizeof q-&gt;ch);
				nq-&gt;pre = q-&gt;pre;
				tree.link(nq-&gt;idx, q-&gt;pre-&gt;idx);
				q-&gt;pre = np-&gt;pre = nq;
				tree.link(q-&gt;idx, nq-&gt;idx);
				tree.link(np-&gt;idx, nq-&gt;idx);
				tree.pd(q-&gt;idx);
				nq-&gt;idx-&gt;val = q-&gt;idx-&gt;val;
				for (; p &amp;&amp; p-&gt;ch[c] == q; p = p-&gt;pre)
					p-&gt;ch[c] = nq;
			}
		}
		last = np;
		tree.access(np-&gt;idx);
		tree.splay(np-&gt;idx);
		np-&gt;idx-&gt;modify(1);
	}
	inline void Insert(const char *s) {
		for (const char *i = s; *i; ++i)
			this-&gt;Insert(*i - 'A');
	}
	inline int Query(const char *s) {
		for (node *p = root; p; p = p-&gt;ch[*(s++) - 'A'])
			if (!*s) {
				tree.pd(p-&gt;idx);
				return p-&gt;idx-&gt;val;
			}
		return 0;
	}
} sam;

char s[3000005], ops[23];

inline void Decode(char *s, int mask) {
	static int n, i;
	n = strlen(s);
	for (i = 0; i &lt; n; ++i) {
		mask = (mask * 131 + i) % n;
		swap(s[i], s[mask]);
	}
}

int main() {
	int Q, mask = 0, ans;
	scanf(&quot;%d&quot;, &amp;Q);
	scanf(&quot;%s&quot;, s);
	sam.Insert(s);
	while (Q--) {
		scanf(&quot;%s%s&quot;, ops, s);
		Decode(s, mask);
		if (*ops == 'Q') {
			ans = sam.Query(s);
			mask ^= ans;
			printf(&quot;%d\n&quot;, ans);
		} else {
			sam.Insert(s);
		}
	}
	return 0;
}
<pre><h2>Problem2563</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
int weight[10005],n,m;
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; ++ i) {
		scanf(&quot;%d&quot;, weight + i);
		weight[i] &lt;&lt;= 1;
	}
	while (m--) {
		int a, b, c;
		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
		weight[a] += c;
		weight[b] += c;
	}
	std::sort(weight + 1, weight + n + 1);
	long long maxdelta = 0LL;
	for (int i = 1; i &lt;= n; i += 2)
		maxdelta += weight[i+1] - weight[i];
	maxdelta &gt;&gt;= 1;
	printf(&quot;%lld&quot;, maxdelta);
	return 0;
}
<pre><h2>Problem2565</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int N = 1e5 + 3;
char s[N], S[N];
int pre[N], ch[26][N], l[N], cnd, len[N], last, xn, siz[N];
void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}
void init() {
	pre[0] = pre[1] = 1;
	l[1] = -1;
	for (int i = 0; i &lt; 26; ++i)
		for (int j = 0; j &lt;= cnd; ++j)
			ch[i][j] = 0;
	for (int i = 2; i &lt;= cnd; ++i) l[i] = 0;
	cnd = 1;
	xn = 0;
	*S = -1;
}
int insert(char c) {
	static int v, k;
	S[++xn] = c;
	while (S[xn - l[last] - 1] ^ S[xn])
		last = pre[last];
	if (!ch[c][last]) {
		v = ++cnd;
		l[v] = l[last] + 2;
		k = pre[last];
		while (S[xn - l[k] - 1] ^ S[xn]) k = pre[k];
		pre[v] = ch[c][k];
		ch[c][last] = v;
	}
	last = ch[c][last];
	++siz[last];
	return last;
}
int main() {
	init();
	int n = 1, ans = 0;
	scanf(&quot;%s&quot;, s + 1);
	for (; s[n]; ++n) len[n] = l[insert(s[n] - 'a')];
	init();
	for (int i = n - 1; i; --i) cmax(ans, len[i - 1] + l[insert(s[i] - 'a')]);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem2588</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline int gi() {
	static int a; static char c,f;
	for(f=0;(c=getchar())&lt;'0';f|=c=='-');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 100005
#define M 4000005
int a[N],rk[N],mp[N],S[M],rt[N],tnd,p[20][N],ls[M],rs[M],n,cnt,dep[N];
bool cmp(const int&amp;i,const int&amp;j) {return a[i]&lt;a[j];}
struct edge{int to;edge*nt;}MED[N&lt;&lt;1],*cedge=MED,*hd[N];
inline void adde(int a,int b){cedge-&gt;to=b,cedge-&gt;nt=hd[a],hd[a]=cedge++;}
void insert(const int&amp;la,int&amp;cu,int l,int r,const int &amp;val) {
	cu=++tnd;
	ls[cu]=ls[la],rs[cu]=rs[la],S[cu]=S[la]+1;
	if(l==r) return; int m=l+r&gt;&gt;1;
	if(val&lt;=m) insert(ls[la],ls[cu],l,m,val);
	else insert(rs[la],rs[cu],m+1,r,val);
}
void dfs(int u) {
	int v; dep[u]=dep[p[0][u]]+1;
	for(v=1;v&lt;20;++v) if(!(p[v][u]=p[v-1][p[v-1][u]])) break;
	insert(rt[p[0][u]],rt[u],1,cnt,a[u]);
	for(edge*it=hd[u];it;it=it-&gt;nt)
		if((v=it-&gt;to)^p[0][u]) p[0][v]=u,dfs(v);
}
inline int findkth(int a,int b,int c,int d,int k) {
	int l=1,r=cnt,m,t;
	while(l^r) {
		m=l+r&gt;&gt;1;
		t=S[ls[a]]+S[ls[b]]-S[ls[c]]-S[ls[d]];
		if(k&lt;=t) a=ls[a],b=ls[b],c=ls[c],d=ls[d],r=m;
		else a=rs[a],b=rs[b],c=rs[c],d=rs[d],l=m+1,k-=t;
	}return l;
}
inline int lca(int u,int v) {
	if(dep[u]&lt;dep[v])u^=v^=u^=v;
	int i,t=dep[u]-dep[v];
	for(i=0;i&lt;20&amp;&amp;t;++i)
		if(t&gt;&gt;i&amp;1) u=p[i][u];
	if(u==v)return u;
	for(i=19;~i;--i)
		if(p[i][u]^p[i][v])u=p[i][u],v=p[i][v];
	return p[0][u];
}
int main() {
	int i,ans=0,u,v,k,anc,fanc,t,q;
	n=gi(),q=gi();
	for(i=1;i&lt;=n;++i)a[i]=gi(),rk[i]=i;
	std::sort(rk+1,rk+n+1,cmp);
	mp[1]=u=a[rk[1]]; a[rk[1]]=cnt=1;
	for(i=2;i&lt;=n;++i) {
		if(u^a[v=rk[i]])mp[++cnt]=u=a[v];
		a[v]=cnt;
	}
	for(i=1;i&lt;n;++i)adde(u=gi(),v=gi()),adde(v,u);
	dfs(1);
	while(q--) {
		u=gi()^ans,v=gi(),k=gi();
		anc=lca(u,v); fanc=p[0][anc];
		t=findkth(rt[u],rt[v],rt[anc],rt[fanc],k);
		ans=mp[t];
		printf(&quot;%d&quot;,ans);
		if(q)puts(&quot;&quot;);
	}
	return 0;
}<pre><h2>Problem2594</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int BUF = 1&lt;&lt;16|127;
inline char gc() {
	static char b[BUF], *s = b, *e = b;
	if (s == e) e = (s = b) + fread(b, 1, BUF, stdin);
	return (s == e) ? EOF : *s++;
}

inline void gi(int &amp;a) {
	static char c;
	while (c = gc(), c &lt; '0'); a = c - '0';
	while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

const int MaxN = 100003, MaxM = 1000003, MaxQ = 100003;

struct edge {
	bool deleted;
	int u, v, w;
	edge() {}
	edge(int u, int v) :
		deleted(false), u(u), v(v), w(0) {}
} e[MaxM];

bool operator &lt; (const edge &amp;a, const edge &amp;b) {
	return (a.u ^ b.u) ? (a.u &lt; b.u) : (a.v &lt; b.v);
}
bool cpe(const edge &amp;a, const edge &amp;b) {
	return a.w &lt; b.w;
}
struct opt {
	int x, y, k, ans;
} p[MaxQ];

int f[MaxN];
inline int gf(int u) {
	static int r, t;
	for (r = u; f[r] ^ r; r = f[r]);
	while (u ^ r) t = f[u], f[u] = r, u = t;
	return r;
}

inline void uni(int u, int v) {
	f[gf(u)] = gf(v);
}

struct LCT {
	struct node {
		int val;
		bool rev;
		node *fa, *ch[2], *mx;
	} node_mset[MaxN + MaxM], *nil;
	void Init(const int &amp;n) {
		nil = node_mset;
		*nil = (node){0, false, nil, {nil, nil}, nil};
		for (int i = 1; i &lt;= n; ++i)
			node_mset[i] = *nil;
	}
	inline node* num(const int &amp;x)  {
		return node_mset + x;
	}
	inline bool isrt(node *u) const {
		return (u-&gt;fa-&gt;ch[0] != u) &amp;&amp; (u-&gt;fa-&gt;ch[1] != u);
	}
	inline bool which(node *u) const {
		return u-&gt;fa-&gt;ch[1] == u;
	}

	inline void maintain(node *u) {
		u-&gt;mx = u;
		if(u-&gt;ch[0]-&gt;mx-&gt;val &gt; u-&gt;mx-&gt;val)
			u-&gt;mx = u-&gt;ch[0]-&gt;mx;
		if(u-&gt;ch[1]-&gt;mx-&gt;val &gt; u-&gt;mx-&gt;val)
			u-&gt;mx = u-&gt;ch[1]-&gt;mx;
	}
	inline void rot(node *u) {
		node *f = u-&gt;fa;
		int d = which(u);
		if ((f-&gt;ch[d] = u-&gt;ch[d ^ 1]) != nil)
			f-&gt;ch[d]-&gt;fa = f;
		u-&gt;ch[d ^ 1] = f;
		u-&gt;fa = f-&gt;fa;
		if (!isrt(f))
			f-&gt;fa-&gt;ch[which(f)] = u;
		f-&gt;fa = u;
		maintain(f);
	}
	inline void pd(node *u) {
		if (!isrt(u)) pd(u-&gt;fa);
		if (u-&gt;rev) {
			u-&gt;ch[0]-&gt;rev ^= true;
			u-&gt;ch[1]-&gt;rev ^= true;
			swap(u-&gt;ch[0], u-&gt;ch[1]);
			u-&gt;rev = false;
		}
	}
	inline void splay(node *u) {
		pd(u);
		for (node *f; !isrt(u); rot(u))
			if (!isrt(f = u-&gt;fa)) rot(which(f) == which(u) ? f : u);
		maintain(u);
	}
	inline void access(node *x) {
		for (node *y = nil; x != nil; x = x-&gt;fa)
			splay(x), x-&gt;ch[1] = y, maintain(y = x);
	}
	inline void mrt(node *u) {
		access(u);
		splay(u);
		u-&gt;rev ^= 1;
	}
	inline void link(node *u, node *v) {
		mrt(u);
		u-&gt;fa = v;
		access(u);
	}
	inline void cut(node *v) {
		splay(v);
		v-&gt;ch[0]-&gt;fa = v-&gt;fa;
		v-&gt;ch[1]-&gt;fa = nil;
		v-&gt;fa = v-&gt;ch[0] = v-&gt;ch[1] = nil;
		v-&gt;mx = v;
	}
	inline void add_edge(int u, int v, int w) {
		node *_u = num(u), *_v = num(v), *_w = num(w);
		if (gf(u) == gf(v)) {
			mrt(_u);
			access(_v);
			splay(_v);
			if (_v-&gt;mx-&gt;val &lt; _w-&gt;val) return;
			cut(_v-&gt;mx);
			maintain(_v);
		}
		uni(u, v);
		link(_u, _w);
		link(_v, _w);
	}
	inline int query(int u, int v) {
		node *_u = num(u), *_v = num(v);
		mrt(_u);
		access(_v), splay(_v);
		return _v-&gt;mx-&gt;val;
	}
} tree;

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;tube_strong.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;tube_strong.out&quot;, &quot;w&quot;, stdout);
#endif
	int n, m, q;
	gi(n), gi(m), gi(q);
	for (int i = 0; i &lt; m; ++i) {
		gi(e[i].u), gi(e[i].v), gi(e[i].w);
		if (e[i].u &gt; e[i].v) swap(e[i].u, e[i].v);
	}
	sort(e, e + m);
	for (int i = 0; i &lt; q; ++i) {
		gi(p[i].k), gi(p[i].x), gi(p[i].y);
		if (p[i].x &gt; p[i].y) swap(p[i].x, p[i].y);
		if (p[i].k == 2)
			lower_bound(e, e + m, edge(p[i].x, p[i].y))-&gt;deleted = true;
	}
	tree.Init(n + m);
	for (int i = 1; i &lt;= n; ++i) f[i] = i;
	for (int i = 0, idx = n + 1; i &lt; m; ++i, ++idx)
		if (!e[i].deleted) {
			tree.num(idx)-&gt;val = e[i].w;
		    tree.add_edge(e[i].u, e[i].v, idx);
		}
	for (int i = q - 1; ~i; --i)
		if (p[i].k == 1) {
			p[i].ans = tree.query(p[i].x, p[i].y);
		} else {
			edge *it = lower_bound(e, e + m, edge(p[i].x, p[i].y));
			tree.num(it - e + n + 1)-&gt;val = it-&gt;w;
			tree.add_edge(it-&gt;u, it-&gt;v, it- e + n + 1);
		}
	for (int i = 0; i &lt; q; ++i)
		if (p[i].k == 1) printf(&quot;%d\n&quot;, p[i].ans);
	return 0;
}<pre><h2>Problem2594</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
/*
const int BUF = 1&lt;&lt;16|127;
inline char gc() {
	static char b[BUF], *s = b, *e = b;
	if (s == e) e = (s = b) + fread(b, 1, BUF, stdin);
	return (s == e) ? EOF : *s++;
}
*/
#define gc getchar
inline void gi(int &amp;a) {
	static char c;
	while (c = gc(), c &lt; '0'); a = c - '0';
	while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

const int MaxN = 100003, MaxM = 1000003, MaxQ = 100003;

struct edge {
	bool deleted;
	int u, v, w;
	edge() {}
	edge(int u, int v) :
		deleted(false), u(u), v(v), w(0) {}
} e[MaxM];

bool operator &lt; (const edge &amp;a, const edge &amp;b) {
	return (a.u ^ b.u) ? (a.u &lt; b.u) : (a.v &lt; b.v);
}
bool cpe(const edge &amp;a, const edge &amp;b) {
	return a.w &lt; b.w;
}
struct opt {
	int x, y, k, ans;
} p[MaxQ];

int f[MaxN];
inline int gf(int u) {
	static int r, t;
	for (r = u; f[r] ^ r; r = f[r]);
	while (u ^ r) t = f[u], f[u] = r, u = t;
	return r;
}

inline void uni(int u, int v) {
	f[gf(u)] = gf(v);
}

struct LCT {
	struct node {
		int val;
		bool rev;
		node *fa, *ch[2], *mx;
	} node_mset[MaxN + MaxM], *nil;
	void Init(const int &amp;n) {
		nil = node_mset;
		*nil = (node){0, false, nil, {nil, nil}, nil};
		for (int i = 1; i &lt;= n; ++i)
			node_mset[i] = *nil;
	}
	inline node* num(const int &amp;x)  {
		return node_mset + x;
	}
	inline bool isrt(node *u) const {
		return (u-&gt;fa-&gt;ch[0] != u) &amp;&amp; (u-&gt;fa-&gt;ch[1] != u);
	}
	inline bool which(node *u) const {
		return u-&gt;fa-&gt;ch[1] == u;
	}

	inline void maintain(node *u) {
		u-&gt;mx = u;
		if(u-&gt;ch[0]-&gt;mx-&gt;val &gt; u-&gt;mx-&gt;val)
			u-&gt;mx = u-&gt;ch[0]-&gt;mx;
		if(u-&gt;ch[1]-&gt;mx-&gt;val &gt; u-&gt;mx-&gt;val)
			u-&gt;mx = u-&gt;ch[1]-&gt;mx;
	}
	inline void rot(node *u) {
		node *f = u-&gt;fa;
		int d = which(u);
		if ((f-&gt;ch[d] = u-&gt;ch[d ^ 1]) != nil)
			f-&gt;ch[d]-&gt;fa = f;
		u-&gt;ch[d ^ 1] = f;
		u-&gt;fa = f-&gt;fa;
		if (!isrt(f))
			f-&gt;fa-&gt;ch[which(f)] = u;
		f-&gt;fa = u;
		maintain(f);
	}
	inline void pd(node *u) {
		if (!isrt(u)) pd(u-&gt;fa);
		if (u-&gt;rev) {
			u-&gt;ch[0]-&gt;rev ^= true;
			u-&gt;ch[1]-&gt;rev ^= true;
			swap(u-&gt;ch[0], u-&gt;ch[1]);
			u-&gt;rev = false;
		}
	}
	inline void splay(node *u) {
		pd(u);
		for (node *f; !isrt(u); rot(u))
			if (!isrt(f = u-&gt;fa)) rot(which(f) == which(u) ? f : u);
		maintain(u);
	}
	inline void access(node *x) {
		for (node *y = nil; x != nil; x = x-&gt;fa)
			splay(x), x-&gt;ch[1] = y, maintain(y = x);
	}
	inline void mrt(node *u) {
		access(u);
		splay(u);
		u-&gt;rev ^= 1;
	}
	inline void link(node *u, node *v) {
		mrt(u);
		u-&gt;fa = v;
		access(u);
	}
	inline void cut(node *v) {
		splay(v);
		v-&gt;ch[0]-&gt;fa = v-&gt;fa;
		v-&gt;ch[1]-&gt;fa = nil;
		v-&gt;fa = v-&gt;ch[0] = v-&gt;ch[1] = nil;
		v-&gt;mx = v;
	}
	inline void add_edge(int u, int v, int w) {
		node *_u = num(u), *_v = num(v), *_w = num(w);
		if (gf(u) == gf(v)) {
			mrt(_u);
			access(_v);
			splay(_v);
			if (_v-&gt;mx-&gt;val &lt; _w-&gt;val) return;
			cut(_v-&gt;mx);
			maintain(_v);
		}
		uni(u, v);
		link(_u, _w);
		link(_v, _w);
	}
	inline int query(int u, int v) {
		node *_u = num(u), *_v = num(v);
		mrt(_u);
		access(_v), splay(_v);
		return _v-&gt;mx-&gt;val;
	}
} tree;

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;tube_strong.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;tube_strong.out&quot;, &quot;w&quot;, stdout);
#endif
	int n, m, q;
	gi(n), gi(m), gi(q);
	for (int i = 0; i &lt; m; ++i) {
		gi(e[i].u), gi(e[i].v), gi(e[i].w);
		if (e[i].u &gt; e[i].v) swap(e[i].u, e[i].v);
	}
	sort(e, e + m);
	for (int i = 0; i &lt; q; ++i) {
		gi(p[i].k), gi(p[i].x), gi(p[i].y);
		if (p[i].x &gt; p[i].y) swap(p[i].x, p[i].y);
		if (p[i].k == 2)
			lower_bound(e, e + m, edge(p[i].x, p[i].y))-&gt;deleted = true;
	}
	tree.Init(n + m);
	for (int i = 1; i &lt;= n; ++i) f[i] = i;
	for (int i = 0, idx = n + 1; i &lt; m; ++i, ++idx)
		if (!e[i].deleted) {
			tree.num(idx)-&gt;val = e[i].w;
		    tree.add_edge(e[i].u, e[i].v, idx);
		}
	for (int i = q - 1; ~i; --i)
		if (p[i].k == 1) {
			p[i].ans = tree.query(p[i].x, p[i].y);
		} else {
			edge *it = lower_bound(e, e + m, edge(p[i].x, p[i].y));
			tree.num(it - e + n + 1)-&gt;val = it-&gt;w;
			tree.add_edge(it-&gt;u, it-&gt;v, it- e + n + 1);
		}
	for (int i = 0; i &lt; q; ++i)
		if (p[i].k == 1) printf(&quot;%d\n&quot;, p[i].ans);
	return 0;
}<pre><h2>Problem2595</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int maxn(13), inf(0x3f3f3f3f);
const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};

int f[maxn][maxn][1 &lt;&lt; maxn], pre[maxn][maxn][1 &lt;&lt; maxn];

int n, m, all, a[maxn][maxn];
bool inq[maxn * maxn * 2], vis[maxn][maxn];

inline int pack(int x, int y) {
	return (x &lt;&lt; 4) | y;
}

inline void uncode(int sta, int &amp;x, int &amp;y) {
	x = sta &gt;&gt; 4;
	y = sta &amp; 15;
}

inline int pack(int x, int y, int z) {
	return (x &lt;&lt; 14) | (y &lt;&lt; 10) | z;
}

inline void uncode(int sta, int &amp;x, int &amp;y, int &amp;z) {
	x = sta &gt;&gt; 14;
	y = (sta &gt;&gt; 10) &amp; 15;
	z = sta &amp; 1023;
}

std::queue&lt;int&gt; q;

inline void spfa(int sta) {
	while (!q.empty()) {
		static int x, y, p, _x, _y;
		p = q.front(), q.pop();
		inq[p] = false;
		uncode(p, x, y);
		for (register int i = 0; i ^ 4; ++i) {
			_x = x + dx[i], _y = y + dy[i];
			if (_x &lt; 0 || _y &lt; 0 || _x &gt;= n || _y &gt;= m)
				continue;
			if (f[_x][_y][sta] &gt; f[x][y][sta] + a[_x][_y]) {
				f[_x][_y][sta] = f[x][y][sta] + a[_x][_y];
				pre[_x][_y][sta] = pack(x, y, sta);
				if (!inq[p = pack(_x, _y)])
					inq[p] = true, q.push(p);
			}
		}
	}
}

void dfs(int x, int y, int s) {
	if (!pre[x][y][s]) return;
	vis[x][y] = true;
	int _x, _y, _s;
	uncode(pre[x][y][s], _x, _y, _s);
	dfs(_x, _y, _s);
	if (_x == x &amp;&amp; _y == y)
		dfs(x, y, s ^ _s);
}


inline void print() {
	for (register int i = 0; i &lt; n; ++i) {
		for (register int j = 0; j &lt; m; ++j)
			if (!a[i][j]) putchar('x');
			else if (vis[i][j]) putchar('o');
			else putchar('_');
		putchar('\n');
	}
}

int main() {
	//freopen(&quot;2595.in&quot;,&quot;r&quot;, stdin);
	int all = 1;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	memset(f, 63, sizeof f);
	for (register int i = 0; i &lt; n; ++i)
		for (register int j = 0; j &lt; m; ++j) {
			scanf(&quot;%d&quot;, a[i] + j);
			if (!a[i][j]) f[i][j][all] = 0, all &lt;&lt;= 1;
		}
	for (register int sta = 1, t; sta ^ all; ++sta) {
		for (register int i = 0; i &lt; n; ++i)
			for (register int j = 0; j &lt; m; ++j) {
				for (register int s = sta &amp; (sta - 1); s; s = (s - 1) &amp; sta)
					if (f[i][j][sta] &gt; f[i][j][s] + f[i][j][sta ^ s] - a[i][j]) {
						f[i][j][sta] = f[i][j][s] + f[i][j][sta ^ s] - a[i][j];
						pre[i][j][sta] = pack(i, j, s);
					}
				if (f[i][j][sta] != inf)
					q.push(t = pack(i, j)), inq[t] = true;
			}
		spfa(sta);
	}
	for (register int i = 0; i &lt; n; ++i)
		for (register int j = 0; j &lt; m; ++j)
			if (!a[i][j]) {
				printf(&quot;%d\n&quot;, f[i][j][all - 1]);
				dfs(i, j, all - 1);
				print();
				return 0;
			}
	return 0;
}<pre><h2>Problem2622</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 1e5 + 4, MaxM = 1e6 + 3;

namespace FastIO {
	const int buf = 1 &lt;&lt; 16 | 123;
	char b[buf], *s = b, *e = b, c;
	inline char gc() {
		if (s == e) {
			s = b;
			e = b + fread(b, 1, buf, stdin);
			if (s == e)
				return EOF;
		}
		return *s++;
	}
	inline void gi(int &amp;a) {
		do c = gc(); while (c &lt; 48);
		a = c - 48;
		while (47 &lt; (c = gc())) 
			a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48;
	}
}

struct edge {
	int to, w;
	edge *nxt;
} edge_mset[MaxM &lt;&lt; 1], *cedge = edge_mset, *g[MaxN];

inline void add_edge(int u, int v, int w) {
	*cedge = (edge) {v, w, g[u]};
	g[u] = cedge++;
}

typedef int arr[MaxN];

bool inq[MaxN];
arr dis, sec_dis, from, que;
int *l = que, *r = que, *end = que + MaxN;

inline void nxt(int * &amp;it) {
	if (++it &gt;= end) it = que;
}

inline void SPFA() {
	int u, v;
	edge *it;
	while (l != r) {
		u = *l;
		nxt(l);
		inq[u] = false;
		for (it = g[u]; it; it = it-&gt;nxt) {
			v = it-&gt;to;
			if (sec_dis[u] + it-&gt;w &lt;= dis[v]) {
				if (from[v] ^ u)
					sec_dis[v] = dis[v];
				dis[v] = sec_dis[u] + it-&gt;w;
				from[v] = u;
				if (!inq[v]) {
					inq[v] = true;
					*r = v;
					nxt(r);
				}
			} else if (sec_dis[u] + it-&gt;w &lt; sec_dis[v]) {
				sec_dis[v] = sec_dis[u] + it-&gt;w;
				if (!inq[v]) {
					inq[v] = true;
					*r = v;
					nxt(r);
				}
			}
		}
	}
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	memset(dis, 63, sizeof dis);
	memset(sec_dis, 63, sizeof sec_dis);
	memset(from, -1, sizeof from);
	int n, m, k, i, u, v, w;
	using namespace FastIO;
	gi(n), gi(m), gi(k);
	for (i = 0; i &lt; m; ++i) {
		gi(u), gi(v), gi(w);
		add_edge(u, v, w);
		add_edge(v, u, w);
	}
	for (i = 0; i &lt; k; ++i) {
		gi(u);
		dis[u] = sec_dis[u] = 0;
		*r = u;
		nxt(r);
		inq[u] = true;
	}
	SPFA();
	printf(&quot;%d\n&quot;, *sec_dis);
	return 0;
}<pre><h2>Problem2648</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline int geti() {
	register int a; register char c,f=0;
	while(c=getchar(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
char buf[10];
inline void outi(int x) {
	if(!x){puts(&quot;0&quot;);return;}
	if(x&lt;0)putchar('-'),x=-x;
	register char *s=buf+8;
	while(x)*s--=x%10+'0',x/=10;
	puts(s+1);
}
#define N 1000005
#define inf 0x7f7f7f7f
inline void cmin(int&amp;a,int b){b&lt;a?a=b:1;}
inline void cmax(int&amp;a,int b){a&lt;b?a=b:1;}
inline int ibs(int a){return a&lt;0?-a:a;}
struct D{int d[2],mx0,mx1,mi0,mi1;D*l,*r;}t[N],*rt;
int cpd,ans;
inline bool cmp(const D&amp;a,const D&amp;b){return(a.d[cpd]^b.d[cpd])?a.d[cpd]&lt;b.d[cpd]:a.d[cpd^1]&lt;b.d[cpd^1];}
inline void kd_upd(D*u) {
	if(u-&gt;l) {
		cmax(u-&gt;mx0,u-&gt;l-&gt;mx0);cmax(u-&gt;mx1,u-&gt;l-&gt;mx1);
		cmin(u-&gt;mi0,u-&gt;l-&gt;mi0);cmin(u-&gt;mi1,u-&gt;l-&gt;mi1);
	}
	if(u-&gt;r) {
		cmax(u-&gt;mx0,u-&gt;r-&gt;mx0);cmax(u-&gt;mx1,u-&gt;r-&gt;mx1);
		cmin(u-&gt;mi0,u-&gt;r-&gt;mi0);cmin(u-&gt;mi1,u-&gt;r-&gt;mi1);
	}
}
D*kd_bld(int l,int r,int d) {
	int m=l+r&gt;&gt;1;
	cpd=d; std::nth_element(t+l+1,t+m+1,t+r+1,cmp);
	t[m].mx0=t[m].mi0=t[m].d[0];
	t[m].mx1=t[m].mi1=t[m].d[1];
	if(l^m)t[m].l=kd_bld(l,m-1,d^1);
	if(r^m)t[m].r=kd_bld(m+1,r,d^1);
	kd_upd(t+m);return t+m;
}
inline void kd_ins(D*ne) {
	int cd=0;D*u=rt;
	while(true) {
		cmax(u-&gt;mx0,ne-&gt;mx0),cmin(u-&gt;mi0,ne-&gt;mi0);
		cmax(u-&gt;mx1,ne-&gt;mx1),cmin(u-&gt;mi1,ne-&gt;mi1);
		if(ne-&gt;d[cd]&lt;u-&gt;d[cd]) {
			if(u-&gt;l)u=u-&gt;l;
			else{u-&gt;l=ne;return;}
		}else{
			if(u-&gt;r)u=u-&gt;r;
			else{u-&gt;r=ne;return;}
		}
		cd^=1;
	}
}
inline int dist(int x,int y,D*u) {
	int r=0;
	if(x&lt;u-&gt;mi0)r=u-&gt;mi0-x;
	else if(x&gt;u-&gt;mx0)r=x-u-&gt;mx0;
	if(y&lt;u-&gt;mi1)r+=u-&gt;mi1-y;
	else if(y&gt;u-&gt;mx1)r+=y-u-&gt;mx1;
	return r;
}
inline void kd_quy(D*u,const int&amp;x,const int&amp;y) {
	int dl,dr,d0;
	d0=ibs(u-&gt;d[0]-x)+ibs(u-&gt;d[1]-y);
	if(d0&lt;ans)ans=d0;
	if(u-&gt;l)dl=dist(x,y,u-&gt;l);else dl=inf;
	if(u-&gt;r)dr=dist(x,y,u-&gt;r);else dr=inf;
	if(dl&lt;dr) {
		if(dl&lt;ans)kd_quy(u-&gt;l,x,y);
		if(dr&lt;ans)kd_quy(u-&gt;r,x,y);
	}else {
		if(dr&lt;ans)kd_quy(u-&gt;r,x,y);
		if(dl&lt;ans)kd_quy(u-&gt;l,x,y);
	}
}
int main() {
	int n=geti(),m=geti(),i,x,y;
	D*cur=t+n+1;
	for(i=1;i&lt;=n;++i)t[i].d[0]=geti(),t[i].d[1]=geti();
	rt=kd_bld(1,n,0);
	while(m--){
		i=geti(),x=geti(),y=geti();
		if(i&lt;2) {
			cur-&gt;mx0=cur-&gt;mi0=cur-&gt;d[0]=x;
			cur-&gt;mx1=cur-&gt;mi1=cur-&gt;d[1]=y;
			kd_ins(cur++);
		} else {
			ans=inf;kd_quy(rt,x,y);
			outi(ans);
		}
	}return 0;
}
<pre><h2>Problem2653</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c,f;
	for(f=0;(c=getchar())&lt;'0';f|=c=='-');a=c-'0';
	while('-'&lt;(c=getchar()))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 20005
#define MS 800000
struct data{int sum,lm,rm;}tr[MS];
data operator + (const data&amp;a,const data&amp;b){return (data){a.sum+b.sum,max(a.lm,a.sum+b.lm),max(b.rm,a.rm+b.sum)};}
int ls[MS],rs[MS],cnd,rt[N],q[4],n;
pair&lt;int,int&gt;a[N];
void build(int&amp;u,int l,int r) {
	if(u=++cnd,l==r) {tr[u]=(data){1,1,1};return;}
	int m=l+r&gt;&gt;1;
	build(ls[u],l,m); build(rs[u],m+1,r);
	tr[u]=tr[ls[u]]+tr[rs[u]];
}
void insert(int la,int&amp;cu,int l,int r,int v) {
	cu=++cnd; ls[cu]=ls[la],rs[cu]=rs[la];
	if(l==r) {tr[cu]=(data){-1,-1,-1};return;}
	int m=l+r&gt;&gt;1;
	if(v&lt;=m) insert(ls[la],ls[cu],l,m,v);
	else insert(rs[la],rs[cu],m+1,r,v);
	tr[cu]=tr[ls[cu]]+tr[rs[cu]];
}
data quy(int x,int y,int l,int r,int u) {
	if(x&gt;y) return (data){0,0,0};
	if(x&lt;=l&amp;&amp;r&lt;=y) return tr[u];
	int m=l+r&gt;&gt;1;
	if(y&lt;=m) return quy(x,y,l,m,ls[u]);
	if(x &gt;m) return quy(x,y,m+1,r,rs[u]);
	return quy(x,y,l,m,ls[u])+quy(x,y,m+1,r,rs[u]);
}
inline bool check(int x) {
	return quy(q[0],q[1],0,n-1,rt[x]).rm+quy(q[1]+1,q[2]-1,0,n-1,rt[x]).sum+quy(q[2],q[3],0,n-1,rt[x]).lm&gt;=0;
}
int main() {
	int ans=0,i,qq,l,r,m;
	for(i=0,n=gi();i&lt;n;++i)a[a[i].second=i].first=gi();
	sort(a,a+n); build(rt[0],0,n-1);
	for(i=1;i&lt;n;++i)insert(rt[i-1],rt[i],0,n-1,a[i-1].second);
	for(qq=gi();qq;--qq) {
		for(i=0;i&lt;4;++i)q[i]=(gi()+ans)%n;
		sort(q,q+4);
		for(l=0,r=n-1;l&lt;=r;)
			(check(m=l+r&gt;&gt;1))?(l=m+1):(r=m-1);
		printf(&quot;%d\n&quot;,ans=a[l-1].first);
	}
	return 0;
}<pre><h2>Problem2654</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int maxn(50005), maxm(100003);

struct edge {
	int u, v, w, color;
	inline edge modify(const int &amp;delta) const {
		if (color)
			return *this;
		else
			return (edge) {u, v, w + delta, color};
	}
} e[maxm], xe[maxm];
int n, m, need, ans, f[maxn];

inline bool operator &lt; (const edge &amp;a, const edge &amp;b) {
	return (a.w ^ b.w) ? a.w &lt; b.w : a.color &lt; b.color;
}

inline int gf(int u) {
	while (f[u] ^ u) u = f[u] = f[f[u]];
	return u;
}

inline bool check(int delta) {
	for (register int i = 0; i &lt; m; ++i)
		xe[i] = e[i].modify(delta);
	for (register int i = 0; i &lt; n; ++i)
		f[i] = i;
	int cnt = 0, sum = 0, u, v, _n = n - 1;
	std::sort(xe, xe + m);
	for (register int i = 0; i &lt; m; ++i) {
		u = gf(xe[i].u), v = gf(xe[i].v);
		if (u ^ v) {
			f[u] = v;
			sum += xe[i].w;
			if (!xe[i].color) ++cnt;
			if (!--_n) break;
		}
	}
	if (cnt &lt; need)
		return false;
	ans = sum - delta * need;
	if (cnt &gt; need)
		return true;
	printf(&quot;%d\n&quot;, ans);
	exit(0);
}

int main() {

	//freopen(&quot;2654.in&quot;, &quot;r&quot;, stdin);

	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;need);

	for (register int i = 0; i &lt; m; ++i)
		scanf(&quot;%d%d%d%d&quot;, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w, &amp;e[i].color);

	for (int l = -100, r = 100, mid; l &lt;= r; )
		if (check(mid = (l + r) &gt;&gt; 1))
			l = mid + 1;
		else
			r = mid - 1;
	printf(&quot;%d\n&quot;, ans);

	return 0;
}<pre><h2>Problem2733</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 100005
struct node {
	int id,v,r,s;
	node *ch[2];
	void maintain() {
		s=1+ch[0]-&gt;s+ch[1]-&gt;s;
	}
}MSET[N*20],*cnode=MSET,*rt[N],*nil;
inline node*newnode() {
	cnode-&gt;ch[0]=cnode-&gt;ch[1]=nil;
	return cnode++;
}
int f[N];
inline int gf(int u) {
	int r=u;
	while(f[r]^r)r=f[r];
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
void rot(node*(&amp;o),const int&amp;d) {
	node*u=o-&gt;ch[d^1];o-&gt;ch[d^1]=u-&gt;ch[d];
	u-&gt;ch[d]=o; o-&gt;maintain(); u-&gt;maintain();o=u;
}
void insert(node*(&amp;u),const int&amp;_id,const int&amp;_v) {
	if(u==nil) {
		u=newnode();u-&gt;id=_id,u-&gt;v=_v;u-&gt;s=1,u-&gt;r=rand();
	} else {
		int k=_v&lt;u-&gt;v?0:1; ++u-&gt;s;
		insert(u-&gt;ch[k],_id,_v);
		if(u-&gt;r &lt; u-&gt;ch[k]-&gt;r)rot(u,k^1);
	}
}
inline int kth(node*u,int k) {
	if(u-&gt;s &lt; k) return -1;
	for(int ls;;){
		ls=u-&gt;ch[0]-&gt;s;
		if(ls+1==k)return u-&gt;id;
		if(k&gt;ls)k-=ls+1,u=u-&gt;ch[1];
		else u=u-&gt;ch[0];
	}
}
void merge(node*(&amp;u),node*(&amp;v)) {
	insert(u,v-&gt;id,v-&gt;v);
	if(v-&gt;ch[0]!=nil) merge(u,v-&gt;ch[0]);
	if(v-&gt;ch[1]!=nil) merge(u,v-&gt;ch[1]);
}
inline void Union(int u,int v) {
	if(u==v) return;
	if(rt[u]-&gt;s &lt; rt[v]-&gt;s) u^=v^=u^=v;
	merge(rt[u],rt[v]); f[v]=u;
}
int main() {
	nil=newnode();
	nil-&gt;ch[0]=nil-&gt;ch[1]=nil;
	nil-&gt;s=0; nil-&gt;r=-100000;
	register int n=geti(),m=geti();
	for(int i=1;i&lt;=n;++i) {
		f[i]=i; rt[i]=nil;
		insert(rt[i],i,geti());
	}
	while(m--) Union(gf(geti()),gf(geti()));
	register int x,y; register char ch;
	for(m=geti();m;--m) {
		while(ch=getchar(),ch&lt;'A');
		x=geti(),y=geti();
		if(ch=='Q') printf(&quot;%d\n&quot;,kth(rt[gf(x)],y));
		else Union(gf(x),gf(y));
	}
	return 0;
}<pre><h2>Problem2733</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 100005
struct node {
	int id,v,r,s;
	node *ch[2];
	void maintain() {
		s=1+ch[0]-&gt;s+ch[1]-&gt;s;
	}
}MSET[N],*rt[N],*nil;
int f[N];
inline int gf(int u) {
	int r=u; while(f[r]^r)r=f[r];
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
void rot(node*(&amp;o),const int&amp;d) {
	node*u=o-&gt;ch[d^1];o-&gt;ch[d^1]=u-&gt;ch[d];
	u-&gt;ch[d]=o; o-&gt;maintain(); u-&gt;maintain();o=u;
}
void insert(node*(&amp;u),node*(&amp;v)) {
	if(u==nil) u=v,u-&gt;s=1,u-&gt;ch[0]=u-&gt;ch[1]=nil;
	else {
		int k=v-&gt;v &lt; u-&gt;v?0:1; ++u-&gt;s;
		insert(u-&gt;ch[k],v);
		if(u-&gt;r &lt; u-&gt;ch[k]-&gt;r)rot(u,k^1);
	}
}
inline int kth(node*u,int k) {
	if(u-&gt;s &lt; k) return -1;
	for(int ls;;){
		ls=u-&gt;ch[0]-&gt;s;
		if(ls+1==k)return u-&gt;id;
		if(k&gt;ls)k-=ls+1,u=u-&gt;ch[1];
		else u=u-&gt;ch[0];
	}
}
void merge(node*(&amp;u),node*(&amp;v)) {
	if(v-&gt;ch[0]!=nil) merge(u,v-&gt;ch[0]);
	if(v-&gt;ch[1]!=nil) merge(u,v-&gt;ch[1]);
	insert(u,v);
}
inline void Union(int u,int v) {
	if(u==v) return;
	if(rt[u]-&gt;s &lt; rt[v]-&gt;s) u^=v^=u^=v;
	merge(rt[u],rt[v]); f[v]=u;
}
int main() {
	nil=new node();
	nil-&gt;ch[0]=nil-&gt;ch[1]=nil;
	nil-&gt;s=0; nil-&gt;r=-100000;
	register int n=geti(),m=geti();
	node*cnd=MSET;
	for(int i=1;i&lt;=n;++i) {
		f[i]=i;
		cnd-&gt;s=1,cnd-&gt;v=geti(),cnd-&gt;id=i,cnd-&gt;r=rand();
		cnd-&gt;ch[0]=cnd-&gt;ch[1]=nil;
		rt[i]=cnd++;
	}
	while(m--) Union(gf(geti()),gf(geti()));
	register int x,y; register char ch;
	for(m=geti();m;--m) {
		while(ch=getchar(),ch&lt;'A');
		x=geti(),y=geti();
		if(ch=='Q') printf(&quot;%d\n&quot;,kth(rt[gf(x)],y));
		else Union(gf(x),gf(y));
	}
	return 0;
}<pre><h2>Problem2734</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int mo = 1000000001;
int n, mx; bool mark[100003];

inline int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}

inline void add(int &amp;a, const int &amp;b) {
	a += b;
	if (a &gt;= mo) a -= mo;
}

inline int cal(int x) {
	static int M[2][2049], *f = M[0], *g = M[1], *t, mat[21][21], a[21];
	static int i, j, k, size = sizeof M[0];
	mat[1][1] = x;
	for (i = 2; i &lt; 19; ++i)
		mat[i][1] = min(mat[i - 1][1] * 2, mx);
	for (i = 1; i &lt; 19; ++i)
		for (j = 2; j &lt; 12; ++j)
			mat[i][j] = min(mat[i][j - 1] * 3, mx);
	memset(a, 0, sizeof a);
	for (i = 1; i &lt; 19; ++i)
		for (j = 1; j &lt; 12; ++j)
			if (mat[i][j] &lt; mx){
				a[i] ^= 1 &lt;&lt; j - 1;
				mark[mat[i][j]] = true;
			}
	memset(f, 0, size);
	f[0] = 1;
	for (i = 0; i &lt; 18; ++i) {
		t = f, f = g, g = t;
		memset(f, 0, size);
		for (j = 0; j &lt;= a[i]; ++j)
			if (g[j]) for (k = 0; k &lt;= a[i + 1]; ++k)
						  if (!(j&amp;k) &amp;&amp; !(k &amp; (k &gt;&gt; 1)))
							  add(f[k], g[j]);
	}
	return f[0];
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	mx = n + 1;
	long long ans = 1LL;
	for (int i = 1; i &lt;= n; ++i)
		if (!mark[i]) ans = ans * cal(i) % mo;
	printf(&quot;%d\n&quot;, (int)ans);
	return 0;
}
<pre><h2>Problem2741</h2><pre>#include &lt;cstdio&gt;

const int MaxN = 12002, MaxS =  MaxN * 32;
struct node {
	int last;
	node *c[2];
} node_mset[MaxS], *cnode = node_mset, *root[MaxN];

void Insert(node *x, const int &amp;p, const int &amp;val) {
	node *y = root[p] = ++cnode;
	y-&gt;last = p;
	for (int i = 1 &lt;&lt; 30, j; i; i &gt;&gt;= 1) {
		j = (val &amp; i) ? 1 : 0;
		y-&gt;c[j ^ 1] = x-&gt;c[j ^ 1];
		y-&gt;c[j] = ++cnode;
		x = x-&gt;c[j];
		y = y-&gt;c[j];
		y-&gt;last = p;
	}
}

int Query(int l, int r, const int &amp;val) {
	node *x = root[r];
	int ans = 0;
	for (int i = 1 &lt;&lt; 30, j; i; i &gt;&gt;= 1) {
		j = (val &amp; i) ? 0 : 1;
		if (x-&gt;c[j]-&gt;last &gt;= l)
		  ans ^= i;
		else
		  j ^= 1;
		x = x-&gt;c[j];
	}
	return ans;
}

int a[MaxN], pre[125][MaxN];

inline int max(const int &amp;a, const int &amp;b) {
	return a &lt; b ? b : a;
}

inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
#endif
	int n, m, blo, cnt, lastans = 0, x, y, bg;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (blo = 1; blo * blo &lt;= n; ++blo);
	cnt = n / blo + (n % blo != 0);
	*cnode = (node) { -1 , {cnode, cnode}};
	Insert(cnode, 0, 0);
	for (int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, a + i);
		a[i] ^= a[i - 1];
		Insert(root[i - 1], i, a[i]);
	}
	for (int i = 0; i &lt; cnt; ++i)
	  for (int j = i * blo + 1, st = i * blo; j &lt;= n; ++j)
		pre[i][j] = max(pre[i][j - 1], Query(st, j - 1, a[j]));

	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		x = (x + lastans % n) % n + 1;
		y = (y + lastans % n) % n + 1;
		if (x &gt; y) x ^= y ^= x ^= y;
		--x;
		bg = x / blo + (x % blo != 0);
		if (bg * blo &lt; y) {
			lastans = pre[bg][y];
			bg = bg * blo;
		} else {
			bg = y;
			lastans = 0;
		}
		for (int i = x; i &lt;= bg; ++i)
		  cmax(lastans, Query(x, y, a[i]));
		printf(&quot;%d\n&quot;, lastans);
	}

	return 0;
}<pre><h2>Problem2743</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
typedef int arr[1000005];
arr C, pre, last, ans;
int n, m, c;
struct query {
	int l, r, id;
}q[1000005];
bool operator &lt; (const query&amp;a,const query&amp;b) {
	return a.r &lt; b.r;
}
void add(int x,int v) {
	for (; x &lt;= n; x += x &amp; -x)
		C[x] += v;
}
int sum(int x) {
	static int r;
	for (r = 0; x; x -= x &amp; -x)
		r += C[x];
	return r;
}
int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;c, &amp;m);
	for (int i = 1, a; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a);
		pre[i] = last[a];
		last[a] = i;
	}
	for (int i = 1, l, r; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		q[i] = (query){l, r, i};
	}
	std::sort(q + 1, q + m + 1);
	for (int i = 1, j = 1; i &lt;= n; ++i) {
		if (pre[i]) add(pre[i], 1);
		if (pre[pre[i]]) add(pre[pre[i]], -1);
		while (i == q[j].r) {
			ans[q[j].id] = sum(q[j].r) - sum(q[j].l - 1);
			if (++j &gt; m) i = n;
		}
	}
	for (int i = 1; i &lt;= m; ++i)
		printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}
<pre><h2>Problem2744</h2><pre>#include &lt;cstdio&gt;
#define _A 203
#define _B 3003
struct edge {int t; edge *n;} me[_B *_B &gt;&gt; 2 | 1], *g[_B], *ce = me;
#define adde(a, b) (*ce = (edge){b, g[a]}, g[a] = ce++)
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)
int a[_A], b[_B], A, B, vis[_B], _vis, lk[_B];
bool mp[_A][_B], able[_B];
inline int Count(int x) {
	static int r;
	for (r = 0; x; x = x &amp; (x - 1)) ++r;
	return r;
}
inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

bool dfs(int u) {
	for (edge *it = g[u]; it; it = it-&gt;n)
	  if (able[it-&gt;t] &amp;&amp; (vis[it-&gt;t] ^ _vis)) {
		  vis[it-&gt;t] = _vis;
		  if (!lk[it-&gt;t] || dfs(lk[it-&gt;t]))
			return lk[it-&gt;t] = u, true;
	  }
	return false;
}

inline int hunger(int x = 0, int y = 0) {
	static int r;
	r = 0;
	rep(i, 1, B)
		if (lk[i] = 0, mp[x][i] &amp;&amp; mp[y][i])
		  able[i] = true, ++r;
		else able[i] = false;
	rep(i, 1, B) 
		if ((b[i] &amp; 1) &amp;&amp; able[i] &amp;&amp; (++_vis, dfs(i)))
		  --r;
	return r;
}

int main() {
	int m, u, v, ans;
	scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;m);
	rep(i, 1, A) scanf(&quot;%d&quot;, a + i);
	rep(i, 1, B) scanf(&quot;%d&quot;, b + i);
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		mp[u][v] = true;
	}
	rep(i, 1, B) mp[0][i] = true;
	rep(i, 1, B)
		if (b[i] &amp; 1)
		  rep(j, 1, B)
			  if ((~b[j] &amp; 1) &amp;&amp; (~Count(b[i] | b[j]) &amp; 1))
				adde(i, j);
	ans = hunger();
	rep(i, 1, A)
		cmax(ans, hunger(i) + 1);
	rep(i, 1, A)
		if (a[i] &amp; 1)
		  rep(j, 1, A)
			  if (~a[j] &amp; 1)
				cmax(ans, hunger(i, j) + 2);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem2753</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int MaxN = 100003, MaxM = 1000000 * 2 + 1;

bool mark[MaxN];
int h[MaxN], f[MaxN], que[MaxN];

struct eg {
	int to;
	eg *nxt;
} eg_mset[MaxM], *g[MaxN], *ceg = eg_mset;

void add_eg(int u, int v) {
	*ceg = (eg) {v, g[u]};
	g[u] = ceg++;
}

struct edge {
	int u, v, w;
	bool operator &lt; (const edge &amp;a) const {
		return (h[v] ^ h[a.v]) ? h[v] &gt; h[a.v] : w &lt; a.w;
	}
} e[MaxM &gt;&gt; 1];

inline int gf(int u) {
	static int r, t;
	for (r = u; f[r] ^ r; r = f[r]);
	while (u ^ r) t = f[u], f[u] = r, u = t;
	return r;
}

int main() {
	eg *it;
	long long sum = 0LL;
	int n, m, u, v, w, i, cnt = 0, *l = que, *r = que;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, h + i);
		f[i] = i;
	}
	for (i = 0; i &lt;  m; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		if (h[u] &lt; h[v]) std::swap(u, v);
		if (h[u] ^ h[v]) add_eg(u, v);
		else add_eg(u, v), add_eg(v, u);
		e[i] = (edge){u, v, w};
	}
	mark[1] = true;
	for (*r++ = 1; l &lt; r;) {
		u = *l++;
		++cnt;
		for (it = g[u]; it; it = it-&gt;nxt)
			if (!mark[it-&gt;to]) {
				*r++ = it-&gt;to;
				mark[it-&gt;to] = true;
			}
	}
	std::sort(e, e + m);
	for (i = 0; i &lt; m; ++i)
		if (mark[e[i].u] &amp;&amp; mark[e[i].v]) {
			u = gf(e[i].u);
			v = gf(e[i].v);
			if (u == v)
				continue;
			f[u] = v;
			sum += e[i].w;
		}
	printf(&quot;%d %lld\n&quot;, cnt, sum);
	return 0;
}
<pre><h2>Problem2754</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int maxn(3e5 + 1e2);
typedef int arr[maxn];
#define rep(i, l, r) for (i = l; i &lt; r; ++i)

inline bool cmp(int *r, int i, int j, int len) {
	return r[i] == r[j] &amp;&amp; r[i + len] == r[j + len];
}

arr str, sa, rk, ht, ta, tb;

inline void da(int n, int m) {
	int i, j, p, *x = ta, *y = tb, *t;
	static arr s;
	rep(i, 0, m) s[i] = 0;
	rep(i, 0, n) ++s[x[i] = str[i]];
	rep(i, 1, m) s[i] += s[i - 1];
	for (i = n - 1; ~i; --i) sa[--s[x[i]]] = i;
	for (p = j = 1; p &lt; n; j &lt;&lt;= 1, m = p) {
		for (p = 0, i = n - j; i &lt; n; ++i) y[p++] = i;
		rep(i, 0, n) if (sa[i] &gt;= j) y[p++] = sa[i] - j;
		rep(i, 0, m) s[i] = 0;
		rep(i, 0, n) ++s[x[y[i]]];
		rep(i, 1, m) s[i] += s[i - 1];
		for (i = n - 1; ~i; --i) sa[--s[x[y[i]]]] = y[i];
		for (t = x, x = y, y = t, i = p = 1, x[sa[0]] = 0; i &lt; n; ++i)
			x[sa[i]] = cmp(y, sa[i], sa[i - 1], j) ? p - 1 : p++;
		//rep(i, 0, n) printf(&quot;%d &quot;, sa[i]);
		//puts(&quot;&quot;);
	}
}

inline void calcht(int n) {
	int i, j, k(0);
	rep(i, 0, n) rk[sa[i]] = i;
	for (i = 0; i &lt; n; ht[rk[i++]] = k)
		if (rk[i]) for (k ? --k : 0, j = sa[rk[i] - 1]; str[i + k] == str[j + k]; ++k);
}

arr vis, ans, from, que, length;

int main() {

	//freopen(&quot;2754.in&quot;, &quot;r&quot;, stdin);

	int n, m, _vis(0), x, len(0);

	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

	memset(from, -1, sizeof from);
	for (register int i = 0; i &lt; n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		for (register int j = 0; j &lt; x; ++j)
			scanf(&quot;%d&quot;, &amp;str[len]), from[len++] = i;
		str[len++] = 10001;
		scanf(&quot;%d&quot;, &amp;x);
		for (register int j = 0; j &lt; x; ++j)
			scanf(&quot;%d&quot;, &amp;str[len]), from[len++] = i;
		str[len++] = 10001;
	}

	for (register int i = 0; i &lt; m; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		que[i] = len;
		length[i] = x;
		for (register int j = 0; j &lt; x; ++j)
			scanf(&quot;%d&quot;, &amp;str[len++]);
		str[len++] = 10001;
	}
	str[len] = -1;
	da(len, 10002);
	calcht(len);
	for (register int i = 0; i &lt; m; ++i) {
		static int p, tot;
		tot = 0;
		++_vis;
		p = rk[que[i]];
		while (ht[p] &gt;= length[i]) {
			if ((~from[sa[p - 1]]) &amp;&amp; (vis[from[sa[p - 1]]] ^ _vis)) {
				vis[from[sa[p - 1]]] = _vis;
				++tot;
				++ans[from[sa[p - 1]]];
			}
			if (!--p) break;
		}
		p = rk[que[i]];
		while (ht[p + 1] &gt;= length[i]) {
			if ((~from[sa[p + 1]]) &amp;&amp; (vis[from[sa[p + 1]]] ^ _vis)) {
				vis[from[sa[p + 1]]] = _vis;
				++tot;
				++ans[from[sa[p + 1]]];
			}
			if (++p &gt;= len) break;
		}
		printf(&quot;%d\n&quot;, tot);
	}
	printf(&quot;%d&quot;, ans[0]);
	for (register int i = 1; i &lt; n; ++i) printf(&quot; %d&quot;, ans[i]);
	return 0;
}<pre><h2>Problem2756</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0'||'9'&lt;c)f|=c=='-';a=c-'0';
	while(c=getc(),!(c&lt;'0'||'9'&lt;c))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 1610
#define M 20000
const long long inf=1LL&lt;&lt;50;
int d[N],dt[N],S,T,la[N];
int to[M],nt[M],hd[N],n,m,te;
long long C[M];
int mp[42][42],idx[42][42];
inline void adde(int a,int b,long long c) {
	to[te]=b;nt[te]=hd[a];C[te]=c;hd[a]=te++;
	to[te]=a;nt[te]=hd[b];C[te]=0;hd[b]=te++;
}
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
long long dfs(int u,long long flow) {
	if(u==T||!flow)return flow;
	long long r=0,t;
	for(int&amp;i=la[u];~i;i=nt[i])
		if(d[u]==d[to[i]]+1&amp;&amp;C[i]&gt;0) {
			t=dfs(to[i],flow&lt;C[i]?flow:C[i]);
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(d[S]&gt;T+1||!flow)return r;
		}
	la[u]=hd[u];
	if(!(--dt[d[u]]))d[S]=T+2;
	++dt[++d[u]];return r;
}
inline bool check(long long x) {
	memset(hd,-1,sizeof hd);
	int i,j,k,_i,_j; te=0;
	long long t=0,st=0;
	for(i=1;i&lt;=n;++i)
		for(j=1;j&lt;=m;++j)
			if((i+j)&amp;1) {
				adde(S,idx[i][j],x-mp[i][j]);
				st+=x-mp[i][j];
				for(k=0;k^4;++k) {
					_i=i+dx[k],_j=j+dy[k];
					if(_i&lt;1||_j&lt;1||_i&gt;n||_j&gt;m)continue;
					adde(idx[i][j],idx[_i][_j],inf);
				}
			}else adde(idx[i][j],T,x-mp[i][j]);
	i=j=0;dt[j++]=T;
	memset(d,0,sizeof d);
	d[T]=1;
	while(i&lt;j) {
		k=dt[i++];
		for(_i=hd[k];~_i;_i=nt[_i])
			if(!d[to[_i]])d[dt[j++]=to[_i]]=d[k]+1;
	}
	memset(dt,0,sizeof dt);
	for(i=S;i&lt;=T;++i)++dt[d[i]],la[i]=hd[i];
	while(d[S]&lt;T+2)t+=dfs(S,inf);
	return st==t;
}
#define getskip(a) (a*n*m-s0-s1)&gt;&gt;1
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;2756.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;2756.out&quot;,&quot;w&quot;,stdout);
#endif
	int __=geti(),i,j,id;
	long long s0,s1,mv,l,r,mi,an;
	while(__--) {
		n=geti(),m=geti();
		s0=s1=0LL;mv=-inf;
		for(id=0,i=1;i&lt;=n;++i)
			for(j=1;j&lt;=m;++j) {
				if((mp[i][j]=geti())&gt;mv)mv=mp[i][j];
				if((i+j)&amp;1)s1+=mp[i][j];
				else s0+=mp[i][j];
				idx[i][j]=++id;
			}
		S=0,T=++id;
		if(n*m&amp;1) {
			l=s0-s1;
			if(l&gt;=mv&amp;&amp;check(l))printf(&quot;%lld\n&quot;,getskip(l));
			else puts(&quot;-1&quot;);
		}else {
			if(s0^s1){puts(&quot;-1&quot;);continue;}
			for(l=mv,r=inf;l&lt;=r;) {
				mi=l+r&gt;&gt;1;
				if(check(mi))r=(an=mi)-1;
				else l=mi+1;
			}
			printf(&quot;%lld\n&quot;,getskip(an));
		}
	}
	return 0;
}
<pre><h2>Problem2756</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 1610
#define M 20000
const long long inf=1LL&lt;&lt;50;
int d[N],dt[N],S,T,la[N];
int to[M],nt[M],hd[N],n,m,te;
long long C[M];
int mp[42][42],idx[42][42];
inline void adde(int a,int b,long long c) {
	to[te]=b;nt[te]=hd[a];C[te]=c;hd[a]=te++;
	to[te]=a;nt[te]=hd[b];C[te]=0;hd[b]=te++;
}
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
long long dfs(int u,long long flow) {
	if(u==T||!flow)return flow;
	long long r=0,t;
	for(int&amp;i=la[u];~i;i=nt[i])
		if(d[u]==d[to[i]]+1&amp;&amp;C[i]&gt;0) {
			t=dfs(to[i],flow&lt;C[i]?flow:C[i]);
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(d[S]&gt;T+1||!flow)return r;
		}
	la[u]=hd[u];
	if(!(--dt[d[u]]))d[S]=T+2;
	++dt[++d[u]];return r;
}
inline bool check(long long x) {
	memset(hd,-1,sizeof hd);
	int i,j,k,_i,_j; te=0;
	long long t=0,st=0;
	for(i=0;i&lt;n;++i)
		for(j=0;j&lt;m;++j)
			if((i+j)&amp;1) {
				adde(S,idx[i][j],x-mp[i][j]);
				st+=x-mp[i][j];
				for(k=0;k^4;++k) {
					_i=i+dx[k],_j=j+dy[k];
					if(_i&lt;0||_j&lt;0||_i&gt;=n||_j&gt;=m)continue;
					adde(idx[i][j],idx[_i][_j],inf);
				}
			}else adde(idx[i][j],T,x-mp[i][j]);
	i=j=0;dt[j++]=T;
	memset(d,0,sizeof d);
	d[T]=1;
	while(i&lt;j) {
		k=dt[i++];
		for(_i=hd[k];~_i;_i=nt[_i])
			if(!d[to[_i]])d[dt[j++]=to[_i]]=d[k]+1;
	}
	memset(dt,0,sizeof dt);
	for(i=S;i&lt;=T;++i)++dt[d[i]],la[i]=hd[i];
	while(d[S]&lt;T+2)t+=dfs(S,inf);
	return st==t;
}
#define getskip(a) (a*n*m-s0-s1)&gt;&gt;1
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;2756.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;2756.out&quot;,&quot;w&quot;,stdout);
#endif
	int __=geti(),i,j,id;
	long long s0,s1,mv,l,r,mi,an;
	while(__--) {
		n=geti(),m=geti();
		s0=s1=0LL;mv=-inf;
		for(id=i=0;i&lt;n;++i)
			for(j=0;j&lt;m;++j) {
				if((mp[i][j]=geti())&gt;mv)mv=mp[i][j];
				if((i+j)&amp;1)s1+=mp[i][j];
				else s0+=mp[i][j];
				idx[i][j]=++id;
			}
		S=0,T=++id;
		if(n*m&amp;1) {
			l=s0-s1;
			if(l&gt;=mv&amp;&amp;check(l))printf(&quot;%lld\n&quot;,getskip(l));
			else puts(&quot;-1&quot;);
		}else {
			if(s0^s1){puts(&quot;-1&quot;);continue;}
			for(l=mv,r=inf;l&lt;=r;) {
				mi=l+r&gt;&gt;1;
				if(check(mi))r=(an=mi)-1;
				else l=mi+1;
			}
			printf(&quot;%lld\n&quot;,getskip(an));
		}
	}
	return 0;
}
<pre><h2>Problem2756</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc(),c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 1610
#define M 20000
const long long inf=1LL&lt;&lt;50;
int d[N],dt[N],S,T,la[N];
int to[M],nt[M],hd[N],n,m,te;
long long C[M];
int mp[42][42],idx[42][42];
inline void adde(int a,int b,long long c) {
	to[te]=b;nt[te]=hd[a];C[te]=c;hd[a]=te++;
	to[te]=a;nt[te]=hd[b];C[te]=0;hd[b]=te++;
}
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
long long dfs(int u,long long flow) {
	if(u==T||!flow)return flow;
	long long r=0,t;
	for(int&amp;i=la[u];~i;i=nt[i])
		if(d[u]==d[to[i]]+1&amp;&amp;C[i]) {
			t=dfs(to[i],flow&lt;C[i]?flow:C[i]);
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(d[S]&gt;T+1||!flow)return r;
		}
	la[u]=hd[u];
	if(!(--dt[d[u]]))d[S]=T+2;
	++dt[++d[u]];return r;
}
inline bool check(long long x) {
	memset(hd,-1,(T+1)&lt;&lt;2);
	int i,j,k,_i,_j;te=0;
	long long t=0,st=0;
	for(i=0;i&lt;n;++i)
		for(j=0;j&lt;m;++j)
			if((i+j)&amp;1){
				adde(S,idx[i][j],x-mp[i][j]);
				st+=x-mp[i][j];
				for(k=0;k^4;++k) {
					_i=i+dx[k],_j=j+dy[k];
					if(_i&lt;0||_j&lt;0||_i&gt;=n||_j&gt;=m)continue;
					adde(idx[i][j],idx[_i][_j],inf);
				}
			}else adde(idx[i][j],T,x-mp[i][j]);
	i=j=0;dt[j++]=T;
	memset(d,0,sizeof d);
	d[T]=1;
	while(i&lt;j) {
		k=dt[i++];
		for(_i=hd[k];~_i;_i=nt[_i])
			if(!d[to[_i]])d[dt[j++]=to[_i]]=d[k]+1;
	}
	memset(dt,0,(T+1)&lt;&lt;2);
	for(i=S;i&lt;=T;++i)++dt[d[i]],la[i]=hd[i];
	while(d[S]&lt;T+2)t+=dfs(S,inf);
	return st==t;
}
#define getskip(a) (a*n*m-s0-s1)&gt;&gt;1
int main() {
	register int __=geti(),i,j,id;
	register long long s0,s1,mv,l,r,mi,an;
	while(__--) {
		n=geti(),m=geti();
		s0=s1=0LL;mv=-inf;
		for(id=i=0;i&lt;n;++i)
			for(j=0;j&lt;m;++j) {
				if((mp[i][j]=geti())&gt;mv)mv=mp[i][j];
				if((i+j)&amp;1)s1+=mp[i][j];
				else s0+=mp[i][j];
				idx[i][j]=++id;
			}
		S=0,T=++id;
		if(n*m&amp;1) {
			l=s0-s1;
			if(l&gt;=mv&amp;&amp;check(l))printf(&quot;%lld\n&quot;,getskip(l));
			else puts(&quot;-1&quot;);
		}else {
			if(s0^s1){puts(&quot;-1&quot;);continue;}
			for(l=mv,r=inf;l&lt;=r;) {
				mi=l+r&gt;&gt;1;
				if(check(mi))r=(an=mi)-1;
				else l=mi+1;
			}
			printf(&quot;%lld\n&quot;,getskip(an));
		}
	}
	return 0;
}
<pre><h2>Problem2756</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c,f=0;
	while(c=getc,c&lt;'0')f|=c=='-';a=c-'0';
	while(c=getc,'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return f?-a:a;
}
#define N 1610
#define M 20000
const long long inf=1LL&lt;&lt;50;
int d[N],dt[N],S,T,la[N];
int to[M],nt[M],hd[N],n,m,te;
long long C[M];
int mp[42][42],idx[42][42];
inline void adde(int a,int b,long long c) {
	to[te]=b;nt[te]=hd[a];C[te]=c;hd[a]=te++;
	to[te]=a;nt[te]=hd[b];C[te]=0;hd[b]=te++;
}
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
long long dfs(int u,long long flow) {
	if(u==T||!flow)return flow;
	long long r=0,t;
	for(int&amp;i=la[u];~i;i=nt[i])
		if(d[u]==d[to[i]]+1&amp;&amp;C[i]) {
			t=dfs(to[i],flow&lt;C[i]?flow:C[i]);
			r+=t,flow-=t;
			C[i]-=t,C[i^1]+=t;
			if(d[S]&gt;T+1||!flow)return r;
		}
	la[u]=hd[u];
	if(!(--dt[d[u]]))d[S]=T+2;
	++dt[++d[u]];return r;
}
inline bool check(long long x) {
	memset(hd,-1,(T+1)&lt;&lt;2);
	register int i,j,k,_i,_j;te=0;
	register long long t=0,st=0;
	for(i=0;i&lt;n;++i)
		for(j=0;j&lt;m;++j)
			if((i+j)&amp;1){
				adde(S,idx[i][j],x-mp[i][j]);
				st+=x-mp[i][j];
				for(k=0;k^4;++k) {
					_i=i+dx[k],_j=j+dy[k];
					if(_i&lt;0||_j&lt;0||_i&gt;=n||_j&gt;=m)continue;
					adde(idx[i][j],idx[_i][_j],inf);
				}
			}else adde(idx[i][j],T,x-mp[i][j]);
	i=j=0;dt[j++]=T;
	memset(d,0,sizeof d);
	d[T]=1;
	while(i&lt;j) {
		k=dt[i++];
		for(_i=hd[k];~_i;_i=nt[_i])
			if(!d[to[_i]])d[dt[j++]=to[_i]]=d[k]+1;
	}
	memset(dt,0,(T+1)&lt;&lt;2);
	for(i=S;i&lt;=T;++i)++dt[d[i]],la[i]=hd[i];
	while(d[S]&lt;T+2)t+=dfs(S,inf);
	return (st^t)?0:1;
}
#define getskip(a) (a*n*m-s0-s1)&gt;&gt;1
int main() {
	register int __=geti(),i,j,id;
	register long long s0,s1,mv,l,r,mi,an;
	while(__--) {
		n=geti(),m=geti();
		s0=s1=0LL;mv=-inf;
		for(id=i=0;i&lt;n;++i)
			for(j=0;j&lt;m;++j) {
				if((mp[i][j]=geti())&gt;mv)mv=mp[i][j];
				if((i+j)&amp;1)s1+=mp[i][j];
				else s0+=mp[i][j];
				idx[i][j]=++id;
			}
		S=0,T=++id;
		if(n*m&amp;1) {
			l=s0-s1;
			if(l&gt;=mv&amp;&amp;check(l))printf(&quot;%lld\n&quot;,getskip(l));
			else puts(&quot;-1&quot;);
		}else {
			if(s0^s1){puts(&quot;-1&quot;);continue;}
			for(l=mv,r=inf;l&lt;=r;) {
				mi=l+r&gt;&gt;1;
				if(check(mi))r=(an=mi)-1;
				else l=mi+1;
			}
			printf(&quot;%lld\n&quot;,getskip(an));
		}
	}
	return 0;
}
<pre><h2>Problem2756</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
    register int a; register char c,f=0;
    while(c=getc(),c&lt;'0'||'9'&lt;c)f|=c=='-';a=c-'0';
    while(c=getc(),!(c&lt;'0'||'9'&lt;c))a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
    return f?-a:a;
}
#define N 1610
#define M 20000
const long long inf=1LL&lt;&lt;50;
int d[N],dt[N],S,T,la[N];
int to[M],nt[M],hd[N],n,m,te;
long long C[M];
int mp[42][42],idx[42][42];
inline void adde(int a,int b,long long c) {
    to[te]=b;nt[te]=hd[a];C[te]=c;hd[a]=te++;
    to[te]=a;nt[te]=hd[b];C[te]=0;hd[b]=te++;
}
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
long long dfs(int u,long long flow) {
    if(u==T||!flow)return flow;
    long long r=0,t;
    for(int&amp;i=la[u];~i;i=nt[i])
        if(d[u]==d[to[i]]+1&amp;&amp;C[i]&gt;0) {
            t=dfs(to[i],flow&lt;C[i]?flow:C[i]);
            r+=t,flow-=t;
            C[i]-=t,C[i^1]+=t;
            if(d[S]&gt;T+1||!flow)return r;
        }
    la[u]=hd[u];
    if(!(--dt[d[u]]))d[S]=T+2;
    ++dt[++d[u]];return r;
}
inline bool check(long long x) {
    memset(hd,-1,sizeof hd);
    int i,j,k,_i,_j; te=0;
    long long t=0,st=0;
    for(i=1;i&lt;=n;++i)
        for(j=1;j&lt;=m;++j)
            if((i+j)&amp;1) {
                adde(S,idx[i][j],x-mp[i][j]);
                st+=x-mp[i][j];
                for(k=0;k^4;++k) {
                    _i=i+dx[k],_j=j+dy[k];
                    if(_i&lt;1||_j&lt;1||_i&gt;n||_j&gt;m)continue;
                    adde(idx[i][j],idx[_i][_j],inf);
                }
            }else adde(idx[i][j],T,x-mp[i][j]);
    i=j=0;dt[j++]=T;
    memset(d,0,sizeof d);
    d[T]=1;
    while(i&lt;j) {
        k=dt[i++];
        for(_i=hd[k];~_i;_i=nt[_i])
            if(!d[to[_i]])d[dt[j++]=to[_i]]=d[k]+1;
    }
    memset(dt,0,sizeof dt);
    for(i=S;i&lt;=T;++i)++dt[d[i]],la[i]=hd[i];
    while(d[S]&lt;T+2)t+=dfs(S,inf);
    return st==t;
}
#define getskip(a) (a*n*m-s0-s1)&gt;&gt;1
int main() {
#ifndef ONLINE_JUDGE
    freopen(&quot;2756.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;2756.out&quot;,&quot;w&quot;,stdout);
#endif
    int __=geti(),i,j,id;
    long long s0,s1,mv,l,r,mi,an;
    while(__--) {
        n=geti(),m=geti();
        s0=s1=0LL;mv=-inf;
        for(id=0,i=1;i&lt;=n;++i)
            for(j=1;j&lt;=m;++j) {
                if((mp[i][j]=geti())&gt;mv)mv=mp[i][j];
                if((i+j)&amp;1)s1+=mp[i][j];
                else s0+=mp[i][j];
                idx[i][j]=++id;
            }
        S=0,T=++id;
        if(n*m&amp;1) {
            l=s0-s1;
            if(l&gt;=mv&amp;&amp;check(l))printf(&quot;%lld\n&quot;,getskip(l));
            else puts(&quot;-1&quot;);
        }else {
            if(s0^s1){puts(&quot;-1&quot;);continue;}
            for(l=mv,r=inf;l&lt;=r;) {
                mi=l+r&gt;&gt;1;
                if(check(mi))r=(an=mi)-1;
                else l=mi+1;
            }
            printf(&quot;%lld\n&quot;,getskip(an));
        }
    }
    return 0;
}<pre><h2>Problem2757</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int mod(20120427), maxl(20), maxs(6e4);

namespace Not_Zero {
	long long e[maxl], h[maxs];
	int cnt, c1[maxs][10], c2[maxs][10], f[maxl][maxs][2];

	inline int search(const long long &amp;x) {
		return std::lower_bound(h, h + cnt, x) - h;
	}

	inline void init() {
		for (int i = *e = 1; i &lt; maxl; ++i) e[i] = e[i - 1] * 10;
		const long long v = 16e16;
		for (long long x = 1; x &lt; v; x *= 2)
			for (long long y = x; y &lt; v; y *= 3)
				for (long long z = y; z &lt; v; z *= 5)
					for (long long a = z; a &lt; v; a *= 7)
						h[cnt++] = a;
		std::sort(h, h + cnt);
		memset(c1, -1, sizeof c1);
		memset(c2, -1, sizeof c2);
		for (int i = 0; i &lt; cnt; ++i)
			for (int j = 9; j; --j)
				if (h[i] * j &lt; v)
					c2[c1[i][j] = search(h[i] * j)][j] = i;

		f[0][0][0] = 1;

		for (int i = 0; i &lt; 18; ++i)
			for (int j = 0; j &lt; cnt; ++j) {
				int const *t = f[i][j];
				if (!*t) continue;
				for (int k = 9; k; --k)
					if (~c1[j][k]) {
						int * const g = f[i + 1][c1[j][k]];
						*g += *t;
						if (*g &gt;= mod) *g -= mod;
						g[1] = (g[1] + t[1] + k * e[i] % mod * *t) % mod;
					}
			}
	}

	inline int calc(int p, long long x) {
		static int cnt, dig[maxl], res;
		cnt = res = 0;
		for (long long t = x; t; t /= 10) dig[cnt++] = t % 10;
		for (int i = 1; i &lt; cnt; ++i) {
			res += f[i][p][1];
			if (res &gt;= mod) res -= mod;
		}
		for (int i = cnt - 1; ~i; --i) {
			static long long t;
			t = x / e[i + 1] * 10;
			for (int j = 1; j &lt; dig[i]; ++j)
				if (~c2[p][j]) {
					const int * const g = f[i][c2[p][j]];
					res = (res + g[1] + (t + j) * e[i] % mod * *g) % mod;
				}
			p = c2[p][dig[i]];
			if (p &lt; 0) break;
		}
		return res;
	}

	inline void main(const long long &amp;a, const long long &amp;b, const long long &amp;k) {
		int p = search(k);
		if (h[p] ^ k)
			puts(&quot;0&quot;);
		else {
			int t = calc(p, b + 1) - calc(p, a) + mod;
			if (t &gt;= mod) t -= mod;
			printf(&quot;%d\n&quot;, t);
		}
	}

}

namespace Is_Zero {

	inline int S(int a, int b, int c, int d, int e) {
		return (a &lt;&lt; 4) | (b &lt;&lt; 3) | (c &lt;&lt; 2) | (d &lt;&lt; 1) | e;
	}

	inline void add(int &amp;a, const int &amp;b) {
		for (a += b; a &gt;= mod; a -= mod);
	}

	inline void main(long long a, long long b) {
		static int cnt, d1[maxl], d2[maxl], f[maxl][33];
		for (--a, ++b, cnt = 0; b; a /= 10, b /= 10, ++cnt)
			d1[cnt] = a % 10, d2[cnt] = b % 10;
		for (int i = cnt; i &lt; maxl; ++i) d1[i] = d2[i] = 0;

		memset(f, 0, sizeof f);
		f[cnt][S(1, 1, 0, 1, 0)] = 1;

		for (int a = cnt - 1; ~a; --a)
			for (int b = 1; ~b; --b)
				for (int c = 1; ~c; --c) {
					int s = b ? d1[a] : 0, t = c ? d2[a] : 9;
					for (int d = 1; ~d; --d)
						for (int e = s; e &lt;= t; ++e) {
#define X(i, j) f[a + 1][S(b, c, d, i, j)]
#define Y(i, j, k) f[a][S(b &amp;&amp; e == s, c &amp;&amp; e == t, i, j, k)]
							add(Y(d | !e, 0, 0), X(0, 0));
							add(Y(d | !e, 0, 1), X(0, 1) * 10 + e * X(0, 0));
							add(Y(0, !e, 0), X(1, 0));
							add(Y(0, !e, 1), X(1, 0) * e);
						}
				}
		printf(&quot;%d\n&quot;, f[0][S(0, 0, 1, 0, 1)]);
	}

}

int main() {

	Not_Zero::init();
	//Is_Zero::init();

	int o_o;
	long long a, b, k;

	scanf(&quot;%d&quot;, &amp;o_o);

	while (o_o--) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;k);

		if (k)
			Not_Zero::main(a, b, k);
		else
			Is_Zero::main(a, b);
	}

	return 0;
}
<pre><h2>Problem2806</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxS = 1100013;

struct node {
	int step;
	node *pre, *ch[3];
} node_mest[MaxS * 2], *cnode = node_mest, *root, *last;

inline node *newnode(const int &amp;step) {
	cnode-&gt;step = step;
	return cnode++;
}

inline void Insert(const int &amp;c) {
	node *p = last, *np = newnode(p-&gt;step + 1);
	last = np;
	for (; p &amp;&amp; !p-&gt;ch[c]; p = p-&gt;pre)
		p-&gt;ch[c] = np;
	if (!p)
		np-&gt;pre = root;
	else {
		node *q = p-&gt;ch[c];
		if (q-&gt;step == p-&gt;step + 1)
			np-&gt;pre = q;
		else {
			node *nq = newnode(p-&gt;step + 1);
			memcpy(nq-&gt;ch, q-&gt;ch, sizeof nq-&gt;ch);
			nq-&gt;pre = q-&gt;pre;
			q-&gt;pre = np-&gt;pre = nq;
			for (; p &amp;&amp; p-&gt;ch[c] == q; p = p-&gt;pre)
				p-&gt;ch[c] = nq;
		}
	}
}

int dp[MaxS], f[MaxS], g[MaxS], q[MaxS];
char s[MaxS];

inline void predp(const int &amp;n) {
	node *u = root;
	int match = 0, idx;
	for (int i = 1; i &lt;= n; ++i) {
		idx = s[i] - 48;
		if (u-&gt;ch[idx]) {
			u = u-&gt;ch[idx];
			++match;
		} else {
			while (u &amp;&amp; !u-&gt;ch[idx]) u = u-&gt;pre;
			if (u) match = u-&gt;step + 1, u = u-&gt;ch[idx];
			else u = root, match = 0;
		}
		dp[i] = match;
	}
}

inline int check(int x, const int &amp;n) {
	int *l = q, *r = q, t;
	for (int i = 1; i &lt;= n; ++i) {
		if ((t = i - x) &gt;= 0) {
			while (l &lt; r &amp;&amp; g[r[-1]] &lt; g[t]) --r;
			*r++ = t;
		}
		while (l &lt; r &amp;&amp; *l &lt; i - dp[i]) ++l;
		f[i] = f[i - 1];
		if (l &lt; r &amp;&amp; f[i] &lt; g[*l] + i)
			f[i] = g[*l] + i;
		g[i] = f[i] - i;
	}
	return f[n];
}

int main() {
	int n, m, len, need, l, r, mid;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	last = root = newnode(0);
	while (m--) {
		scanf(&quot;%s&quot;, s);
		for (char *i = s; *i; ++i)
			Insert(*i - 48);
		if (m) Insert(2);
	}
	while (n--) {
		scanf(&quot;%s&quot;, s + 1);
		len = strlen(s + 1);
		need = (int)(ceil((double)len * 0.9));
		predp(len);
		if (check(1, len) &lt; need) {
			puts(&quot;0&quot;);
			continue;
		}
		for (l = 2, r = len; l &lt;= r; )
			if (mid = (l + r) &gt;&gt; 1,check(mid, len) &gt;= need)
				l = mid + 1;
			else
				r = mid - 1;
		printf(&quot;%d\n&quot;, r);
	}
	return 0;
}<pre><h2>Problem2809</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int MaxN = 100005;

struct edge {
	int to;
	edge *nxt;
}edge_mset[MaxN], *g[MaxN], *cedge = edge_mset;

inline void add_edge(int u, int v) {
	*cedge = (edge) {v, g[u]};
	g[u] = cedge++;
}

struct node {
	int val;
	node *ls, *rs;
	//void pop();
	//int top() const;
} node_mset[MaxN], *root[MaxN];

node *merge(node *x, node *y) {
	if (!x) return y;
	else if (!y) return x;
	if (x-&gt;val &lt; y-&gt;val)
		std::swap(x, y);
	x-&gt;rs = merge(x-&gt;rs, y);
	//if (x-&gt;rs-&gt;dep &gt; x-&gt;ls-&gt;dep)
	std::swap(x-&gt;ls, x-&gt;rs);
	//x-&gt;dep = x-&gt;rs-&gt;dep + 1;
	return x;
}

int L[MaxN], size[MaxN], m;
long long ans, sum[MaxN];

void dfs(int u) {
	size[u] = 1;
	sum[u] = root[u]-&gt;val;
	for (edge *it = g[u]; it; it = it-&gt;nxt) {
		dfs(it-&gt;to);
		sum[u] += sum[it-&gt;to];
		size[u] += size[it-&gt;to];
		root[u] = merge(root[u], root[it-&gt;to]);
	}
	while (sum[u] &gt; m) {
		sum[u] -= root[u]-&gt;val;
		//root[u]-&gt;pop();
		root[u] = merge(root[u]-&gt;ls, root[u]-&gt;rs);
		--size[u];
	}
	ans = std::max(ans, (long long)size[u] * L[u]);
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	//nil = node_mset;
	//*nil = (node) {0, -1, nil, nil};
	int n, u, i;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 1; i &lt;= n; ++i) {
		root[i] = node_mset + i;
		//node_mset[i] = *nil;
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;node_mset[i].val, L + i);
		add_edge(u, i);
		//node_mset[i].dep = 0;
	}
	dfs(1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem2809</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
 
const int MaxN = 100005;
 
struct edge {
    int to;
    edge *nxt;
}edge_mset[MaxN], *g[MaxN], *cedge = edge_mset;
 
inline void add_edge(int u, int v) {
    *cedge = (edge) {v, g[u]};
    g[u] = cedge++;
}
 
struct node {
    int val, dep;
    node *ls, *rs;
    void pop();
    int top() const;
} node_mset[MaxN], *root[MaxN], *nil;
 
node *merge(node *x, node *y) {
    if (x == nil) return y;
    else if (y == nil) return x;
    if (x-&gt;val &lt; y-&gt;val)
        std::swap(x, y);
    x-&gt;rs = merge(x-&gt;rs, y);
    if (x-&gt;rs-&gt;dep &gt; x-&gt;ls-&gt;dep)
        std::swap(x-&gt;ls, x-&gt;rs);
    x-&gt;dep = x-&gt;rs-&gt;dep + 1;
    return x;
}
 
int node :: top() const {
    return val;
}
 
int L[MaxN], size[MaxN], m;
long long ans, sum[MaxN];
 
void dfs(int u) {
    size[u] = 1;
    sum[u] = root[u]-&gt;val;
    for (edge *it = g[u]; it; it = it-&gt;nxt) {
        dfs(it-&gt;to);
        sum[u] += sum[it-&gt;to];
        size[u] += size[it-&gt;to];
        root[u] = merge(root[u], root[it-&gt;to]);
    }
    while (sum[u] &gt; m) {
        sum[u] -= root[u]-&gt;top();
        //root[u]-&gt;pop();
        root[u] = merge(root[u]-&gt;ls, root[u]-&gt;rs);
        --size[u];
    }
    ans = std::max(ans, (long long)size[u] * L[u]);
}
 
int main() {
    nil = node_mset;
    *nil = (node) {0, -1, nil, nil};
    int n, u, i;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (i = 1; i &lt;= n; ++i) {
        root[i] = node_mset + i;
        node_mset[i] = *nil;
        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;node_mset[i].val, L + i);
        add_edge(u, i);
        node_mset[i].dep = 0;
    }
    dfs(1);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}<pre><h2>Problem2956</h2><pre>#include &lt;cstdio&gt;

typedef unsigned long long u64;
const u64 mod = 19940417;
const u64 inv2 = 9970209, inv3 = 3323403;


inline u64 g1(u64 n, u64 m) {
	u64 ans = 0, i = 1, last, t;
	for (; i &lt;= n; i = last + 1) {
		t = m / i;
		last = m / t;
		if (last &gt; n) last = n;
		ans += ((last - i + 1) * (i + last) &gt;&gt; 1) % mod * t % mod;
		if (ans &gt;= mod) ans -= mod;
	}
	return ans;
}

inline u64 s2(u64 n) {
	u64 t1 = n, t2 = n + 1, t3 = n &lt;&lt; 1 | 1;
	if (t1 &amp; 1) t2 &gt;&gt;= 1;
	else t1 &gt;&gt;= 1;
	if (t1 % 3 == 0) t1 /= 3;
	else if (t2 % 3 == 0) t2 /= 3;
	else t3 /= 3;
	return t1 * t2 % mod * t3 % mod;
}

inline u64 min(const u64 &amp;a, const u64 &amp;b) {
	return a &lt; b ? a : b;
}

inline u64 g2(u64 n, u64 m, u64 k) {
	u64 ans = 0, i = 1, last, t1, t2;
	for (; i &lt;= k; i = last + 1) {
		t1 = n / i;
		t2 = m / i;
		last = min(k, min(n / t1, m / t2));
		ans += (s2(last) + mod - s2(i - 1)) % mod * t1 % mod * t2 % mod;
		if (ans &gt;= mod) ans -= mod;
	}
	return ans;
}

int main() {
	u64 n, m, ans, t1, t2;
	scanf(&quot;%llu%llu&quot;, &amp;n, &amp;m);
	if (n &lt; m) n ^= m ^= n ^= m;
	t1 = (n * n % mod + mod - g1(n, n)) % mod * (m * m % mod + mod - g1(m, m)) % mod;
	t2 = m * m % mod * n % mod + mod - g1(m, n) * m % mod + mod - g1(m, m) * n % mod + mod + g2(n, m, m);
	t2 %= mod;
	ans = t1 + mod - t2;
	if (ans &gt;= mod) ans -= mod;
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem2962</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define N 150000
#define mod 19940417
#define ll long long
using namespace std;

int lazy[N],zhs[N][21],size[N];
struct node{int sum[21];}ans[N];
bool rev[N];

int read()
{
    int x=0,y=1;
    char ch=getchar();
    while (ch&lt;'0' || ch&gt;'9') {if (ch=='-') y=-1;ch=getchar();}
    while (ch&gt;='0' &amp;&amp; ch&lt;='9') {x=x*10+ch-48;ch=getchar();}
    return x*y;
}

void add(int &amp;x,int y)
{
    x+=y;
    if (x&gt;=mod) x-=mod;
}

void up_date(int k)
{
     for (int i=1;i&lt;=20;i++)
     {
         ans[k].sum[i]=0;
         for (int j=1;j&lt;i;j++) add(ans[k].sum[i],(ll)ans[k&lt;&lt;1].sum[j]*ans[k&lt;&lt;1|1].sum[i-j]%mod);
         add(ans[k].sum[i],ans[k&lt;&lt;1].sum[i]);add(ans[k].sum[i],ans[k&lt;&lt;1|1].sum[i]);
     }
}

void ins(int k,int val)
{
     add(lazy[k],val);
     for (int i=20;i;i--)
     {
         int x=val,j;
         for (j=i-1;j;j--,x=(ll)x*val%mod)
             add(ans[k].sum[i],(ll)x*ans[k].sum[j]%mod*zhs[size[k]-j][i-j]%mod);
         add(ans[k].sum[i],(ll)x*zhs[size[k]][i]%mod);
     }
}

void turn(int k)
{
    int i; rev[k]^=1;
    if (lazy[k]) lazy[k]=mod-lazy[k];
    for (i=19;i&gt;0;i-=2) if (ans[k].sum[i]) ans[k].sum[i]=mod-ans[k].sum[i];
}

void build(int l,int r,int cur)
{
     size[cur]=r-l+1;
     if (l==r) {ans[cur].sum[1]=read()%mod;return;}
     int mid=(l+r)&gt;&gt;1;
     build(l,mid,cur&lt;&lt;1),build(mid+1,r,cur&lt;&lt;1|1),up_date(cur);
}

void push_down(int k)
{
    if (rev[k]) turn(k&lt;&lt;1),turn(k&lt;&lt;1|1),rev[k]=0;
    if (lazy[k])ins(k&lt;&lt;1,lazy[k]),ins(k&lt;&lt;1|1,lazy[k]),lazy[k]=0;
}


void fan(int l,int r,int k,int x,int y)
{
    if (l==x &amp;&amp; r==y){ turn(k); return; }
    int mid=l+r&gt;&gt;1; push_down(k);
    if (y&lt;=mid) fan(l,mid,k&lt;&lt;1,x,y);
    else if (x&gt;mid) fan(mid+1,r,k&lt;&lt;1|1,x,y);
         else fan(l,mid,k&lt;&lt;1,x,mid),fan(mid+1,r,k&lt;&lt;1|1,mid+1,y);
    up_date(k);
}

void jia(int L,int R,int cur,int l,int r,int val)
{
    if (l==L &amp;&amp; r==R) {ins(cur,val);return;}
    int mid=(L+R)&gt;&gt;1; push_down(cur);
    if (r&lt;=mid) jia(L,mid,cur&lt;&lt;1,l,r,val);
    else if (l&gt;mid) jia(mid+1,R,cur&lt;&lt;1|1,l,r,val); 
         else jia(L,mid,cur&lt;&lt;1,l,mid,val),jia(mid+1,R,cur&lt;&lt;1|1,mid+1,r,val);
    up_date(cur);
}

node ask(int L,int R,int cur,int l,int r,int val)
{
     if (l==L &amp;&amp; r==R) return ans[cur];
     int mid=(L+R)&gt;&gt;1; push_down(cur);
     if (l&gt;mid) return ask(mid+1,R,cur&lt;&lt;1|1,l,r,val);
     else if (r&lt;=mid) return ask(L,mid,cur&lt;&lt;1,l,r,val);
          else
          {
              node x=ask(L,mid,cur&lt;&lt;1,l,mid,val),y=ask(mid+1,R,cur&lt;&lt;1|1,mid+1,r,val),t;
              for (int i=1;i&lt;=val;i++)
              {
                  t.sum[i]=(x.sum[i]+y.sum[i])%mod;
                  for (int j=1;j&lt;i;j++) add(t.sum[i],(ll)x.sum[j]*y.sum[i-j]%mod);
              }
              return t;
          }
}

int main()
{
    int n=read(),m=read(),i,j;
    zhs[0][0]=1;
    for (i=1;i&lt;=n;i++)
    {
        zhs[i][0]=1;
        for (j=1;j&lt;=i &amp;&amp; j&lt;=20;j++) zhs[i][j]=(zhs[i-1][j-1]+zhs[i-1][j])%mod;
    }
    build(1,n,1);
    while (m--)
    {
          char ch=getchar();
          while (ch&lt;'A' || ch&gt;'Z') ch=getchar();
          if (ch=='I')
          {
               int x=read(),y=read(),z=read()%mod;
               if (z&lt;0) z+=mod; jia(1,n,1,x,y,z);
          }
          if (ch=='R')
          {
              int x=read(),y=read();
              fan(1,n,1,x,y);
          }
          if (ch=='Q')
          {
              int x=read(),y=read(),z=read();
              printf(&quot;%d\n&quot;,ask(1,n,1,x,y,z).sum[z]);
          }
    }
    return 0;
}<pre><h2>Problem2962</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define N 150000
#define mod 19940417
#define ll long long
using namespace std;

int lazy[N],zhs[N][21],size[N];
struct node{int sum[21];}ans[N];
bool rev[N];


inline char gc() {
	static char buffer[1&lt;&lt;16], *s = buffer, *e = buffer;
	if (s == e) e = (s = buffer) + fread(buffer, 1, 1&lt;&lt;16, stdin);
	return *s++;
}

inline int read() {
	static int a; static char c, f;
	for (f = 0; (c = gc()) &lt; '0'; f |= c == '-');
	for (a = c - '0'; '-' &lt; (c = gc()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
	return f ? -a : a;
}


void add(int &amp;x,int y)
{
    x+=y;
    if (x&gt;=mod) x-=mod;
}

void up_date(int k)
{
	for (int i=1;i&lt;=20;i++)
	{
		ans[k].sum[i]=0;
		for (int j=1;j&lt;i;j++) add(ans[k].sum[i],(ll)ans[k&lt;&lt;1].sum[j]*ans[k&lt;&lt;1|1].sum[i-j]%mod);
		add(ans[k].sum[i],ans[k&lt;&lt;1].sum[i]);add(ans[k].sum[i],ans[k&lt;&lt;1|1].sum[i]);
	}
}

void ins(int k,int val)
{
	add(lazy[k],val);
	for (int i=20;i;i--)
	{
		int x=val,j;
		for (j=i-1;j;j--,x=(ll)x*val%mod)
			add(ans[k].sum[i],(ll)x*ans[k].sum[j]%mod*zhs[size[k]-j][i-j]%mod);
		add(ans[k].sum[i],(ll)x*zhs[size[k]][i]%mod);
	}
}

void turn(int k)
{
    int i; rev[k]^=1;
    if (lazy[k]) lazy[k]=mod-lazy[k];
    for (i=19;i&gt;0;i-=2) if (ans[k].sum[i]) ans[k].sum[i]=mod-ans[k].sum[i];
}

void build(int l,int r,int cur)
{
	size[cur]=r-l+1;
	if (l==r) {ans[cur].sum[1]=read()%mod;return;}
	int mid=(l+r)&gt;&gt;1;
	build(l,mid,cur&lt;&lt;1),build(mid+1,r,cur&lt;&lt;1|1),up_date(cur);
}

void push_down(int k)
{
    if (rev[k]) turn(k&lt;&lt;1),turn(k&lt;&lt;1|1),rev[k]=0;
    if (lazy[k])ins(k&lt;&lt;1,lazy[k]),ins(k&lt;&lt;1|1,lazy[k]),lazy[k]=0;
}


void fan(int l,int r,int k,int x,int y)
{
    if (l==x &amp;&amp; r==y){ turn(k); return; }
    int mid=l+r&gt;&gt;1; push_down(k);
    if (y&lt;=mid) fan(l,mid,k&lt;&lt;1,x,y);
    else if (x&gt;mid) fan(mid+1,r,k&lt;&lt;1|1,x,y);
	else fan(l,mid,k&lt;&lt;1,x,mid),fan(mid+1,r,k&lt;&lt;1|1,mid+1,y);
    up_date(k);
}

void jia(int L,int R,int cur,int l,int r,int val)
{
    if (l==L &amp;&amp; r==R) {ins(cur,val);return;}
    int mid=(L+R)&gt;&gt;1; push_down(cur);
    if (r&lt;=mid) jia(L,mid,cur&lt;&lt;1,l,r,val);
    else if (l&gt;mid) jia(mid+1,R,cur&lt;&lt;1|1,l,r,val); 
	else jia(L,mid,cur&lt;&lt;1,l,mid,val),jia(mid+1,R,cur&lt;&lt;1|1,mid+1,r,val);
    up_date(cur);
}

node ask(int L,int R,int cur,int l,int r,int val)
{
	if (l==L &amp;&amp; r==R) return ans[cur];
	int mid=(L+R)&gt;&gt;1; push_down(cur);
	if (l&gt;mid) return ask(mid+1,R,cur&lt;&lt;1|1,l,r,val);
	else if (r&lt;=mid) return ask(L,mid,cur&lt;&lt;1,l,r,val);
	else
	{
		node x=ask(L,mid,cur&lt;&lt;1,l,mid,val),y=ask(mid+1,R,cur&lt;&lt;1|1,mid+1,r,val),t;
		for (int i=1;i&lt;=val;i++)
		{
			t.sum[i]=(x.sum[i]+y.sum[i])%mod;
			for (int j=1;j&lt;i;j++) add(t.sum[i],(ll)x.sum[j]*y.sum[i-j]%mod);
		}
		return t;
	}
}

int main()
{
    int n=read(),m=read(),i,j;
    zhs[0][0]=1;
    for (i=1;i&lt;=n;i++)
    {
        zhs[i][0]=1;
        for (j=1;j&lt;=i &amp;&amp; j&lt;=20;j++) zhs[i][j]=(zhs[i-1][j-1]+zhs[i-1][j])%mod;
    }
    build(1,n,1);
    while (m--)
    {
		char ch=gc();
		while (ch&lt;'A' || ch&gt;'Z') ch=gc();
		if (ch=='I')
		{
			int x=read(),y=read(),z=read()%mod;
			if (z&lt;0) z+=mod; jia(1,n,1,x,y,z);
		}
		if (ch=='R')
		{
			int x=read(),y=read();
			fan(1,n,1,x,y);
		}
		if (ch=='Q')
		{
			int x=read(),y=read(),z=read();
			printf(&quot;%d\n&quot;,ask(1,n,1,x,y,z).sum[z]);
		}
    }
    return 0;
}<pre><h2>Problem2962</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
 
const int mo = 19940417, N = 150009;
 
inline char gc() {
    static char buffer[1&lt;&lt;16], *s = buffer, *e = buffer;
    if (s == e) e = (s = buffer) + fread(buffer, 1, 1&lt;&lt;16, stdin);
    return *s++;
}
 
inline int gi() {
    static int a; static char c, f;
    for (f = 0; (c = gc()) &lt; '0'; f |= c == '-');
    for (a = c - '0'; '-' &lt; (c = gc()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
    return f ? -a : a;
}
 
inline void mov(int &amp;a, int b) {
    a += b;
    if (a &gt;= mo) a -= mo;
}
 
int lazy[N], C[N][21], size[N], c[N][21];
bool rev[N];
 
inline void mul(int *a, int *x, const int *y) {
    static int i, j;
    for (i = 1; i &lt; 21; ++i) {
        a[i] = 0;
        for (j = 1; j &lt; i; ++j)
            mov(a[i], (long long)x[j] * y[i - j] % mo);
        mov(a[i], x[i]);
        mov(a[i], y[i]);
    }
}
 
inline void modify(const int &amp;u, const int &amp;val) {
    static int i, j, x, *a;
    mov(lazy[u], val);
    for (a = c[u], i = 20; i; --i) {
        for (x = val, j = i - 1; j; --j, x = (long long)x * val % mo)
            mov(a[i], (long long)x * a[j] % mo * C[size[u] - j][i - j] % mo);
        mov(a[i], (long long)x * C[size[u]][i] % mo);
    }
}
 
inline void Switch(const int &amp;u) {
    static int i, *a;
    rev[u] ^= 1;
    if (lazy[u]) lazy[u] = mo - lazy[u];
    for (i = 19, a = c[u]; ~i; i -= 2)
        if (a[i]) a[i] = mo - a[i];
}
 
void build(int u, int l, int r) {
    size[u] = r - l + 1;
    if (l &gt;= r) return (void)(c[u][1] = gi() % mo);
    int m = l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, m);
    build(u &lt;&lt; 1 | 1, m + 1, r);
    mul(c[u], c[u &lt;&lt; 1], c[u &lt;&lt; 1 | 1]);
}
 
inline void pd(const int &amp;u) {
    if (rev[u]) Switch(u &lt;&lt; 1), Switch(u &lt;&lt; 1 | 1), rev[u] = false;
    if (lazy[u]) modify(u &lt;&lt; 1, lazy[u]), modify(u &lt;&lt; 1 | 1, lazy[u]), lazy[u] = 0;
}
 
void range_add(int u, int l, int r, const int &amp;x, const int &amp;y, const int &amp;delta) {
    if (x &lt;= l &amp;&amp; r &lt;= y) return modify(u, delta);
    int m = l + r &gt;&gt; 1; pd(u);
    if (x &lt;= m) range_add(u &lt;&lt; 1, l, m, x, y, delta);
    if (y &gt;  m) range_add(u &lt;&lt; 1 | 1, m + 1, r, x, y, delta);
    mul(c[u], c[u &lt;&lt; 1], c[u &lt;&lt; 1 | 1]);
}
 
void range_rev(int u, int l, int r, const int &amp;x, const int &amp;y) {
    if (x &lt;= l &amp;&amp; r &lt;= y) return Switch(u);
    int m = l + r &gt;&gt; 1; pd(u);
    if (x &lt;= m) range_rev(u &lt;&lt; 1, l, m, x, y);
    if (y &gt;  m) range_rev(u &lt;&lt; 1 | 1, m + 1, r, x, y);
    mul(c[u], c[u &lt;&lt; 1], c[u &lt;&lt; 1 | 1]);
}
 
void query(int u, int l, int r, const int &amp;x, const int &amp;y, int *res) {
    if (x &lt;= l &amp;&amp; r &lt;= y) return (void)memcpy(res, c[u], sizeof c[0]);
    int m = l + r &gt;&gt; 1; pd(u);
    if (y &lt;= m) return query(u &lt;&lt; 1, l, m, x, y, res);
    if (x &gt;  m) return query(u &lt;&lt; 1 | 1, m + 1, r, x, y, res);
    int a[21], b[21], i, j;
    query(u &lt;&lt; 1, l, m, x, y, a);
    query(u &lt;&lt; 1 | 1, m + 1, r, x, y, b);
    for (i = 1; i &lt; 21; ++i) {
        res[i] = a[i] + b[i];
        if (res[i] &gt;= mo) res[i] -= mo;
        for (j = 1; j &lt; i; ++j)
            mov(res[i], (long long)a[j] * b[i - j] % mo);
    }
}
 
int main() {
    int n = gi(), m = gi(), i, j, x, y, z, a[21];
    register char ch;
    for (i = 0; i &lt;= n; ++i)
        for (C[i][0] = j = 1; j &lt; 21 &amp;&amp; j &lt;= i; ++j)
            for (C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; C[i][j] &gt;= mo; C[i][j] -= mo);
    build(1, 1, n);
    while (m--) {
        do ch = gc(); while(ch &lt; 'A' || ch &gt; 'Z');
        x = gi(), y = gi();
        if (ch == 'I') {
            z = gi() % mo;
            if (z &lt; 0) z += mo;
            range_add(1, 1, n, x, y, z);
        } else if (ch == 'R') range_rev(1, 1, n, x, y);
        else {
            z = gi();
            query(1, 1, n, x, y, a);
            printf(&quot;%d\n&quot;, a[z]);
        }
    }
    return 0;
}<pre><h2>Problem2965</h2><pre>#include &lt;set&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

inline char gc() {
	static char buffer[1&lt;&lt;16], *s = buffer, *e = buffer;
	if (s == e) e = (s = buffer) + fread(buffer, 1, 1&lt;&lt;16, stdin);
	return s == e ? EOF : *s++;
}
inline void gi(int &amp;a) {
	static char c, f; f = 0;
	while (c = gc(), c &lt; '0') f |= c == '-'; a = c - '0';
	while (c = gc(), '-' &lt; c) 
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	if (f) a = -a;
}
inline void cmin(int &amp;a, const int &amp;b) {
	if (b &lt; a) a = b;
}
inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}
/*************************/
const int N = 233, M = 633;
int id[N], tot, n, vis[M], g[N], et = 1, blo, col, ans[13];
long long sum[N];
struct E {int t, w, n, p;} e[M];
struct P {
	int x, y;
	bool operator &lt; (const P &amp;a) const {
		return (x ^ a.x) ? (x &lt; a.x) : y &lt; a.y;
	}
	bool operator == (const P &amp;a) const {
		return ! ((x ^ a.x) | (y ^ a.y));
	}
	P operator - (const P &amp;a) const {
		return (P) {x - a.x, y - a.y};
	}
	long long operator * (const P &amp;a) const {
		return (long long)x * a.y - (long long)y * a.x;
	}
}p[N];
struct D {
	P p; int n;
	bool operator &lt; (const D &amp;a) const {
		return atan2(p.y, p.x) &lt; atan2(a.p.y, a.p.x);
	}
}cmpd[N], a[N];

bool cmp(const D &amp;a, const D &amp;b) {
	return (a.p == b.p) ? a.n &lt; b.n : a.p &lt; b.p;
}

inline void sort_edge(int u) {
	int cnt = 0;
	for (int i = g[u]; i; i = e[i].n)
	  cmpd[++cnt] = (D) {p[e[i].t] - p[u], i};
	std::sort(cmpd + 1, cmpd + cnt + 1);
	for (int i = 2; i &lt;= cnt; ++i)
	  e[cmpd[i].n].p = cmpd[i - 1].n;
	e[cmpd[1].n].p = cmpd[cnt].n;
}

void get_area(int co, int i) {
	int o = i, x = e[i ^ 1].t;
	for (vis[i] = co; (i = e[i ^ 1].p) ^ o; vis[i] = co)
	  sum[co] += (p[e[i].t] - p[x]) * (p[e[i^1].t] - p[x]);
	if (sum[co] &lt; 0) sum[co] = -sum[co];
}

double nx;

struct Tree {
	int tot;
	struct node {
		double k, b, x0;
		int col;
		bool operator &lt; (const node &amp;a) const {
			double y1 = k * (nx + 0.001) + b;
			double y2 = a.k * (nx + 0.001) + a.b;
			if (y1 &lt; y2) return true;
			if (y2 &lt; y1) return false;
			return x0 &lt; a.x0;
		}
	}tr[M];
	std::set&lt;node&gt; s;
	std::set&lt;node&gt;::iterator it[M];
	void init() {
		P u, v;
		for (int i = 2; i &lt;= et; i += 2) {
			node &amp;x = tr[i&gt;&gt;1];
			u = p[e[i].t], v = p[e[i^1].t];
			x.k = (double)(u.y- v.y) / (u.x - v.x);
			x.b = u.y - x.k * u.x;
			x.x0 = std::min(u.x, v.x);
			x.col = vis[i ^ (u.x &lt; v.x)];
		}
		tr[0].b = -1, tr[0].col = blo;
		s.insert(*tr);
		tot = (et &gt;&gt; 1) + 1;
	}
	void insert(int x, int o) {
		nx = x;
		it[o] = s.insert(tr[o]).first;
	}
	void remove(int o) {
		s.erase(it[o]);
	}
	void movedata(int o, int x, int y) {
		nx = x;
		tr[tot].b = y;
		id[o - ::n] = (--s.lower_bound(tr[tot]))-&gt;col;
	}
}Tr;

struct MF {
	int et, g[N], og[N], to[M], nxt[M], c[M], C[M], la[N], tot, s, t, d[N], dt[N];
	void ade(int x, int y, int z) {
		to[++et] = y, C[et] = z, nxt[et] = og[x], og[x] = et;
		to[++et] = x, C[et] = z, nxt[et] = og[y], og[y] = et;
	}
	void adde(int x, int y, int z) {
		to[++tot] = y, c[tot] = z, nxt[tot] = g[x], g[x] = tot;
		to[++tot] = x, c[tot] = z, nxt[tot] = g[y], g[y] = tot;
	}
	int dfs(int u, int flow) {
		if (u == t || !flow) return flow;
		int ret = 0, tmp;
		for (int &amp;i = la[u]; i; i = nxt[i])
		  if (c[i] &amp;&amp; d[u] == d[to[i]] + 1) {
			  tmp = dfs(to[i], std::min(flow, c[i]));
			  c[i] -= tmp, c[i^1] += tmp;
			  ret += tmp, flow -= tmp;
			  if (!flow || d[s] &gt; ::col + 2) return ret;
		  }
		if (!(--dt[d[u]])) d[s] = ::col + 3;
		++dt[++d[u]];
		la[u] = g[u];
		return ret;
	}
	int SAP() {
		int ret = 0;
		memset(d, 0, sizeof d);
		memset(dt, 0, sizeof dt);
		dt[0] = ::col + 1;
		while (d[s] &lt; ::col + 3)
		  ret += dfs(s, 0x3f3f3f3f);
		return ret;
	}
	void mf(int p) {
		memset(ans, 63, sizeof ans);
		int end = 1 &lt;&lt; p, cnt, i, x, tmp, S;
		for (S = 1; S ^ end; ++S) {
			memcpy(g, og, sizeof og);
			memcpy(c, C, sizeof c);
			tot = et, cnt = 0, x = S;
			for (i = 1; i &lt;= p; ++i, x &gt;&gt;= 1)
			  if (x &amp; 1) ++cnt, adde(s, id[i], 0x3f3f3f3f);
			tmp = SAP();
			for (; cnt; --cnt)
			  cmin(ans[cnt], tmp);
		}
	}
}G;

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;2965.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;2965.out&quot;, &quot;w&quot;, stdout);
#endif
	int t, m, x, y, i;
	gi(t), gi(n), gi(m);
	tot = n, G.et = 1;
	for (i = 1; i &lt;= t; ++i) {
		gi(x), gi(y);
		a[++tot] = (D){(P) {x, y}, i + n};
	}
	for (i = 1; i &lt;= n; ++i) {
		gi(x), gi(y);
		a[i] = (D){p[i] = (P){x,y}, i};
	}
	while (m--) {
		gi(x), gi(y), gi(i);
		e[++et] = (E) {y, i, g[x]}, g[x] = et;
		e[++et] = (E) {x, i, g[y]}, g[y] = et;
	}
	for (i = 1; i &lt;= n; ++i)
	  sort_edge(i);
	for (i = 2; i &lt;= et; ++i)
	  if (!vis[i]) get_area(++col, i);
	blo = 1;
	for (i = 2; i &lt;= col; ++i)
	  if (sum[blo] &lt; sum[i]) blo = i;
	for (i = 2; i &lt;= et; i += 2)
	  G.ade(vis[i], vis[i ^ 1], e[i].w);
	Tr.init();
	std::sort(a + 1, a + tot + 1, cmp);
	for (i = 1; i &lt;= tot; ++i)
	  if((x = a[i].n) &lt;= n) {
		  for (int j = g[x]; j; j = e[j].n)
			if (p[e[j].t].x &lt; p[x].x) Tr.remove(j &gt;&gt; 1);
			else if (p[x].x &lt; p[e[j].t].x) Tr.insert(p[x].x, j &gt;&gt; 1);
	  } else Tr.movedata(x, a[i].p.x, a[i].p.y);
	G.s = col + 1;
	G.t = blo;
	G.mf(t);
	for (i = 1; i &lt;= t; ++i)
	  printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}<pre><h2>Problem3083</h2><pre>/**************************************************************
    Problem: 3083
    User: Tunix
    Language: C++
    Result: Accepted
    Time:4444 ms
    Memory:23172 kb
****************************************************************/
 
//BZOJ 3083
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;++i)
#define F(i,j,n) for(int i=j;i&lt;=n;++i)
#define D(i,j,n) for(int i=j;i&gt;=n;--i)
#define pb push_back
using namespace std;
typedef long long LL;
inline int getint(){
    int r=1,v=0; char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if (ch=='-') r=-1;
    for(; isdigit(ch);ch=getchar()) v=v*10-'0'+ch;
    return r*v;
}
const int N=100010;
const int INF=2147483647;
/*******************template********************/
int to[N&lt;&lt;1],next[N&lt;&lt;1],head[N],cnt;
void add(int x,int y){
    to[++cnt]=y; next[cnt]=head[x]; head[x]=cnt;
    to[++cnt]=x; next[cnt]=head[y]; head[y]=cnt;
}
int t[N&lt;&lt;2],mn[N&lt;&lt;2];
//t[o]表示set标记
#define mid (l+r&gt;&gt;1)
#define L (o&lt;&lt;1)
#define R (o&lt;&lt;1|1)
void Push_down(int o,int l,int r){
    if (t[o]!=-1){
        mn[L]=mn[R]=t[L]=t[R]=t[o];
        t[o]=-1;
    }
}
void maintain(int o,int l,int r){
    mn[o]=min(mn[L],mn[R]);
}
void update(int o,int l,int r,int ql,int qr,int v){
    if (ql&lt;=l &amp;&amp; qr&gt;=r) t[o]=mn[o]=v;
    else{
        Push_down(o,l,r);
        if (ql&lt;=mid) update(L,l,mid,ql,qr,v);
        if (qr&gt;mid) update(R,mid+1,r,ql,qr,v);
        maintain(o,l,r);
    }
}
int query(int o,int l,int r,int ql,int qr){
    if (ql&gt;qr) return INF;
    if (ql&lt;=l &amp;&amp; qr&gt;=r) return mn[o];
    else{
        int ans=INF;
        Push_down(o,l,r);
        if (ql&lt;=mid) ans=min(ans,query(L,l,mid,ql,qr));
        if (qr&gt;mid) ans=min(ans,query(R,mid+1,r,ql,qr));
        return ans;
    }
}
int n,m,rt;
int a[N];
int fa[N][20],st[N],ed[N],son[N],dep[N],size[N],top[N],tot;
void dfs(int x){
    size[x]=1; son[x]=0;
    F(i,1,17)
        if (dep[x]&gt;=(1&lt;&lt;i)) fa[x][i]=fa[fa[x][i-1]][i-1];
        else break;
    int mx=0;
    for(int i=head[x];i;i=next[i])
        if (to[i]!=fa[x][0]){
            fa[to[i]][0]=x;
            dep[to[i]]=dep[x]+1;
            dfs(to[i]);
            size[x]+=size[to[i]];
            if (size[to[i]]&gt;mx) son[x]=to[i],mx=size[to[i]];
        }
}
bool vis[N];
void connect(int x,int f){
    vis[x]=1; top[x]=f;
    st[x]=++tot;
    if (son[x]) connect(son[x],f);
 
    for(int i=head[x];i;i=next[i])
        if (!vis[to[i]])
            connect(to[i],to[i]);
    ed[x]=tot;
}
void modify(int x,int y,int v){
    while(top[x]!=top[y]){
        if (dep[top[x]]&lt;dep[top[y]]) swap(x,y);
        update(1,1,n,st[top[x]],st[x],v);
        x=fa[top[x]][0];
    }
    if (dep[x]&gt;dep[y]) swap(x,y);
    update(1,1,n,st[x],st[y],v);
}
 
int main(){
#ifndef ONLINE_JUDGE
    freopen(&quot;3083.in&quot;,&quot;r&quot;,stdin);
//  freopen(&quot;3083.out&quot;,&quot;w&quot;,stdout);
#endif
    n=getint(); m=getint();
    F(i,2,n){
        int x=getint(),y=getint();
        add(x,y);
    }
    dfs(1);
    connect(1,1);
    memset(t,-1,sizeof t);
    F(i,1,n){
        a[i]=getint();
        update(1,1,n,st[i],st[i],a[i]);
    }
    rt=getint();
    F(i,1,m){
        int cmd=getint();
        if (cmd==1){
            rt=getint();
        }else if (cmd==2){
            int x=getint(),y=getint();
            int v=getint();
            modify(x,y,v);
        }else if (cmd==3){
            int x=getint();
            if (st[rt]&gt;=st[x] &amp;&amp; ed[rt]&lt;=ed[x]){
                int y=rt,t=dep[rt]-dep[x]-1,ans=INF;
                D(i,17,0) if (t&amp;(1&lt;&lt;i)) y=fa[y][i];
                if (1&lt;=st[y]-1) ans=min(ans,query(1,1,n,1,st[y]-1));
                if (n&gt;=ed[y]+1) ans=min(ans,query(1,1,n,ed[y]+1,n));
                printf(&quot;%d\n&quot;,ans);
            }else{
                printf(&quot;%d\n&quot;,query(1,1,n,st[x],ed[x]));
            }
        }
    }
    return 0;
}<pre><h2>Problem3083</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 100005
int p[19][N], dep[N], C[N&lt;&lt;2|1], ly[N&lt;&lt;2|2], son[N], in[N], ou[N], dfn, tp[N];
struct edge {int t; edge *n;} me[N&lt;&lt;1|1], *g[N], *ce = me;
#define adde(a, b) (ce-&gt;t = b, ce-&gt;n = g[a], g[a] = ce++)
#define FOR(a, b) for (edge *a = g[b]; a; a = a-&gt;n)
int dfs1(int u, int f) {
	int r = 1, t, mx =  0;
	p[0][u] = f;
	dep[u] = dep[f] + 1;
	FOR(it, u) if (it-&gt;t ^ f) {
		t = dfs1(it-&gt;t, u);
		if (t &gt; mx) mx = t, son[u] = it-&gt;t;
		r += t;
	}
	return r;
}
void dfs2(int u, int anc) {
	tp[u] = anc;
	in[u] = ++dfn;
	if (son[u]) dfs2(son[u], anc);
	FOR(it, u) if (!tp[it-&gt;t]) dfs2(it-&gt;t, it-&gt;t);
	ou[u] = dfn;
}
#define pd(u) ((ly[u]) ? (C[u &lt;&lt; 1] = C[u &lt;&lt; 1 | 1] = ly[u &lt;&lt; 1] = ly[u &lt;&lt; 1 | 1] = ly[u], ly[u] = 0) : 0)
#define min(a, b) (a &lt; b ? a : b)
void upd(int u, int l, int r, const int &amp;x, const int &amp;y, const int &amp;v) {
	if (x &lt;= l &amp;&amp; r &lt;= y)
		return (void)(C[u] = ly[u] = v);
	int m = l + r &gt;&gt; 1; pd(u);
	if (x &lt;= m) upd(u &lt;&lt; 1, l, m, x, y, v);
	if (y &gt; m) upd(u &lt;&lt; 1 | 1, m + 1, r, x, y, v);
	C[u] = min(C[u &lt;&lt; 1], C[u &lt;&lt; 1 | 1]);
}
void quy(int u, int l, int r, const int &amp;x, const int &amp;y, int &amp;v) {
	if (x &lt;= l &amp;&amp; r &lt;= y) return (void)(C[u] &lt; v ? v = C[u] : 0);
	int m = l + r &gt;&gt; 1; pd(u);
	if (x &lt;= m) quy(u &lt;&lt; 1, l, m, x, y, v);
	if (y &gt; m)  quy(u &lt;&lt; 1 | 1, m + 1, r, x, y, v);
}
int Walk(int u, int x) {
	static int i;
	for (i = 0; x; ++i, x &gt;&gt;= 1)
		if (x &amp; 1) u = p[i][u];
	return u;
}
int main() {
	///freopen(&quot;3083.in&quot;, &quot;r&quot;, stdin);
	///freopen(&quot;3083.out&quot;, &quot;w&quot;, stdout);
	int n, m, u, v, i, rt, x, y, z;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		adde(u, v), adde(v, u);
	}
	dfs1(1, 0); dfs2(1, 1);
	//memset(ly, -1, sizeof ly);
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;u);
		upd(1, 1, n, in[i], in[i], u);
	}
	for (i = 1; (1 &lt;&lt; i) &lt; n; ++i)
		for (u = 1; u &lt;= n; ++u)
			p[i][u] = p[i - 1][p[i - 1][u]];
	scanf(&quot;%d&quot;, &amp;rt);
	while (m--) {
		scanf(&quot;%d&quot;, &amp;i);
		if (i &amp; 1) scanf(&quot;%d&quot;, &amp;x);
		else scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
		if (i &lt; 2) rt = x;
		else if (i &amp; 1) {
			if (x == rt) printf(&quot;%d\n&quot;, C[1]);
			else {
				z = 0x3fffffff;
				if (in[rt] &lt; in[x] || ou[rt] &gt; ou[x]) quy(1, 1, n, in[x], ou[x], z);
				else {
					u = Walk(rt, dep[rt] - dep[x] - 1);
					if (in[u] &gt; 1) quy(1, 1, n, 1, in[u] - 1, z);
					if (ou[u] &lt; n) quy(1, 1, n, ou[u] + 1, n, z);
				}
				printf(&quot;%d\n&quot;, z);
			}
		} else {
			while (tp[x] ^ tp[y]) {
				if (dep[tp[x]] &lt; dep[tp[y]]) x ^= y ^= x ^= y;
				upd(1, 1, n, in[tp[x]], in[x], z);
				x = p[0][tp[x]];
			}
			if (dep[x] &lt; dep[y]) x ^= y ^= x ^= y;
			upd(1, 1, n, in[y], in[x], z);
		}
	}
	return 0;
}
<pre><h2>Problem3097</h2><pre>#include &lt;cstdio&gt;
char s[100001],*T=s;
#define ad(c) (*T++=c)
int main() {
	register int i,j,l,n=1;
	ad('a');
	for(i=0;i&lt;12;++i) {
		for(j=0;j&lt;n;++j)
			s[j]=='a'?ad('b'):ad('a');
		n&lt;&lt;=1;
	}
	l=n&gt;&gt;1;
	ad('a');++n;
	for(i=0;i&lt;l;++i)ad('a'),++n;
	ad('b');++n;
	for(i=0;i&lt;l;++i)ad('a'),++n;
	printf(&quot;%d %d\n&quot;,n,l);
	puts(s);
	return 0;
}
<pre><h2>Problem3123</h2><pre>#include &lt;bits/stdc++.h&gt;

#define N 80005
#define MS 20002000

struct edge {int t; edge *n;} me[N&lt;&lt;1|1], *g[N], *ce = me;
#define adde(a, b) (*ce = (edge){b, g[a]}, g[a] = ce++)
int fa[17][N], dep[N], sz[N], uf[N];
int gf(int u) {
	return (uf[u] ^ u) ? uf[u] = gf(uf[u]) : u;
}

int ha[N], hacnt, val[N];
int idx(const int &amp;x) {
	return std::lower_bound(ha + 1, ha + hacnt + 1, x) - ha;
}

struct SegNode {
	int sum;
	SegNode *ls, *rs;
} SegMst[MS], *SegIt = SegMst, *rt[N];

void Insert(SegNode *x, SegNode * &amp;y, int l, int r, const int &amp;v) {
	*(y = SegIt++) = *x;
	++y-&gt;sum;
	if (l &gt;= r)
	  return;
	int m = l + r &gt;&gt; 1;
	if (v &lt;= m)
	  Insert(x-&gt;ls, y-&gt;ls, l, m, v);
	else
	  Insert(x-&gt;rs, y-&gt;rs, m + 1, r, v);
}

#define swp(a, b) (a ^= b ^= a ^= b)

int Lca(int u, int v) {
	if (dep[u] &lt; dep[v])
	  swp(u, v);
	int delta = dep[u] - dep[v];
	for (int i = 0; delta; ++i, delta &gt;&gt;= 1)
	  if (delta &amp; 1) u = fa[i][u];
	if (u == v)
	  return u;
	for (int i = 16; ~i; --i)
	  if (fa[i][u] ^ fa[i][v])
		u = fa[i][u], v = fa[i][v];
	return fa[0][u];
}

int Query(int u, int v, int k) {
	int tmp, l = 1, r = hacnt, m;
	tmp = Lca(u, v);
	SegNode *x = rt[u], *y = rt[v], *z = rt[tmp], *d = rt[fa[0][tmp]];
	while (l ^ r) {
		m = l + r &gt;&gt; 1;
		tmp = x-&gt;ls-&gt;sum + y-&gt;ls-&gt;sum - z-&gt;ls-&gt;sum - d-&gt;ls-&gt;sum;
		if (k &lt;= tmp) {
			x = x-&gt;ls;
			y = y-&gt;ls;
			z = z-&gt;ls;
			d = d-&gt;ls;
			r = m;
		} else {
			x = x-&gt;rs;
			y = y-&gt;rs;
			z = z-&gt;rs;
			d = d-&gt;rs;
			l = m + 1;
			k -= tmp;
		}
	}
	return ha[l];
}

int que[N], *l, *r;
void bfs(int u) {
	l = r = que;
	*r++ = u;
	static int v, i;
	while (l &lt; r) {
		u = *l++;
		for (edge *it = g[u]; it; it = it-&gt;n)
		  if ((v = it-&gt;t) ^ fa[0][u]) {
			  fa[0][v] = u;
			  dep[v] = dep[u] + 1;
			  *r++ = v;
		  }
	}
	for (l = que; l &lt; r; ++l) {
		Insert(rt[fa[0][*l]], rt[*l], 1, hacnt, val[*l]);
	}
	for (i = 1; i &lt; 17; ++i)
	  for (l = que; l &lt; r; ++l)
		fa[i][*l] = fa[i - 1][fa[i - 1][*l]];
}

void Union(int u, int v) {
	int fu = gf(u), fv = gf(v);
	if (sz[fu] &gt; sz[fv])
	  swp(u, v), swp(fu, fv);
	fa[0][u] = v;
	dep[u] = dep[v] + 1;
	bfs(u);
	uf[fu] = fv;
	sz[fv] += sz[fv];
	adde(u, v);
	adde(v, u);
}

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;forest.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;forest.out&quot;, &quot;w&quot;, stdout);
#endif
	int n, m, t, u, v, k, lastans;
	char ops[5];
	scanf(&quot;%*d%d%d%d&quot;, &amp;n, &amp;m, &amp;t);
	for (int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, val + i);
		ha[++hacnt] = val[i];
	}
	std::sort(ha + 1, ha + hacnt + 1);
	hacnt = std::unique(ha + 1, ha + hacnt + 1) - ha - 1;
	*rt = SegIt++;
	**rt = (SegNode) {0, *rt, *rt};
	for (int i = 1; i &lt;= n; ++i)
		val[i] = idx(val[i]);
	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		adde(u, v);
		adde(v, u);
	}
	for (int i = 1; i &lt;= n; ++i)
	  if (!fa[0][i]) {
		  bfs(i);
		  for (l = que; l &lt; r; ++l)
			uf[*l] = i;
		  sz[i] = r - que;
	  }
	while (t--) {
		scanf(&quot;%s%d%d&quot;, ops, &amp;u, &amp;v);
		u ^= lastans, v ^= lastans;
		if (*ops == 'Q') {
			scanf(&quot;%d&quot;, &amp;k);
			k ^= lastans;
			printf(&quot;%d\n&quot;, lastans = Query(u, v, k));
		} else Union(u, v);
	}
	return 0;
}<pre><h2>Problem3124</h2><pre>#include &lt;cstdio&gt;
inline int gi() {
	static int a; static char c;
	while ((c = getchar()) &lt; '0'); a = c - '0';
	while ('-' &lt; (c = getchar())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
const int N = 200003;
struct edge {int t, w; edge *n;}me[N&lt;&lt;1|1], *ce = me, *hd[N], *fe[N];
inline void adde(const int &amp;a, const int &amp;b, const int &amp;c) {
	ce-&gt;t = b, ce-&gt;w = c, ce-&gt;n = hd[a], hd[a] = ce++;
}
#define FOR(a,b) for (edge *a = hd[b]; a; a = a-&gt;n)
long long mxd;
int p, from[N];
bool mark[N];
void d1(int u, int fa, long long d) {
	if (mxd &lt; d) mxd = d, p = u;
	FOR(it, u) if ((it-&gt;t) ^ fa) d1(it-&gt;t, u, d + it-&gt;w);
}
void d2(int u, int fa, long long d) {
	if (mxd &lt; d) mxd = d, p = u;
	FOR(it, u) if ((it-&gt;t) ^ fa) {
		from[it-&gt;t] = u, fe[it-&gt;t] = it;
		d2(it-&gt;t, u, d + it-&gt;w);
	}
}
void d3(int u, int fa, long long d) {
	if (mxd &lt; d) mxd = d;
	FOR(it, u) if ((it-&gt;t) ^ fa &amp;&amp; !mark[it-&gt;t]) 
		d3(it-&gt;t, u, d + it-&gt;w);
}
int main() {
	int n = gi(), i, a, b, c;
	long long nd = 0, t;
	for (i = 1; i &lt; n; ++i) {
		a = gi(), b = gi(), c = gi();
		adde(a, b, c), adde(b, a, c);
	}
	mxd = -1LL;
	d1(1, 0, 0LL);
	mxd = -1LL;
	a = p;
	d2(a, 0, 0LL);
	printf(&quot;%lld\n&quot;, mxd);
	t = mxd;
	mark[a] = mark[p] = 1;
	for (edge *it = fe[p]; it; it = fe[from[it-&gt;t]])
		mark[it-&gt;t] = 1;
	a = c = 0;
	for (edge *it = fe[p]; it; it = fe[from[it-&gt;t]]) {
		++c;
		mxd = -1LL;
		d3(from[it-&gt;t], 0, 0);
		nd += it-&gt;w;
		if (nd == mxd) a = c;
		if (nd + mxd == t) break;
	}
	a = c - a;
	printf(&quot;%d\n&quot;, a);
	return 0;
}
<pre><h2>Problem3160</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = (1 &lt;&lt; 19) + 13, mo = 1e9 + 7;
const double pi = acos(-1.0);
struct complex {
	double x, y;
	complex(double _x = 0.0, double _y = 0.0) : x(_x), y(_y) {}
	complex operator - (const complex &amp;a) const {return complex(x - a.x, y - a.y);}
	complex operator + (const complex &amp;a) const {return complex(x + a.x, y + a.y);}
	complex operator * (const complex &amp;a) const {return complex(x * a.x - y * a.y, x * a.y + y * a.x);}
}a[N], b[N], c[N];
int rev[N], pw[N], p[N];
char s[N], str[N];
void fft(complex *a, int n, int flag) {
	static int i, j, k;
	for (i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]);
	for (i = 1; i &lt; n; i &lt;&lt;= 1) {
		complex wn(cos(pi/i), sin(flag*pi/i)), t1, t2;
		for (j = 0; j &lt; n; j += (i&lt;&lt;1)) {
			complex w(1, 0);
			for (k = 0; k &lt; i; ++k, w = w * wn) {
				t1 = a[j + k], t2 = w * a[j + k + i];
				a[j + k] = t1 + t2;
				a[j + k + i] = t1 - t2;
			}
		}
	}
}

int mancher() {
	int i = 0, j = 1, ret = 0;
	str[0] = '~';
	str[1] = '!';
	for (; s[i + 1]; ++i) str[++j] = s[i + 1], str[++j] = '!';
	for (i = 1, j = 0; str[i]; ++i) {
		if (p[j] + j &gt; i) p[i] = min(p[2 * j - i], p[j] + j - i);
		else p[i] = 1;
		while (str[i + p[i]] == str[i - p[i]]) ++p[i];
		if (i + p[i] &gt; j + p[j]) j = i;
		ret += p[i] &gt;&gt; 1;
		while (ret &gt;= mo) ret -= mo;
	}
	return ret;
}

int main() {
	int n, i, len, nn, t;
	long long ans = 0;
	scanf(&quot;%s&quot;, s + 1);
	for (n = 1; s[n]; ++n)
		if (s[n] == 'a') a[n].x = 1;
		else b[n].x = 1;
	--n; n &lt;&lt;= 1;
	for (nn = 1, len = 0; nn &lt;= n; nn &lt;&lt;= 1) ++len;
	for (i = 0; i &lt; nn; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;len-1);
	fft(a, nn, 1); fft(b, nn, 1);
	for (i = 0; i &lt; nn; ++i) c[i] = a[i] * a[i] + b[i] * b[i];
	fft(c, nn, -1);
	for (i = *pw = 1; i &lt;= nn; ++i) if ((pw[i] = pw[i - 1] &lt;&lt; 1) &gt;= mo) pw[i] -= mo;
	for (i = 0; i &lt; nn; ++i) {
		t = c[i].x / nn + 0.5;
		ans = (ans + pw[(t + 1) &gt;&gt; 1] - 1);
		for (; ans &gt;= mo; ) ans -= mo;
	}
	ans = ans + mo - mancher();
	while (ans &gt;= mo) ans -= mo;
	printf(&quot;%d\n&quot;, (int)ans);
	return 0;
}
<pre><h2>Problem3205</h2><pre>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
using namespace std;
int gi() {
	int w=0;bool q=1;char c=getchar();
	while ((c&lt;'0'||c&gt;'9') &amp;&amp; c!='-') c=getchar();
	if (c=='-') q=0,c=getchar();
	while (c&gt;='0'&amp;&amp;c &lt;= '9') w=w*10+c-'0',c=getchar();
	return q? w:-w;
}
const int N=510,NN=N*N;
int map[N][N],n,m;
int dis[9][9][N*N],to[NN][4];
int q[NN],st[NN],bug[NN&lt;&lt;2];bool in[NN];
bool vis[N][N][4];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
//0:右 1:下 2:左 3:上
inline void dfs(int x,int y,int t) {
	if (to[x*m+y][t]!=-1) return;
	if (vis[x][y][t]) { to[x*m+y][t]=-2; return; }
	vis[x][y][t]=true;
	int k=t;
	if (map[x][y]==10) (t+=3)&amp;=3;
	else if (map[x][y]==11) (++t)&amp;=3;
	if (x+dx[t]&lt;0||y+dy[t]&lt;0||map[x+dx[t]][y+dy[t]]&lt;0) to[x*m+y][k]=x*m+y;
	else {
		dfs(x+dx[t],y+dy[t],t);
		to[x*m+y][k]=to[(x+dx[t])*m+y+dy[t]][t];
	}
	vis[x][y][k]=false;
}
inline void upd(int &amp;x,int y) { y&lt;x?x=y:0; }
int main()
{
#ifndef ONLINE_JUDGE
	freopen(&quot;robot.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;robot.out&quot;,&quot;w&quot;,stdout);
#endif
	gi();m=gi(),n=gi();int d,i,j,L=8,R=0,t,k,len,l,r,mid,s,*dis,id,top;char c;
	memset(map,-1,sizeof(map));
	memset(::dis,0x3f,sizeof(::dis));
	for (i=id=0;i&lt;n;i++)
		for (j=0;j&lt;m;j++,id++) {
			while (1) {
				if ((c=getchar())=='A') map[i][j]=10;
				else if (c=='C') map[i][j]=11;
				else if (c=='.') map[i][j]=9;
				else if ('1'&lt;=c&amp;&amp;c&lt;='9') map[i][j]=c-'1',L=min(L,map[i][j]),R=max(R,map[i][j]),::dis[map[i][j]][map[i][j]][id]=0;
				else if (c!='x') continue;
				break;
			}
			for (t=0;t&lt;4;t++) to[id][t]=-1;
		}
	for (i=0;i&lt;n;i++)
		for (j=0;j&lt;m;j++)
			if (map[i][j]&gt;=0)
				for (t=0;t&lt;4;t++)
					dfs(i,j,t);
	//数据范围有点大，可以利用所有边权都是1，把spfa改成BFS
	for (len=0;len&lt;R-L+1;len++)
		for (l=0,r=len;r&lt;=R;++l,++r) {
			dis=::dis[l][r];
			for (mid=l;mid&lt;r;mid++)
				for (i=n*m;i--;)
					upd(dis[i],::dis[l][mid][i]+::dis[mid+1][r][i]);
			for (i=n*m,s=1&lt;&lt;30,t=0;i--;)
				if (dis[i]&lt;1&lt;&lt;20)
					s=min(s,dis[i]),t=max(t,dis[i]),bug[dis[i]]++;
			if (s&gt;t) continue;
			for (i=s+1;i&lt;=t;i++) bug[i]+=bug[i-1];
			for (i=n*m,top=bug[t];i--;) if (dis[i]&lt;1&lt;&lt;20) st[bug[dis[i]]--]=i,in[i]=true;
			memset(bug+s,0,(t-s+1)&lt;&lt;2);
			for (i=top&gt;&gt;1;i;i--) swap(st[i],st[top+1-i]);
			for (s=t=1;s!=t||top;) {
				if (!top||(s!=t&amp;&amp;dis[q[s]]&lt;dis[st[top]])) k=q[s],s=s+1==NN?0:s+1;
				else k=st[top--];
				in[k]=false;
				for (d=0;d&lt;4;d++)
					if (to[k][d]&gt;=0&amp;&amp;dis[k]+1&lt;dis[to[k][d]]) {
						dis[to[k][d]]=dis[k]+1;
						if (!in[to[k][d]]) in[q[t]=to[k][d]]=true,t=t+1==NN?0:t+1;
					}
			}
		}
	k=1&lt;&lt;30;dis=::dis[L][R];
	for (i=n*m;i--;) upd(k,dis[i]);
	printf(&quot;%d\n&quot;,k&gt;1&lt;&lt;20?-1:k);
	return 0;
}<pre><h2>Problem3206</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
typedef long long i64;
const int maxn(1e5 + 7), maxm(3e5 + 7), maxk(22);
#define rep(i, s, t) for (register int i = s; i &lt;= t; ++i)
inline void get_int(int &amp;a) {
	register char c;
	do c = getchar_unlocked(); while (c &lt; 48);
	a = c ^ 48;
	while (47 &lt; (c = getchar_unlocked()))
		a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (c ^ 48);
}
struct edge {
	int u, v, w;
	bool operator &lt; (const edge &amp;a) const {
		return w &lt; a.w;
	}
} G[maxm], K[maxk], NG[maxm], NN[maxm];
struct it_edge {
	int to, cost;
	it_edge *nxt;
} it_edge_mset[maxk * maxk * 2], *g[maxn];
i64 sum_p[maxn], csum[maxk];
bool used[maxk], mark[maxk];
int f1[maxn], f2[maxn], p[maxn], rena[maxn], dep[maxk], fadis[maxk];
inline int gf(int u, int *f) {
	while (f[u] ^ u) u = f[u] = f[f[u]];
	return u;
}
void dfs(const int u) {
	csum[u] = sum_p[u];
	for (it_edge *it = g[u]; it; it = it-&gt;nxt)
		if (it-&gt;to != f1[u]) {
			f1[it-&gt;to] = u;
			fadis[it-&gt;to] = it-&gt;cost;
			dep[it-&gt;to] = dep[u] + 1;
			mark[it-&gt;to] = it-&gt;cost == 0x3f3f3f3f;
			dfs(it-&gt;to);
			csum[u] += csum[it-&gt;to];
		}
}
void limited(int u, int v, const int w) {
	if (dep[u] &lt; dep[v]) u ^= v ^= u ^= v;
	for (; dep[u] &gt; dep[v]; u = f1[u])
		if (mark[u] &amp;&amp; fadis[u] &gt; w) fadis[u] = w;
	if (u == v) return;
	while (u ^ v) {
		if (mark[u] &amp;&amp; fadis[u] &gt; w) fadis[u] = w;
		if (mark[v] &amp;&amp; fadis[v] &gt; w) fadis[v] = w;
		u = f1[u], v = f1[v];
	}
}
int main() {
	int n, m, k, u, v, w, ecnt(0), ncnt(0), ng(0), nn(0);
	get_int(n), get_int(m), get_int(k);
	rep (i, 1, m) {
		get_int(u), get_int(v), get_int(w);
		G[i] = (edge) {u, v, w};
	}
	std::sort(G + 1,  G + m + 1);
	rep (i, 1, n) f1[i] = f2[i] = i;
	rep (i, 1, k) {
		get_int(u), get_int(v);// get_int(w);
		K[i] = (edge) {u, v, 0};
		u = gf(u, f1), v = gf(v, f1);
		if (u != v) f1[u] = v, ++ecnt;
	}
	rep (i, 1, n) get_int(p[i]);
	rep (i, 1, m) {
		u = gf(G[i].u, f1), v = gf(G[i].v, f1);
		if (u != v) {
			++ecnt;
			f1[u] = v;
			u = gf(G[i].u, f2), v = gf(G[i].v, f2);
			if (u != v) f2[u] = v;
			if (ecnt == n - 1) break;
		}
	}
	rep (i, 1, n) {
		if (!rena[gf(i, f2)]) rena[gf(i, f2)] = ++ncnt;
		rena[i] = rena[gf(i, f2)];
		sum_p[rena[i]] += p[i];
	}
	rep (i, 1, m) {
		u = rena[G[i].u], v = rena[G[i].v];
		if (u != v) NG[++ng] = (edge) {u, v, G[i].w};
	}
	rep (i, 1, k) K[i] = (edge) {rena[K[i].u], rena[K[i].v], 0};
	ecnt = 0;
	rep (i, 1, ncnt) f1[i] = i;
	std::sort(NG + 1, NG + ng + 1);
	rep (i, 1, ng) {
		u = gf(NG[i].u, f1), v = gf(NG[i].v, f1);
		if (u != v) {
			++ecnt;
			f1[u] = v;
			NN[++nn] = NG[i];
			if (ecnt == ncnt - 1) break;
		}
	}
	i64 ans(0ll);
	int end_status = 1 &lt;&lt; k;
	for (int status = 0; status ^ end_status; ++status) {
		static it_edge *curten;
		curten = it_edge_mset, ecnt = 0;
		rep (i, 1, ncnt) f1[i] = i, g[i] = NULL;
		for (int i = 0; i ^ k; ++i) if (status &gt;&gt; i &amp; 1) {
				u = K[i + 1].u, v = K[i + 1].v;
				if (gf(u, f1) != gf(v, f1)) {
					++ecnt;
					f1[gf(u, f1)] = gf(v, f1);
					*curten = (it_edge) {v, 0x3f3f3f3f, g[u]};
					g[u] = curten++;
					*curten = (it_edge) {u, 0x3f3f3f3f, g[v]};
					g[v] = curten++;
				}
			}
		rep (i, 1, nn) used[i] = false;
		if (ecnt &lt; ncnt - 1) {
			rep (i, 1, nn)
				if (u = gf(NN[i].u, f1), v = gf(NN[i].v, f1), u != v) {
					++ecnt;
					f1[u] = v;
					used[i] = true;
					u = NN[i].u, v = NN[i].v;
					*curten = (it_edge) {v, NN[i].w, g[u]};
					g[u] = curten++;
					*curten = (it_edge) {u, NN[i].w, g[v]};
					g[v] = curten++;
					if (ecnt == ncnt - 1) break;
				}
		}
		f1[rena[1]] = 0;
		dfs(rena[1]);
		rep (i, 1, nn) if (!used[i]) limited(NN[i].u, NN[i].v, NN[i].w);
		i64 res(0);
		rep (i, 1, ncnt) if (mark[i]) res += csum[i] * fadis[i];
		if (res &gt; ans) ans = res;
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem3223</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MaxN = 1e5 + 7;

struct node {
	int val, size;
	bool rev;
	node *fa, *ch[2];
	void pd();
	void REV();
	bool which();
	void maintain();
} node_mset[MaxN], *root;

void node :: pd() {
	if (rev) {
		if (ch[0]) ch[0]-&gt;REV();
		if (ch[1]) ch[1]-&gt;REV();
		rev = false;
	}
}

void node :: REV() {
	rev ^= true;
	swap(ch[0], ch[1]);
}

bool node :: which() {
	return fa-&gt;ch[1] == this;
}

void node :: maintain() {
	size = 1;
	if (ch[0]) size += ch[0]-&gt;size;
	if (ch[1]) size += ch[1]-&gt;size;
}

inline node *kth(int k) {
	node *u = root;
	static int t;
	while (u) {
		u-&gt;pd();
		t = (u-&gt;ch[0]) ? u-&gt;ch[0]-&gt;size : 0;
		if (k &lt;= t) u = u-&gt;ch[0];
		else if (k &gt; t + 1) u = u-&gt;ch[1], k -= t + 1;
		else return u;
	}
	return NULL;
}

inline void rot(node *u) {
	node *f = u-&gt;fa;
	f-&gt;pd(); u-&gt;pd();
	int d = u-&gt;which();
	if (f-&gt;ch[d] = u-&gt;ch[d ^ 1])
		f-&gt;ch[d]-&gt;fa = f;
	u-&gt;ch[d ^ 1] = f;
	u-&gt;fa = f-&gt;fa;
	if (f-&gt;fa) f-&gt;fa-&gt;ch[f-&gt;which()] = u;
	f-&gt;fa = u;
	f-&gt;maintain();
}

inline void splay(node *u, node *target) {
	for (node *f; u-&gt;fa != target; rot(u))
		if ((f = u-&gt;fa)-&gt;fa != target)
			f-&gt;fa-&gt;pd(), rot(f-&gt;which() == u-&gt;which() ? f : u);
	u-&gt;maintain();
	if (target == NULL) root = u;
}

node *build(int l, int r) {
	int m = (l + r) &gt;&gt; 1;
	node *u = node_mset + m;
	u-&gt;val = m;
	if (l &lt; m) (u-&gt;ch[0] = build(l, m - 1))-&gt;fa = u;
	if (m &lt; r) (u-&gt;ch[1] = build(m + 1, r))-&gt;fa = u;
	u-&gt;maintain();
	return u;
}
int n, m;
void Print(node *u) {
	u-&gt;pd();
	if (u-&gt;ch[0]) Print(u-&gt;ch[0]);
	if (u-&gt;val &amp;&amp; u-&gt;val &lt;= n) printf(&quot;%d &quot;, u-&gt;val);
	if (u-&gt;ch[1]) Print(u-&gt;ch[1]);
}

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);
#endif
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	root = build(0, n + 1);
	for (int l, r; m; --m) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		splay(kth(l), NULL);
		splay(kth(r + 2), root);
		root-&gt;ch[1]-&gt;ch[0]-&gt;REV();
		//.Print(root); puts(&quot;&quot;);
	}
	Print(root); puts(&quot;&quot;);
	return 0;
}<pre><h2>Problem3237</h2><pre>#include &lt;cstdio&gt;

const int MaxN = 100003, MaxM = 200003, MaxQ = 100003;

struct ask {
	int id, s[4], size;
	void read(const int &amp;id) {
		this-&gt;id = id;
		scanf(&quot;%d&quot;, &amp;size);
		for (int i = 0; i &lt; size; ++i)
		  scanf(&quot;%d&quot;, s + i);
	}
	const int &amp; operator [] (const int &amp;i) const {
		return s[i];
	}
}q[MaxQ];

struct edge {
	int u, v;
	void read() {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
	}
}e[MaxM];

int f[MaxN], stk[MaxM * 10], *top = stk, ans[MaxQ], mark[MaxM], _mark;

int gf(int u) {
	if (f[u] == u) return u;
	*top++ = u, *top++ = f[u];
	return f[u] = gf(f[u]);
}

void uni(int u, int v) {
	if (gf(u) == gf(v)) return;
	*top++ = f[v], *top++ = f[f[v]];
	f[f[v]] = f[u];
}

void divide(int l, int r) {
	int *ctop = top, mid = (l + r) &gt;&gt; 1, i, j;
	if (l == r) {
		int t = 1;
		for (int i = 0; i &lt; q[l].size; ++i)
		  if (gf(e[q[l][i]].u) ^ gf(e[q[l][i]].v)) {
			  t = 0;
			  break;
		  }
		ans[q[l].id] = t;
		for (; top &gt; ctop; top -= 2)
		  f[top[-2]] = top[-1];
		return;
	}

	++_mark;
	for (i = l; i &lt;= mid; ++i)
	  for (j = 0; j &lt; q[i].size; ++j)
		mark[q[i][j]] = _mark;
	for (i = mid + 1; i &lt;= r; ++i)
	  for (j = 0; j &lt; q[i].size; ++j)
		if (mark[q[i][j]] ^ _mark) uni(e[q[i][j]].u, e[q[i][j]].v);
	divide(l, mid);
	for (; top &gt; ctop; top -= 2)
	  f[top[-2]] = top[-1];

	++_mark;
	for (i = mid + 1; i &lt;= r; ++i)
	  for (j = 0; j &lt; q[i].size; ++j)
		mark[q[i][j]] = _mark;
	for (i = l; i &lt;= mid; ++i)
	  for (j = 0; j &lt; q[i].size; ++j)
		if (mark[q[i][j]] ^ _mark) uni(e[q[i][j]].u, e[q[i][j]].v);
	divide(mid + 1, r);
	for (; top &gt; ctop; top -= 2)
	  f[top[-2]] = top[-1];
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, m, k;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= m; ++i)
	  e[i].read();

	scanf(&quot;%d&quot;, &amp;k);
	for (int i = 0; i &lt; k; ++i) q[i].read(i);

	++_mark;
	for (int i = 0, j; i &lt; k; ++i)
	  for (j = 0; j &lt; q[i].size; ++j)
		mark[q[i][j]] = _mark;

	for (int i = 1; i &lt;= n; ++i)
	  f[i] = i;

	for (int i = 1; i &lt;= m; ++i)
	  if (!mark[i]) uni(e[i].u, e[i].v);

	divide(0, k - 1);
	for (int i = 0; i &lt; k; ++i)
	  puts(ans[i] ? &quot;Connected&quot; : &quot;Disconnected&quot;);
	return 0;
}<pre><h2>Problem3238</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int maxn=1000010;
int n,to[maxn][26],fa[maxn],l[maxn],f[maxn],x[maxn],w[maxn],od[maxn],cnt=1,last=1;
void extend(int c)
{
    int p,q,np,nq;
    p=last;last=np=++cnt;l[np]=l[p]+1;f[np]=w[np]=1;
    for(;!to[p][c];p=fa[p]) to[p][c]=np;
    if(!p) fa[np]=1;
    else
    {
        q=to[p][c];
        if(l[p]+1==l[q]) fa[np]=q;
        else
        {
            nq=++cnt;l[nq]=l[p]+1;
            memcpy(to[nq],to[q],sizeof(to[q]));
            fa[nq]=fa[q];
            fa[q]=fa[np]=nq;
            for(;to[p][c]==q;p=fa[p]) to[p][c]=nq;
        }
    }
}
LL solve()
{
    LL ans=0;
    for(int i=1;i&lt;=cnt;i++) x[l[i]]++;
    for(int i=1;i&lt;=n;i++) x[i]+=x[i-1];
    for(int i=1;i&lt;=cnt;i++) od[x[l[i]]--]=i;
    for(int i=cnt;i;i--) f[fa[od[i]]]+=f[od[i]];
    for(int i=1;i&lt;=cnt;i++)
    {
        ans+=(LL)w[fa[i]]*f[i]*l[fa[i]];
        w[fa[i]]+=f[i];
    }
    return ans;
}
char s[maxn];
int main()
{
    scanf(&quot;%s&quot;,s);
    n=strlen(s);
    for(int i=n-1;i&gt;=0;i--) extend(s[i]-'a');
    LL ans=0;
    for(int i=1;i&lt;=n;i++) ans+=(LL)i*(n-1);
    printf(&quot;%lld\n&quot;,ans-2*solve());
    return 0;
}<pre><h2>Problem3238</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 500003;

struct node {
	int step, size, curtensize;
	node *pre, *ch[26];
} node_mset[MaxN &lt;&lt; 1], *cnode = node_mset, *root, *last, *order[MaxN &lt;&lt; 1];

inline node *newnode(const int &amp;step, int s = 0) {
	cnode-&gt;step = step;
	cnode-&gt;size = cnode-&gt;curtensize = s;
	return cnode++;
}

inline void Insert(const int &amp;c) {
	node *p = last, *np = newnode(p-&gt;step + 1, 1);
	for (; p &amp;&amp; !p-&gt;ch[c]; p = p-&gt;pre)
		p-&gt;ch[c] = np;
	if (!p)
		np-&gt;pre = root;
	else {
		node *q = p-&gt;ch[c];
		if (q-&gt;step == p-&gt;step + 1)
			np-&gt;pre = q;
		else {
			node *nq = newnode(p-&gt;step + 1);
			memcpy(nq-&gt;ch, q-&gt;ch, sizeof q-&gt;ch);
			nq-&gt;pre = q-&gt;pre;
			q-&gt;pre = np-&gt;pre = nq;
			for (; p &amp;&amp; p-&gt;ch[c] == q; p = p-&gt;pre)
				p-&gt;ch[c] = nq;
		}
	}
	last = np;
}

int cnt[MaxN &lt;&lt; 1];

inline void toposort() {
	int mxstep = 0;
	for (node *i = node_mset; i &lt; cnode; ++i) {
		if (i-&gt;step &gt; mxstep)
			mxstep = i-&gt;step;
		++cnt[i-&gt;step];
	}
	++mxstep;
	for (int i = 1; i &lt; mxstep; ++i) cnt[i] += cnt[i - 1];
	for (node *i = node_mset; i &lt; cnode; ++i) {
		order[--cnt[i-&gt;step]] = i;
		//printf(&quot;%d &quot;, i-&gt;step);
	}
	//puts(&quot;&quot;);
}

inline long long calc() {
	toposort();
	int size = cnode - node_mset;
	for (int i = size - 1; ~i; --i)
		if (order[i]-&gt;pre) order[i]-&gt;pre-&gt;size += order[i]-&gt;size;
	long long ret = 0;
	for (node *i = node_mset; i &lt; cnode; ++i)
		if (i-&gt;pre) {
			ret += (long long)i-&gt;pre-&gt;curtensize * i-&gt;pre-&gt;step * i-&gt;size;
			i-&gt;pre-&gt;curtensize += i-&gt;size;
		}
	return ret;
}

char s[MaxN];

int main() {
	scanf(&quot;%s&quot;, s);
	int n = strlen(s);
	long long ans = (long long)(n - 1) * ((long long)n * (n + 1) &gt;&gt; 1);
	last = root = newnode(0);
	for (int i = n - 1; ~i; --i) 
		Insert(s[i] - 'a');
	//printf(&quot;%lld\n&quot;, ans);
	printf(&quot;%lld\n&quot;, ans - 2 * calc());
	return 0;
}
<pre><h2>Problem3240</h2><pre>#include &lt;cstdio&gt;
typedef unsigned long long u64;
const u64 mod = 1000000007;
struct D {
	u64 x, y;
	D(u64 x = 0ULL, u64 y = 0ULL) :
		x(x), y(y) {}
}x, y, z;
D operator * (const D &amp;a, const D &amp;b) {
	return D(a.x * b.x % mod, (a.x * b.y + a.y) % mod);
}
inline D pow(D a, u64 b) {
	static D r;
	for (r = a; b; b &gt;&gt;= 1, a = a * a)
	  if (b &amp; 1) r = r * a;
	return r;
}
char n[1001000], m[1001000];
inline u64 StringToNum(const char *s, const u64 &amp;mod) {
	static u64 r;
	static const char *i;
	for (i = s, r = 0; *i; ++i)
	  r = (r * 10 + *i - '0') % mod;
	return r;
}
int main() {
	u64 a, b, c, d, t, p;
	scanf(&quot;%s%s%llu%llu%llu%llu&quot;, n, m, &amp;a, &amp;b, &amp;c, &amp;d);
	p = mod - 1 + (a == 1);
	t = StringToNum(m, p);
	if (t &lt; 2) t += p;
	x = pow(D(a, b), t - 2);
	y = D(c, d);
	z = y * x;
	p = mod - 1 + (z.x == 1);
	t = StringToNum(n, p);
	if (t &lt; 2) t += p;
	z = pow(z, t - 2);
	x = x * z;
	printf(&quot;%llu\n&quot;, (x.x + x.y) % mod);
	return 0;
}<pre><h2>Problem3243</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
const int maxn(100005);
#define _(i, n) for (register int i = 1; i &lt;= n; ++i)
int n, m, p, a[maxn][105], b[105], c[105][105], r[maxn];

inline int calc(int i) {
	int s = 0;
	if (p == 2)
		_(j, m) s ^= b[j] &amp; a[i][j], b[j] ^= a[i][j];
	else
		_(j, m) _(k, m) {
			s += c[j][k] * a[i][j] * a[i][k];
			c[j][k] += a[i][j] * a[i][k];
		}
	return s % p;
}

inline void check(int i, int j) {
	int s = 0;
	_(k, m) s += a[i][k] * a[j][k];
	if (s % p == 0) {
		if (i &gt; j) printf(&quot;%d %d\n&quot;, j, i);
		else printf(&quot;%d %d\n&quot;, i, j);
		exit(0);
	}
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p);
	_(i, n) _(j, m) scanf(&quot;%d&quot;, a[i] + j), a[i][j] %= p;
	_(i, n) r[i] = i;
	srand(20000327);
	std::random_shuffle(r + 1,r + n + 1);
	_(i, n) if (calc(r[i]) != (i - 1) % p)
		_(j, n) check(r[i], r[j]);
	puts(&quot;-1 -1&quot;);
	return 0;
}<pre><h2>Problem3243</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
const int maxn(100005);
#define _(i, n) for (register int i = 1; i &lt;= n; ++i)
int n, m, p, a[maxn][105], b[105], c[105][105], r[maxn];

inline int calc(int i) {
	int s = 0;
	if (p == 2)
		_(j, m) s ^= b[j] &amp; a[i][j], b[j] ^= a[i][j];
	else
		_(j, m) _(k, m) {
			s += c[j][k] * a[i][j] * a[i][k];
			c[j][k] += a[i][j] * a[i][k];
		}
	return s % p;
}

inline void check(int i, int j) {
	int s = 0;
	_(k, m) s += a[i][k] * a[j][k];
	if (s % p == 0) {
		if (i &gt; j) printf(&quot;%d %d\n&quot;, j, i);
		else printf(&quot;%d %d\n&quot;, i, j);
		exit(0);
	}
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p);
	_(i, n) _(j, m) scanf(&quot;%d&quot;, a[i] + j), a[i][j] %= p;
	_(i, n) r[i] = i;
	srand(19260817);
	std::random_shuffle(r + 1,r + n + 1);
	_(i, n) if (calc(r[i]) != (i - 1) % p)
		_(j, n) check(r[i], r[j]);
	puts(&quot;-1 -1&quot;);
	return 0;
}<pre><h2>Problem3288</h2><pre>#include &lt;cstdio&gt;
#define N 1000005
#define mo 1000000007
int v[N], phi[N];
int main() {
	int n, ans;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 2; i &lt;= n; ++i)
		if (!v[i]) for (int j = i; j &lt;= n; j += i)
			v[j] = i;
	phi[1] = 1;
	for (int i = 2; i &lt;= n; ++i)
		if (v[i] ^ v[i / v[i]])
			phi[i] = phi[i / v[i]] * (v[i] - 1);
		else
			phi[i] = phi[i / v[i]] * v[i];
	ans = 1;
	for (int i = 2; i &lt;= n; ++i)
		ans = (long long)ans * phi[i] % mo;
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem3289</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define N 50003

struct query {
	int l, r, _l, id;
	bool operator &lt; (const query &amp;a) const {
		return (_l ^ a._l) ? _l &lt; a._l : r &lt; a.r;
	}
}q[N];

int tr[N], ha[N], a[N], trend;

void add(int x, const int &amp;delta) {
	for (; x &lt; trend; x += x &amp; -x)
	  tr[x] += delta;
}

int sum(int x) {
	static int r;
	for (r = 0; x; x ^= x &amp; -x)
	  r += tr[x];
	return r;
}

int main() {
	int n, _q, i, l, r, blo, _l, _r, ct = 0, *end;
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, a + i);
		ha[i] = a[i];
	}
	std::sort(ha + 1, ha + n + 1);
	end = std::unique(ha + 1, ha + n + 1);
	trend = end - ha;
	for (i = 1; i &lt;= n; ++i)
	  a[i] = std::lower_bound(ha + 1, end, a[i]) - ha;
	for (blo = 1; blo * blo &lt;= n; ++blo);
	scanf(&quot;%d&quot;, &amp;_q);
	for (i = 0; i &lt; _q; ++i) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		q[i] = (query) {l, r, l / blo, i};
	}
	std::sort(q, q + _q);
	l = 1, r = 0;
	for (i = 0; i &lt; _q; ++i) {
		_l = q[i].l, _r = q[i].r;
		while (l &lt; _l) {
			add(a[l], -1);
			ct -= sum(a[l] - 1);
			++l;
		}
		while (_r &lt; r) {
			add(a[r], -1);
			ct -= r - l - sum(a[r]);
			--r;
		}
		while (_l &lt; l) {
			--l;
			add(a[l], 1);
			ct += sum(a[l] - 1);
		}
		while (r &lt; _r) {
			++r;
			add(a[r], 1);
			ct += r - l + 1 - sum(a[r]);
		}
		ha[q[i].id] = ct;
	}
	for (i = 0; i &lt; _q; ++i)
	  printf(&quot;%d\n&quot;, ha[i]);
	return 0;
}<pre><h2>Problem3295</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 100005
int n, m, tr[N];
void add(int x, const int &amp;delta) {
	for (; x &lt;= n; x += x &amp; -x)
	  tr[x] += delta;
}
int sum(int x) {
	static int r;
	for (r = 0; x; x ^= x &amp; -x)
	  r += tr[x];
	return r;
}
struct dot {
	int x, y, t;
} a[N], ta[N];
int pos[N];
long long ans[N];
void cdq(int l, int r) {
	if (l &gt;= r)
	  return;
	int m = (l + r) &gt;&gt; 1;
	int i1 = l, i2 = m + 1, i;
	for (i = l; i &lt;= r; ++i) 
		if (a[i].t &lt;= m)
		  ta[i1++] = a[i];
		else 
		  ta[i2++] = a[i];
	for (i = l; i &lt;= r; ++i)
	  a[i] = ta[i];
	i1 = l;
	for (i = m + 1; i &lt;= r; ++i) {
		for (; i1 &lt;= m &amp;&amp; a[i1].x &lt; a[i].x; ++i1)
		  add(a[i1].y, 1);
		ans[a[i].t] += i1 - l - sum(a[i].y);
	}
	for (i = l; i &lt; i1; ++i)
	  add(a[i].y, -1);
	i1 = m;
	for (int i = r; i &gt; m; --i) {
		for (; i1 &gt;= l &amp;&amp; a[i1].x &gt; a[i].x; --i1)
		  add(a[i1].y, 1);
		ans[a[i].t] += sum(a[i].y - 1);
	}
	for (i = i1 + 1; i &lt;= m; ++i)
	  add(a[i].y, -1);
	cdq(l, m); cdq(m + 1, r);
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].y);
		a[i].x = i;
		pos[a[i].y] = i;
	}
	int curtime = n;
	for (int i = 1, x; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		a[pos[x]].t = curtime--;
	}
	for (int i = 1; i &lt;= n; ++i)
	  if (!a[i].t) a[i].t = curtime--;
	cdq(1, n);
	for (int i = 1; i &lt;= n; ++i)
	  ans[i] += ans[i - 1];
	for (int i = n; i &gt;= n - m + 1; --i)
	  printf(&quot;%lld\n&quot;, ans[i]);
	return 0;
}<pre><h2>Problem3309</h2><pre>#include &lt;cstdio&gt;
#define N 10000007
typedef int arr[N];
arr a, pa, g;

void Init() {
	static int p[1001001], *ep = p;
	static bool vis[N];
	int i, *j, t, _t;
	for (i = 2; i &lt; N; ++i) {
		if (!vis[i]) {
			a[i] = 1;
			pa[i] = i;
			g[i] = 1;
			*ep++ = i;
		}
		for (j = p; (t = *j * i) &lt; N; ++j) {
			vis[t] = true;
			if (!(i % *j)) {
				a[t] = a[i] + 1;
				pa[t] = pa[i] * *j;
				_t = i / pa[i];
				if (_t == 1)
				  g[t] = 1;
				else 
				  g[t] = ((a[t] ^ a[_t]) ? 0 : -g[_t]);
				break;
			}
			a[t] = 1;
			pa[t] = *j;
			g[t] = ((a[i] ^ 1) ? 0 : -g[i]);
		}
	}
	for (i = 1; i &lt; N; ++i)
	  g[i] += g[i - 1];
}

int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}

#define swap(a, b) (a ^= b ^= a ^= b)

long long Query(int n, int m) {
	static int i, j, _n, _m;
	static long long ans;
	if (n &gt; m)
	  swap(n, m);
	for (ans = 0LL, i = 1; i &lt;= n; i = j + 1) {
		_n = n / i, _m = m / i;
		j = min(n / _n, m / _m);
		ans += (long long)_n * _m * (g[j] - g[i - 1]);
	}
	return ans;
}

int main() {
	int _, a, b;
	Init();
	for (scanf(&quot;%d&quot;, &amp;_); _; _--) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		printf(&quot;%lld\n&quot;, Query(a, b));
	}
	return 0;
}<pre><h2>Problem3489</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#define Maxn 200010
#define l(x) ch[x][0]
#define r(x) ch[x][1]
#define lc(x) c[x][0]
#define rc(x) c[x][1]
using namespace std;
int n,m,tot=0,_tot=0,tree[Maxn]={0};
int a[Maxn],last[Maxn],pos[Maxn],next[Maxn],N,rank[Maxn];
int maxt[40000005],ch[40000010][2];
int c[2000010][2],root[2000010];

stack&lt;int&gt; _mL,mL;

int get(){
	if(mL.empty()) return ++tot;
	int tp=mL.top();
	mL.pop();
	return tp;
}

int _get(){
	if(_mL.empty()) return ++_tot;
	int tp=_mL.top();
	_mL.pop();
	return tp;
}

int _change(int o,int l,int r,int qx,int qv){
    int x=++_tot; maxt[x]=max(maxt[o],qv);
    l(x)=l(o); r(x)=r(o);
    if(l==r) return x;
    int mid=(l+r)&gt;&gt;1;
    if(qx&lt;=mid) l(x)=_change(l(x),l,mid,qx,qv);
    else r(x)=_change(r(x),mid+1,r,qx,qv);
    return x;
}

int _query(int o,int l,int r,int ql,int qr){
	if(!o) return 0;
    if(ql&lt;=l&amp;&amp;r&lt;=qr) return maxt[o];
    int mid=(l+r)&gt;&gt;1,res=0;
    if(ql&lt;=mid) res=max(res,_query(l(o),l,mid,ql,qr));
    if(mid&lt;qr) res=max(res,_query(r(o),mid+1,r,ql,qr));
    return res;
}

int query(int o,int l,int r,int ql,int qr,int qa,int qb){
    if(ql&lt;=l&amp;&amp;r&lt;=qr) return _query(root[o],1,n,qa,qb);
    int mid=(l+r)&gt;&gt;1,res=0;
    if(ql&lt;=mid) res=max(res,query(lc(o),l,mid,ql,qr,qa,qb));
    if(mid&lt;qr) res=max(res,query(rc(o),mid+1,r,ql,qr,qa,qb));
    return res;
}

int change(int o,int l,int r,int qx,int qy,int qv){
    int x=++tot;
    lc(x)=lc(o); rc(x)=rc(o);
    root[x]=_change(root[o],1,n,qy,qv);
    if(l==r) return x;
    int mid=(l+r)&gt;&gt;1;
    if(qx&lt;=mid) lc(x)=change(lc(o),l,mid,qx,qy,qv);
    else rc(x)=change(rc(o),mid+1,r,qx,qy,qv);
    return x;
}

bool cmp(const int &amp;a,const int &amp;b){
    return last[a]&lt;last[b];
}

int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    memset(last,0,sizeof(last));
    for(int i=1;i&lt;=n;i++) pos[i]=0;
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
        last[i]=pos[a[i]],pos[a[i]]=i;
    }
    memset(next,0,sizeof(next));
    for(int i=1;i&lt;=n;i++) pos[i]=n+1;
    for(int i=n;i&gt;=1;i--){
        rank[i]=i;
        next[i]=pos[a[i]],pos[a[i]]=i;
    }
    sort(rank+1,rank+n+1,cmp);
    int j=1,ans=0,l,r;
    for(int i=0;i&lt;n;i++){
        if(i) tree[i]=tree[i-1];
        while(j&lt;=n&amp;&amp;last[rank[j]]==i){
            tree[i]=change(tree[i],0,n+1,next[rank[j]],rank[j],a[rank[j]]);
            j++;
        }
    }
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
        l=(l+ans)%n+1;
        r=(r+ans)%n+1;
        if(l&gt;r) swap(l,r);
        ans=query(tree[l-1],0,n+1,r+1,n+1,l,r);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}<pre><h2>Problem3506</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 100010
int fa[N],ch[2][N],s[N],rt;
bool flag[N]; pair&lt;int,int&gt;a[N];
inline void reverse(const int&amp;u) {flag[u]^=1; swap(ch[0][u],ch[1][u]);}
inline void down(const int&amp;u) {
	if(!flag[u])return;
	flag[u]=false;
	if(ch[0][u])reverse(ch[0][u]);
	if(ch[1][u])reverse(ch[1][u]);
}
inline void up(const int&amp;u) {s[u]=1+s[ch[0][u]]+s[ch[1][u]];}
inline void rot(const int&amp;u) {
	static int f,d,t;
	f=fa[u],d=u==ch[1][f];
	down(f),down(u);
	(t=ch[d][f]=ch[d^1][u])?fa[t]=f:0;
	(t=fa[u]=fa[f])?ch[f==ch[1][t]][t]=u:0;
	fa[f]=u,ch[d^1][u]=f;
	up(f),up(u);
}
inline void splay(int u,const int&amp;target) {
	for(int t;fa[u]^target;rot(u))
		if(fa[t=fa[u]]^target) ((u==ch[1][t])^(t==ch[1][fa[t]]))?rot(u):rot(t);
	if(!target) rt=u;
}
inline void del(int u) {
	splay(u,0);
	down(u);
	if(!ch[0][u]||!ch[1][u])fa[rt=ch[0][u]+ch[1][u]]=0;
	else {
		int t=ch[0][u];
		for(down(t);ch[1][t];down(t))t=ch[1][t];
		splay(t,u);
		fa[ch[1][t]=ch[1][u]]=t;
		fa[t]=0; rt=t;
		up(t);
	}
}
int build(int l,int r) {
	if(l&gt;r) return 0;
	int m=l+r&gt;&gt;1;
	s[m]=r-l+1;
	if(ch[0][m]=build(l,m-1))fa[ch[0][m]]=m;
	if(ch[1][m]=build(m+1,r))fa[ch[1][m]]=m;
	return m;
}
int main() {
	register int n=gi(),i;
	for(i=1;i&lt;=n;++i)a[i].first=gi(),a[i].second=i;
	sort(a+1,a+n+1);
	rt=build(1,n);
	for(i=1;i&lt;=n;++i) {
		splay(a[i].second,0);
		reverse(ch[0][rt]);
		printf(&quot;%d &quot;,s[ch[0][rt]]+i);
		del(rt);
	}
	return 0;
}<pre><h2>Problem3513</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define N 399999
struct complex {
    double x, i;
    complex(double _x = 0, double _i = 0) : x(_x), i(_i) {}
    complex operator + (const complex &amp;a) {return complex(x + a.x, i + a.i);}
    complex operator - (const complex &amp;a) {return complex(x - a.x, i - a.i);}
    complex operator * (const complex &amp;a) {return complex(x * a.x - i*a.i, x * a.i + i * a.x);}
}a[N];
int rev[N], s[N];
const double pi = acos(-1.0);
void fft(complex *a, int n, int flag) {
    static int i, j, k; static complex t1, t2;
    for (i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]);
    for (i = 1; i &lt; n; i &lt;&lt;= 1) {
        complex wn(cos(pi/i), flag * sin(pi/i));
        for (j = 0; j &lt; n; j += (i &lt;&lt; 1)) {
            complex w(1, 0);
            for (k = 0; k &lt; i; ++k) {
                t1 = a[j + k], t2 = w * a[i + j + k];
                a[j + k] = t1 + t2;
                a[i + j + k] = t1 - t2;
                w = w * wn;
            }
        }
    }
}
int main() {
	int __, n, i, x, mx, len, ___;
	long long tot, pre;
	scanf(&quot;%d&quot;, &amp;__);
	while (__--) {
		scanf(&quot;%d&quot;, &amp;n);
		___ = n;
		memset(s, 0, sizeof s);
		memset(a, 0, sizeof a);
		mx = -1;
		while (n--) {
			scanf(&quot;%d&quot;, &amp;x);
			mx = std::max(mx, x);
			++s[x];
		}
		++mx;
		for (i = 1; i &lt; mx; ++i) a[i].x = s[i];
		for (n = 1, len = 0; n &lt;= (mx&lt;&lt;1); n &lt;&lt;= 1) ++len;
		for (i = 0; i &lt; n; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;len-1);
		fft(a, n, 1);
		for (i = 0; i &lt;= n; ++i) a[i] = a[i] * a[i];
		fft(a, n, -1);
		tot = pre = 0LL;
		for (i = 0; i &lt;= mx; ++i) {
			pre += a[i].x / n + 0.5;
			if (~i &amp; 1) pre -= s[i &gt;&gt; 1];
			tot += pre * s[i];
		}
		tot &gt;&gt;= 1;
		pre = (long long)___ * (___ - 1) * (___ - 2) / 6LL;
		printf(&quot;%.7lf\n&quot;, 1 - (double)tot / pre);
	}
	return 0;
}
<pre><h2>Problem3514</h2><pre>#include &lt;stdio.h&gt;
int n, m, Q, T;
int rev[400010], minv[400010], son[400010][2], fa[400010], val[400010], tmp;
int ql, qr, num, ans, total, total_node;
int ls[4000010], rs[4000010], sum[4000010], hehe[400010], root[400010];
 
struct EDGE{
	int u, v;
}e[400010];
 
void pushup(int u) {
	minv[u] = u;
	if (val[minv[son[u][0]]] &lt; val[minv[u]])
		minv[u] = minv[son[u][0]];
	if (val[minv[son[u][1]]] &lt; val[minv[u]])
		minv[u] = minv[son[u][1]];
}
 
void pushdown(int u) {
	if (rev[u]) {
		rev[u] = 0;
		rev[son[u][0]] ^= 1;
		rev[son[u][1]] ^= 1;
		tmp = son[u][0]; son[u][0] = son[u][1]; son[u][1] = tmp;
	}
}
 
int notroot(int u) {
	return son[fa[u]][0] == u || son[fa[u]][1] == u;
}
 
void rotate(int u) {
	int f = fa[u], p;
	p = son[fa[u]][1] == u;
	fa[u] = fa[f];
	if (notroot(f)) son[fa[f]][son[fa[f]][1] == f] = u;
	son[f][p] = son[u][!p];
	if (son[f][p]) fa[son[f][p]] = f;
	fa[f] = u;
	son[u][!p] = f;
	pushup(f);
}
 
void clea(int u) {
	if (notroot(u))
		clea(fa[u]);
	pushdown(u);
}
 
void splay(int u) {
	int f;
	for (clea(u); notroot(u); rotate(u)) {
		f = fa[u];
		if (notroot(f))	
			rotate((son[fa[f]][1] == f) ^ (son[f][1] == u) ? u : f);
	}
	pushup(u);
}
 
void access(int u) {
	int pre = 0;
	while (u) {
		splay(u);	
		son[u][1] = pre;
		pre = u;
		u = fa[u];
	}
}
 
void makeroot(int u) {
	access(u);
	splay(u);
	rev[u] ^= 1;
}
 
void link(int u, int v) {
	makeroot(u);
	fa[u] = v;
}
 
void cut(int u, int v) {
	makeroot(u);
	access(v);
	splay(v);
	fa[u] = son[v][0] = 0;
}
 
int find(int u) {
	access(u); splay(u);
	while (son[u][0])
		u = son[u][0];
	return u;
}
 
int query_minv(int u, int v) {
	makeroot(u);
	access(v);
	splay(v);
	return minv[v];
}
 
void insert(int x, int y, int l, int r) {
	int mid = (l + r) &gt;&gt; 1;
	sum[x] = sum[y] + 1;
	if (l == r) return;
	ls[x] = ls[y]; rs[x] = rs[y];
	if (num &lt;= mid) {
		ls[x] = ++total;
		insert(ls[x], ls[y], l, mid);
	}
	else {
		rs[x] = ++total;
		insert(rs[x], rs[y], mid + 1, r);
	}
}
 
void query(int x, int y, int l, int r) {
	int mid = (l + r) &gt;&gt; 1;
	if (l == r) {
		ans -= sum[x] - sum[y];
		return;
	}
	if (num &lt;= mid) query(ls[x], ls[y], l, mid);
	else {
		ans -= sum[ls[x]] - sum[ls[y]];
		query(rs[x], rs[y], mid + 1, r);
	}
}
 
int main() {
	int i, u, v, t;
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;Q, &amp;T); total_node = n;
	for (i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;e[i].u, &amp;e[i].v);
	for (i = 0; i &lt;= n; i++) minv[i] = i, val[i] = 1000000000;
	for (i = 1; i &lt;= m; i++) {
		u = e[i].u, v = e[i].v;
		if (u == v) { hehe[i] = i; continue; }
		if (find(u) == find(v)) {
			t = query_minv(u, v);
			cut(e[val[t]].u, t); cut(e[val[t]].v, t);
			hehe[i] = val[t];
		}
		total_node++;
		minv[total_node] = total_node;
		val[total_node] = i;
		link(u, total_node);
		link(v, total_node); 
	}
	for (i = 1; i &lt;= m; i++) {
		root[i] = ++total; num = hehe[i];
		insert(root[i], root[i - 1], 0, m);	
	}
	for (i = 1; i &lt;= Q; i++) {
		scanf(&quot;%d%d&quot;, &amp;ql, &amp;qr);
		if (T) { ql ^= ans; qr ^= ans; }
		ans = n; num = ql - 1;
		query(root[qr], root[ql - 1], 0, m);
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}
<pre><h2>Problem3514</h2><pre>#include &lt;cstdio&gt;

const int Max = 200007, inf = 0x3f3f3f3f;

struct FastInput {
	char b[5&lt;&lt;21], *s;
	FastInput() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 21, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		while (*s &lt; 48) ++s;
		a = *s++ - 48;
		while (47 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
	}
} io;

struct LCT {
	struct node {
		int val;
		bool rev;
		node *fa, *ch[2], *mi;
	} node_mset[Max &lt;&lt; 1], *nil;
	void Init(const int &amp;n) {
		nil = node_mset;
		*nil = (node){inf, false, nil, {nil, nil}, nil};
		for (int i = 1; i &lt;= n; ++i)
			node_mset[i] = *nil;
	}
	inline node* num(const int &amp;x)  {
		return node_mset + x;
	}
	inline bool isrt(node *u) const {
		return (u-&gt;fa-&gt;ch[0] != u) &amp;&amp; (u-&gt;fa-&gt;ch[1] != u);
	}
	inline bool which(node *u) const {
		return u-&gt;fa-&gt;ch[1] == u;
	}
	inline void maintain(node *u) {
		u-&gt;mi = u;
		if(u-&gt;ch[0]-&gt;mi-&gt;val &lt; u-&gt;mi-&gt;val)
			u-&gt;mi = u-&gt;ch[0]-&gt;mi;
		if(u-&gt;ch[1]-&gt;mi-&gt;val &lt; u-&gt;mi-&gt;val)
			u-&gt;mi = u-&gt;ch[1]-&gt;mi;
	}
	inline void rot(node *u) {
		node *f = u-&gt;fa;
		int d = which(u);
		if ((f-&gt;ch[d] = u-&gt;ch[d ^ 1]) != nil)
			f-&gt;ch[d]-&gt;fa = f;
		u-&gt;ch[d ^ 1] = f;
		u-&gt;fa = f-&gt;fa;
		if (!isrt(f))
			f-&gt;fa-&gt;ch[which(f)] = u;
		f-&gt;fa = u;
		maintain(f);
	}
	inline void swap(node * &amp;x, node * &amp;y) {
		static node *t;
		t = x, x = y, y = t;
	}
	inline void pd(node *u) {
		if (!isrt(u)) pd(u-&gt;fa);
		if (u-&gt;rev) {
			u-&gt;ch[0]-&gt;rev ^= true;
			u-&gt;ch[1]-&gt;rev ^= true;
			swap(u-&gt;ch[0], u-&gt;ch[1]);
			u-&gt;rev = false;
		}
	}
	inline void splay(node *u) {
		pd(u);
		for (node *f; !isrt(u); rot(u))
			if (!isrt(f = u-&gt;fa)) rot(which(f) == which(u) ? f : u);
		maintain(u);
	}
	inline void access(node *x) {
		for (node *y = nil; x != nil; x = x-&gt;fa)
			splay(x), x-&gt;ch[1] = y, maintain(y = x);
	}
	inline void mrt(node *u) {
		access(u);
		splay(u);
		u-&gt;rev ^= 1;
	}
	inline void link(node *u, node *v) {
		mrt(u);
		u-&gt;fa = v;
		access(u);
	}
	inline void cut(node *v) {
		splay(v);
		v-&gt;ch[0]-&gt;fa = v-&gt;fa;
		v-&gt;ch[1]-&gt;fa = nil;
		v-&gt;fa = v-&gt;ch[0] = v-&gt;ch[1] = nil;
		v-&gt;mi = v;
	}
	inline void add_edge(int u, int v, int w) {
		node *_u = num(u), *_v = num(v), *_w = num(w);
		link(_u, _w);
		link(_v, _w);
	}
	inline int query(int u, int v) {
		node *_u = num(u), *_v = num(v);
		mrt(_u);
		access(_v), splay(_v);
		return _v-&gt;mi-&gt;val;
	}
} tree;

struct SegMentTree {
	struct node {
		int sum;
		node *ls, *rs;
	} node_mset[Max * 40], *root[Max], *cnode;
	SegMentTree() : cnode(node_mset) {
		*root = node_mset;
		**root = (node) {0, *root, *root};
	}
	inline void insert(node *x, node * &amp;y, int l, int r, const int &amp;p) {
		*(y = ++cnode) = *x;
		++y-&gt;sum;
		if (l == r) return;
		int mid = (l + r) &gt;&gt; 1;
		if (p &lt;= mid) insert(x-&gt;ls, y-&gt;ls, l, mid, p);
		else insert(x-&gt;rs, y-&gt;rs, mid + 1, r, p);
	}

	inline int query(node *x, node *y, int l, int r, const int &amp;p) {
		if (r &lt;= p)
			return y-&gt;sum - x-&gt;sum;
		int mid = (l + r) &gt;&gt; 1;
		if (p &lt;= mid)
			return query(x-&gt;ls, y-&gt;ls, l, mid, p);
		else
			return query(x-&gt;rs, y-&gt;rs, mid + 1, r, p) + y-&gt;ls-&gt;sum - x-&gt;ls-&gt;sum;
	}

	inline void insert(int x, int n, int p) {
		insert(root[x - 1], root[x], 0, n, p);
	}

	inline int query(int l, int r, int n) {
		return query(root[l - 1], root[r], 0, n, l - 1);
	}
	
} seg;

int f[Max];

inline int gf(int u) {
	while (u ^ f[u]) u = f[u] = f[f[u]];
	return u;
}

int main() {
	
	int n, m, k, type, lastans = 0, x, y;
	
	io.gi(n), io.gi(m), io.gi(k), io.gi(type);

	tree.Init(n + m);

	for (register int i = 1; i &lt;= n; ++i)
		f[i] = i;
		
	
	for (register int i = 1; i &lt;= m; ++i) {
		io.gi(x), io.gi(y);
		if (x == y)
			seg.insert(i, m, i);
		else {
			if (gf(x) == gf(y)) {
				static int t;
				t = tree.query(x, y);
				tree.cut(tree.num(t + n));
				seg.insert(i, m, t);
			} else {
				seg.insert(i, m, 0);
				f[gf(x)] = gf(y);
			}
			tree.num(i + n)-&gt;val = i;
			tree.add_edge(x, y, i + n);
		}
	}

	while (k--) {
		io.gi(x), io.gi(y);
		if (type) x ^= lastans, y ^= lastans;
		lastans = n - seg.query(x, y, m);
		printf(&quot;%d\n&quot;, lastans);
	}
	
	return 0;
}<pre><h2>Problem3514</h2><pre>#include &lt;cstdio&gt;

const int Max = 200007, inf = 0x3f3f3f3f;

struct FastInput {
	char b[5&lt;&lt;21], *s;
	FastInput() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 21, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		while (*s &lt; 48) ++s;
		a = *s++ - 48;
		while (47 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
	}
} io;

struct LCT {
	struct node {
		int val;
		bool rev;
		node *fa, *ch[2], *mi;
	} node_mset[Max &lt;&lt; 1], *nil;
	void Init(const int &amp;n) {
		nil = node_mset;
		*nil = (node){inf, false, nil, {nil, nil}, nil};
		for (int i = 1; i &lt;= n; ++i)
			node_mset[i] = *nil;
	}
	inline node* num(const int &amp;x)  {
		return node_mset + x;
	}
	inline bool isrt(node *u) const {
		return (u-&gt;fa-&gt;ch[0] != u) &amp;&amp; (u-&gt;fa-&gt;ch[1] != u);
	}
	inline bool which(node *u) const {
		return u-&gt;fa-&gt;ch[1] == u;
	}
	inline void maintain(node *u) {
		u-&gt;mi = u;
		if(u-&gt;ch[0]-&gt;mi-&gt;val &lt; u-&gt;mi-&gt;val)
			u-&gt;mi = u-&gt;ch[0]-&gt;mi;
		if(u-&gt;ch[1]-&gt;mi-&gt;val &lt; u-&gt;mi-&gt;val)
			u-&gt;mi = u-&gt;ch[1]-&gt;mi;
	}
	inline void rot(node *u) {
		node *f = u-&gt;fa;
		int d = which(u);
		if ((f-&gt;ch[d] = u-&gt;ch[d ^ 1]) != nil)
			f-&gt;ch[d]-&gt;fa = f;
		u-&gt;ch[d ^ 1] = f;
		u-&gt;fa = f-&gt;fa;
		if (!isrt(f))
			f-&gt;fa-&gt;ch[which(f)] = u;
		f-&gt;fa = u;
		maintain(f);
	}
	inline void swap(node * &amp;x, node * &amp;y) {
		static node *t;
		t = x, x = y, y = t;
	}
	inline void pd(node *u) {
		if (!isrt(u)) pd(u-&gt;fa);
		if (u-&gt;rev) {
			u-&gt;ch[0]-&gt;rev ^= true;
			u-&gt;ch[1]-&gt;rev ^= true;
			swap(u-&gt;ch[0], u-&gt;ch[1]);
			u-&gt;rev = false;
		}
	}
	inline void splay(node *u) {
		pd(u);
		for (node *f; !isrt(u); rot(u))
			if (!isrt(f = u-&gt;fa)) rot(which(f) == which(u) ? f : u);
		maintain(u);
	}
	inline void access(node *x) {
		for (node *y = nil; x != nil; x = x-&gt;fa)
			splay(x), x-&gt;ch[1] = y, maintain(y = x);
	}
	inline void mrt(node *u) {
		access(u);
		splay(u);
		u-&gt;rev ^= 1;
	}
	inline void link(node *u, node *v) {
		mrt(u);
		u-&gt;fa = v;
		access(u);
	}
	inline void cut(node *v) {
		splay(v);
		v-&gt;ch[0]-&gt;fa = v-&gt;fa;
		v-&gt;ch[1]-&gt;fa = nil;
		v-&gt;fa = v-&gt;ch[0] = v-&gt;ch[1] = nil;
		v-&gt;mi = v;
	}
	inline void add_edge(int u, int v, int w) {
		node *_u = num(u), *_v = num(v), *_w = num(w);
		link(_u, _w);
		link(_v, _w);
	}
	inline int query(int u, int v) {
		node *_u = num(u), *_v = num(v);
		mrt(_u);
		access(_v), splay(_v);
		return _v-&gt;mi-&gt;val;
	}
} tree;

struct SegMentTree {
	struct node {
		int sum;
		node *ls, *rs;
	} node_mset[Max * 20], *root[Max], *cnode;
	SegMentTree() : cnode(node_mset) {
		*root = node_mset;
		**root = (node) {0, *root, *root};
	}
	inline void insert(node *x, node * &amp;y, int l, int r, const int &amp;p) {
		*(y = ++cnode) = *x;
		++y-&gt;sum;
		if (l == r) return;
		int mid = (l + r) &gt;&gt; 1;
		if (p &lt;= mid) insert(x-&gt;ls, y-&gt;ls, l, mid, p);
		else insert(x-&gt;rs, y-&gt;rs, mid + 1, r, p);
	}

	inline int query(node *x, node *y, int l, int r, const int &amp;p) {
		if (r &lt;= p)
			return y-&gt;sum - x-&gt;sum;
		int mid = (l + r) &gt;&gt; 1;
		if (p &lt;= mid)
			return query(x-&gt;ls, y-&gt;ls, l, mid, p);
		else
			return query(x-&gt;rs, y-&gt;rs, mid + 1, r, p) + y-&gt;ls-&gt;sum - x-&gt;ls-&gt;sum;
	}

	inline void insert(int x, int n, int p) {
		insert(root[x - 1], root[x], 0, n, p);
	}

	inline int query(int l, int r, int n) {
		return query(root[l - 1], root[r], 0, n, l - 1);
	}
	
} seg;

int f[Max];

inline int gf(int u) {
	while (u ^ f[u]) u = f[u] = f[f[u]];
	return u;
}

int main() {
	
	int n, m, k, type, lastans = 0, x, y;
	
	io.gi(n), io.gi(m), io.gi(k), io.gi(type);

	tree.Init(n + m);

	for (register int i = 1; i &lt;= n; ++i) f[i] = i;
	
	for (register int i = 1; i &lt;= m; ++i) {
		io.gi(x), io.gi(y);
		if (x == y)
			seg.insert(i, m, i);
		else {
			if (gf(x) == gf(y)) {
				static int t;
				t = tree.query(x, y);
				tree.cut(tree.num(t + n));
				seg.insert(i, m, t);
			} else {
				seg.insert(i, m, 0);
				f[gf(x)] = gf(y);
			}
			tree.num(i + n)-&gt;val = i;
			tree.add_edge(x, y, i + n);
		}
	}

	while (k--) {
		io.gi(x), io.gi(y);
		if (type) x ^= lastans, y ^= lastans;
		lastans = n - seg.query(x, y, m);
		printf(&quot;%d\n&quot;, lastans);
	}
	
	return 0;
}<pre><h2>Problem3520</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define N 1003
struct Main{
	int f[N], sz[N], n, ans, cnte;
	long double sum[N];
	struct edge {
		long double w;
		int u, v;
		bool operator &lt; (const edge &amp;a) const {
			return w &lt; a.w;
		}
	} e[N * N];
	int gf(int u) {
		return f[u] == u ? u : f[u] = gf(f[u]);
	}
	void merge(int u, int v) {
		u = gf(u), v = gf(v);
		if (u == v)
		  return;
		f[u] = v;
		sz[v] += sz[u];
		if (sz[v] &gt; ans)
		  ans = sz[v];
	}
	void Init() {
		scanf(&quot;%d&quot;, &amp;n);
		cnte = 0;
		for (int i = 1, x; i &lt; n; ++i) {
			scanf(&quot;%d&quot;, &amp;x);
			sum[i + 1] = sum[i] + log10(x);
		}
	}
	void Build_Edge() {
		for (int i = 1; i &lt;= n; ++i)
		  for (int j = 1; j &lt; i; ++j)
			e[cnte++] = (edge){(sum[i] - sum[j]) / (i - j), i, j};
		sort(e, e + cnte);
		for (int i = 1; i &lt;= n; ++i)
		  f[i] = i, sz[i]  =1;
	}

	void Work() {
		merge(e[0].u, e[0].v);
		int pre = 0;
		for (int i = 1; i &lt; cnte; ++i) {
			if (e[i - 1].w &lt; e[i].w) {
				for (int j = pre; j &lt; i; ++j) {
					sz[e[j].u] = sz[e[j].v] = 1;
					f[e[j].u] = e[j].u;
					f[e[j].v] = e[j].v;
					pre = i;
				}
			}
			merge(e[i].u, e[i].v);
		}
		for (int i = 1; i &lt;= n; ++i)
		  if (gf(i) == i &amp;&amp; ans &lt; sz[i])
			ans = sz[i];
	}
	Main() {
		cnte = 0, ans = 0;
		Init();
		Build_Edge();
		Work();
		printf(&quot;%d\n&quot;, ans);
	}

}Solve;
int main() {}<pre><h2>Problem3527</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 100009
#define LEN 1199999
struct complex {
	double x, i;
	complex(double _x = 0, double _i = 0) : x(_x), i(_i) {}
	complex operator + (const complex &amp;a) {return complex(x + a.x, i + a.i);}
	complex operator - (const complex &amp;a) {return complex(x - a.x, i - a.i);}
	complex operator * (const complex &amp;a) {return complex(x * a.x - i*a.i, x * a.i + i * a.x);}
}a[LEN], b[LEN];
int rev[LEN];
const double pi = acos(-1.0);
void fft(complex *a, int n, int flag) {
	static int i, j, k; static complex t1, t2;
	for (i = 0; i &lt; n; ++i) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]);
	for (i = 1; i &lt; n; i &lt;&lt;= 1) {
		complex wn(cos(pi/i), flag * sin(pi/i));
		for (j = 0; j &lt; n; j += (i &lt;&lt; 1)) {
			complex w(1, 0);
			for (k = 0; k &lt; i; ++k) {
				t1 = a[j + k], t2 = w * a[i + j + k];
				a[j + k] = t1 + t2;
				a[i + j + k] = t1 - t2;
				w = w * wn;
			}
		}
	}
}

int main() {
	int n, m, len, i, j;
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 0; i &lt; n; ++i) scanf(&quot;%lf&quot;, &amp;a[i].x);
	for (i = 1; i &lt; n; ++i) b[i].x = -1.0 / (n - i) / (n - i), b[i + n].x = 1.0 / i / i;
	m = (n &lt;&lt; 1) + n;
	for (n = 1, len = 0; n &lt;= m; n &lt;&lt;= 1) ++len;
	for (i = 0; i &lt; n; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;len-1);
	fft(a, n, 1); fft(b, n, 1);
	for (i = 0; i &lt;= n; ++i) a[i] = a[i] * b[i];
	fft(a, n, -1);
	for (i = m / 3, m = i &lt;&lt; 1; i &lt; m; ++i) printf(&quot;%.3lf\n&quot;, a[i].x / n);
	return 0;
}
<pre><h2>Problem3551</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
const int N=200005,M=500005,MS=2000000;
int val[N],ch[2][N],p[17][N],st[N],en[N],n,a[N],mpa[N],f[N],mcnt;
int ls[MS],rs[MS],sum[MS],rt[N],cnd,exd,_dfn;
pair&lt; int,pair&lt;int,int&gt; &gt;edge[M]; bool vis[N];
inline int g(const int&amp;x){return lower_bound(mpa+1,mpa+mcnt+1,x)-mpa;}
inline int gf(int u) {
	int r=u;
	while(f[r]^r)r=f[r];
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
void insert(int x,int&amp;y,int l,int r,const int&amp;v) {
	y=++cnd; ls[y]=ls[x],rs[y]=rs[x],sum[y]=sum[x]+1;
	if(l&gt;=r) return;
	int m=l+r&gt;&gt;1;
	if(v&lt;=m)insert(ls[x],ls[y],l,m,v);
	else insert(rs[x],rs[y],m+1,r,v);
}
void dfs(int u) {
	st[u]=++_dfn; vis[u]=true;
	if(u&gt;n)rt[_dfn]=rt[_dfn-1];
	else insert(rt[_dfn-1],rt[_dfn],1,mcnt,a[u]);
	if(ch[0][u])dfs(ch[0][u]),dfs(ch[1][u]);
	en[u]=_dfn;
}
inline int ganc(int u,int x) {
	for(int i=16;~i;--i)if(p[i][u]&amp;&amp;val[p[i][u]]&lt;=x)u=p[i][u];
	return u;
}
inline int query(int x,int y,int k) {
	int l=1,r=mcnt,md,t;
	while(l^r) {
		md=l+r&gt;&gt;1;
		t=sum[ls[y]]-sum[ls[x]];
		if(k&lt;=t)x=ls[x],y=ls[y],r=md;
		else x=rs[x],y=rs[y],l=md+1,k-=t;
	}return mpa[l];
}
int main() {
	int m,q,i,u,v,x,k,ans=0;
	n=gi(),m=gi(),q=gi();
	for(i=1;i&lt;=n;++i)a[i]=mpa[i]=gi();
	sort(mpa+1,mpa+n+1);
	mcnt=unique(mpa+1,mpa+n+1)-mpa-1;
	for(i=1;i&lt;=n;++i)a[i]=g(a[i]);
	for(i=0;i&lt;m;++i) {
		u=gi(),v=gi(),x=gi();
		edge[i]=make_pair(x,make_pair(u,v));
	}
	for(i=n*2;i;--i)f[i]=i;
	sort(edge,edge+m);
	exd=n;
	for(i=0;i&lt;m;++i) 
		if(u=gf(edge[i].second.first),v=gf(edge[i].second.second),u^v) {
			f[u]=f[v]=++exd;
			ch[0][exd]=u,ch[1][exd]=v;
			p[0][u]=p[0][v]=exd;
			val[exd]=edge[i].first;
		}
	for(i=1;i&lt;=n;++i)
		if(!vis[i])dfs(gf(i));
	for(i=1;i&lt;17;++i)for(v=1;v&lt;=exd;++v)p[i][v]=p[i-1][p[i-1][v]];
	while(q--) {
		u=gi()^ans,x=gi()^ans,k=gi()^ans;
		v=ganc(u,x);
		i=sum[rt[en[v]]]-sum[rt[st[v]-1]];
		if(i&lt;k)puts(&quot;-1&quot;),ans=0;
		else printf(&quot;%d\n&quot;,ans=query(rt[st[v]-1],rt[en[v]],i-k+1));
	}return 0;
}
<pre><h2>Problem3563</h2><pre>#include &lt;bits/stdc++.h&gt;
char s[1009], mark[500001];
std::pair&lt;int, int&gt; e[500001];
int fa[100001], ans[50001];
int gf(int u) {
	return ::fa[u] == u ? u : ::fa[u] = gf(::fa[u]);
}
#define isdight(c) (c &gt;= '0' &amp;&amp; c &lt;= '9')
inline bool uni(int x, int y) {
	x = gf(x), y = gf(y);
	if (x ^ y) return ::fa[x] = y, true;
	return false;
}
int main() {
	int n, m, q, i, j, k, _k, block;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 1; i &lt;= m; ++i) 
		scanf(&quot;%d%d&quot;, &amp;::e[i].first, &amp;::e[i].second);
	scanf(&quot;%d&quot;, &amp;q);
	for (i = 1; i &lt;= q; ++i) {
		scanf(&quot;%d&quot;, &amp;_k);
		gets(::s + 1); k = 0;
		for (char *it = ::s + 1; *it; ++it)
			if (isdight(*it) &amp;&amp; !isdight(it[1]))
				++k;
		::ans[i] = k ^ _k;
	}
	for (i = 1; i &lt; q; ++i)
		puts((::ans[i + 1] ^ ::ans[i]) ? &quot;Connected&quot; : &quot;Disconnected&quot;);
	
	for (i = *::s = 1, k = 0; ::s[i - 1]; ++i)
		if (isdight(::s[i]))
			k = k * 10 + ::s[i] - '0';
		else if (isdight(::s[i - 1]))
			::mark[k ^ ::ans[q]] = 1, k = 0;
	block = n;
	for (i = 1; i &lt;= n; ++i)
		::fa[i] = i;

	for (i = 1; i &lt;= m; ++i)
		if (!mark[i] &amp;&amp; uni(e[i].first, e[i].second))
			--block;
	puts(block == 1 ? &quot;Connected&quot; : &quot;Disconnected&quot;);
	return 0;
}<pre><h2>Problem3569</h2><pre>    #include &lt;cstdio&gt;  
    #include &lt;cstring&gt;  
    #include &lt;iostream&gt;  
    #include &lt;algorithm&gt;  
    #define M 100100  
    using namespace std;  
    struct abcd{  
        int to,next;  
    }table[1001001];  
    int head[M],tot=1;  
    int n,m,q,last_ans;  
    int a[500500],b[M];  
    int stack[20],top;  
    void Add(int x,int y)  
    {  
        table[++tot].to=y;  
        table[tot].next=head[x];  
        head[x]=tot;  
    }  
    void DFS1(int x,int from)  
    {  
        static bool v[M];  
        int i;  
        v[x]=1;  
        for(i=head[x];i;i=table[i].next)  
        {  
            if(table[i].to==from)  
                continue;  
            if(!v[table[i].to])  
                DFS1(table[i].to,x);  
            else if(!~a[i&gt;&gt;1])  
            {  
                a[i&gt;&gt;1]=rand();  
                b[table[i].to]^=a[i&gt;&gt;1];  
                b[x]^=a[i&gt;&gt;1];  
            }  
        }  
    }  
    void DFS2(int x,int from)  
    {  
        static bool v[M];  
        int i;  
        v[x]=1;  
        for(i=head[x];i;i=table[i].next)  
            if(!v[table[i].to])  
            {  
                DFS2(table[i].to,x);  
                a[i&gt;&gt;1]=b[table[i].to];  
                b[x]^=b[table[i].to];  
            }  
    }  
    void Gauss_Elimination()  
    {  
        int i,j,k=0;  
        for(j=1&lt;&lt;30;j;j&gt;&gt;=1)  
        {  
            for(i=k+1;i&lt;=top;i++)  
                if(stack[i]&amp;j)  
                    break;  
            if(i==top+1)  
                continue;  
            swap(stack[i],stack[++k]);  
            for(i=1;i&lt;=top;i++)  
                if(stack[i]&amp;j&amp;&amp;i!=k)  
                    stack[i]^=stack[k];  
        }  
    }  
    int main()  
    {  
           
        srand(19980402);  
           
        int i,x,y,k;  
        cin&gt;&gt;n&gt;&gt;m;  
        for(i=1;i&lt;=m;i++)  
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y),Add(x,y),Add(y,x);  
        memset(a,-1,sizeof a);  
        DFS1(1,0);  
        DFS2(1,0);  
        cin&gt;&gt;q;  
        for(i=1;i&lt;=q;i++)  
        {  
            scanf(&quot;%d&quot;,&amp;k);top=0;  
            for(;k;k--)  
                scanf(&quot;%d&quot;,&amp;x),stack[++top]=a[x^last_ans];  
            Gauss_Elimination();  
            last_ans+=(bool)stack[top];  
            printf(&quot;%s\n&quot;,stack[top]?&quot;Connected&quot;:&quot;Disconnected&quot;);  
        }  
    }  <pre><h2>Problem3569</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 100001
#define M 500001
#define CON &quot;Connected&quot;
#define DIS &quot;Disconnected&quot;
struct edge {int t, n;} me[M&lt;&lt;1|1];
int g[N], a[M], b[N], stk[17], tp;
#define FOR(a, b) for (int a = g[b]; a; a = me[a].n)
inline void adde(int a, int b) {
	static unsigned int ce = 1;
	me[++ce] = (edge) {b, g[a]};
	g[a] = ce;
}
void d1(int u, int f) {
	static bool vis[N];
	vis[u] = true;
	unsigned int v;
	FOR (i, u) if ((v = me[i].t) ^ f) {
		if (!vis[v]) d1(v, u);
		else if (!~a[i &gt;&gt; 1]) {
			a[i &gt;&gt; 1] = ((rand() &lt;&lt; 12) ^ rand()) &amp; ((1U &lt;&lt; 31) - 1);
			b[v] ^= a[i &gt;&gt; 1];
			b[u] ^= a[i &gt;&gt; 1];
		}
	}
}
void d2(int u) {
	static bool vis[N];
	vis[u] = true;
	FOR(i, u) if (!vis[me[i].t]) {
		d2(me[i].t);
		a[i &gt;&gt; 1] = b[me[i].t];
		b[u] ^= b[me[i].t];
	}
}
inline void guass() {
	static int i, j, k;
	for (k = 0, j = 1 &lt;&lt; 30; j; j &gt;&gt;= 1) {
		for (i = k + 1; i &lt;= tp; ++i)
			if (stk[i] &amp; j) break;
		if (i &gt; tp) continue;
		std::swap(stk[i], stk[++k]);
		for (i = 1; i &lt;= tp; ++i)
			if (stk[i] &amp; j &amp;&amp; (i ^ k))
				stk[i] ^= stk[k];
	}
}
int main() {

	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	
	srand(1234321);
	int i, x, y, k, n, m, q, last_ans = 0U;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		adde(x, y), adde(y, x);
	}
	memset(a, -1, sizeof a);
	d1(1, 0); d2(1);
	scanf(&quot;%d&quot;, &amp;q);
	while (q--) {
		scanf(&quot;%d&quot;, &amp;k);
		tp = 0;
		while (k--) {
			scanf(&quot;%d&quot;, &amp;x);
			stk[++tp] = a[x ^ last_ans];
		}
		guass();
		last_ans += (bool)stk[tp];
		puts(stk[tp] ? CON : DIS);
	}
	return 0;
}<pre><h2>Problem3572</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int maxn(3e5 + 7);

typedef int arr[maxn];
typedef std::pair&lt;int, int&gt; pii;

struct edge {
	int to;
	edge *nxt;
} edge_mset[maxn &lt;&lt; 1], *cedge = edge_mset, *g[maxn];


inline void add_edge(int u, int v) {
	*cedge = (edge) {v, g[u]};
	g[u] = cedge++;
}

pii ner[maxn];
int n, m, _clock, tot, p[maxn][20];
arr dep, dfn, size, pos, h, t, stk, fa, w, dis, ans;

inline bool cmp(const int &amp;a, const int &amp;b) {
	return dfn[a] &lt; dfn[b];
}

inline int find_vert(int x, int d) {
	for (register int i = 0, _d = dep[x] - d; _d; ++i, _d &gt;&gt;= 1)
		if (_d &amp; 1) x = p[x][i];
	return x;
}

inline int lca(int u, int v) {
	if (dep[u] &lt; dep[v]) std::swap(u, v);
	int d = dep[u] - dep[v];
	for (register int i = 0; d; ++i, d &gt;&gt;= 1)
		if (d &amp; 1) u = p[u][i];
	if (u == v) return u;
	for (register int i = 19; ~i; --i)
		if (p[u][i] ^ p[v][i])
			u = p[u][i], v = p[v][i];
	return p[u][0];
}

void dfs(int u) {
	size[u] = 1;
	dfn[u] = ++_clock;
	for (register int i = 1; p[u][i] = p[p[u][i - 1]][i - 1]; ++i);
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if (it-&gt;to ^ p[u][0]) {
			p[it-&gt;to][0] = u;
			dep[it-&gt;to] = dep[u] + 1;
			dfs(it-&gt;to);
			size[u] += size[it-&gt;to];
		}
}

inline void build_vt() {
	static int *top, x;

	top = stk;
	std::sort(h + 1, h + m + 1, cmp);
	for (register int i = 1; i &lt;= m; ++i) {
		if (top == stk) fa[*++top = h[i]] = 0;
		else {
			for (x = lca(*top, h[i]); dep[*top] &gt; dep[x]; --top)
				if (dep[top[-1]] &lt;= dep[x]) fa[*top] = x;
			if (*top ^ x) {
				fa[x] = *top;
				t[++tot] = *++top = x;
				ner[x] = std::make_pair(0x3f3f3f3f, 0);
			}
			fa[*++top = h[i]] = x;
		}
	}
}

inline void solve() {
	tot = 0;
	scanf(&quot;%d&quot;, &amp;m);
	for (register int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, h + i);
		t[++tot] = pos[i] = h[i];
		ans[h[i]] = 0;
		ner[h[i]] = std::make_pair(0, h[i]);
	}
	build_vt();
	std::sort(t + 1, t + tot + 1, cmp);
	w[t[1]] = size[t[1]];
	for (register int i = 2; i &lt;= tot; ++i)
		w[t[i]] = size[t[i]], dis[t[i]] = dep[t[i]] - dep[fa[t[i]]];
	for (register int i = tot, x; i &gt; 1; --i)
		x = t[i], ner[fa[x]] = std::min(ner[fa[x]], std::make_pair(ner[x].first + dis[x], ner[x].second));
	for (register int i = 2, x; i &lt;= tot; ++i)
		x = t[i], ner[x] = std::min(ner[x], std::make_pair(ner[fa[x]].first + dis[x], ner[fa[x]].second));
	ans[ner[t[1]].second] = n - size[t[1]];
	for (register int i = 2, x; i &lt;= tot; ++i) {
		static int rt, sum;
		x  = t[i];
		rt = find_vert(x, dep[fa[x]] + 1);
		sum = size[rt] - size[x];
		w[fa[x]] -= size[rt];
		if (ner[fa[x]].second == ner[x].second) ans[ner[x].second] += sum;
		else {
			static int mid, tmp;
			mid = dep[x] - (ner[fa[x]].first - ner[x].first + dis[x]) / 2;
			if (!((ner[fa[x]].first + ner[x].first + dis[x]) &amp; 1) &amp;&amp; ner[fa[x]].second &lt; ner[x].second)
				++mid;
			tmp = size[find_vert(x, mid)] - size[x];
			ans[ner[fa[x]].second] += sum - tmp;
			ans[ner[x].second] += tmp;
		}
	}
	for (register int i = 1; i &lt;= tot; ++i) ans[ner[t[i]].second] += w[t[i]];
	for (register int i = 1; i &lt;= m; ++i) printf(&quot;%d &quot;, ans[pos[i]]);
	puts(&quot;&quot;);
}
int main() {

	//freopen(&quot;3572.in&quot;, &quot;r&quot;, stdin);

	int u, v, q;
	scanf(&quot;%d&quot;, &amp;n);
	for (register int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		add_edge(u, v), add_edge(v, u);
	}
	dep[1] = 1;
	dfs(1);
	scanf(&quot;%d&quot;, &amp;q);
	while (q--) solve();
	return 0;
}<pre><h2>Problem3594</h2><pre>#include &lt;cstdio&gt;

const int maxn(10003), maxk(505);

int tr[maxk][5555], n, k, maxa, a[maxn];

inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

inline int query(int x, int y) {
	int ans = 0;
	for (register int i = x; i; i = i &amp; (i - 1))
		for (register int j = y; j; j = j &amp; (j - 1))
			cmax(ans, tr[i][j]);
	return ans;
}

inline void modify(int x, int y, int val) {
	for (register int i = x; i &lt;= k; i += i &amp; -i)
		for (register int j = y; j &lt;= maxa; j += j &amp; -j)
			cmax(tr[i][j], val);
}

int main() {
	int ans(0), t;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	++k;
	for (register int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, a + i);
		cmax(maxa, a[i]);
	}
	maxa += k;
	for (register int i = 1; i &lt;= n; ++i)
		for (register int j = k; j; --j) {
			t = query(j, a[i] + j) + 1;
			cmax(ans, t);
			modify(j, a[i] + j, t);
		}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem3626</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 50005, mod = 201314;

struct SegNode {
	int sum, lazy;
	SegNode *ls, *rs;
} SegNode_Mset[MaxN * 150], *root[MaxN], *cSegNode = SegNode_Mset;

inline void modify(SegNode *a, SegNode * &amp;b, int l, int r, const int &amp;x, const int &amp;y) {
	*(b = ++cSegNode) = *a;
	if (x &lt;= l &amp;&amp; r &lt;= y)
		return (void)(b-&gt;sum += r - l + 1, ++b-&gt;lazy);
	int mid = (l + r) &gt;&gt; 1;
	if (x &lt;= mid) modify(a-&gt;ls, b-&gt;ls, l, mid, x, y);
	if (y &gt;  mid) modify(a-&gt;rs, b-&gt;rs, mid + 1, r, x, y);
	b-&gt;sum = b-&gt;ls-&gt;sum + b-&gt;rs-&gt;sum + b-&gt;lazy * (r - l + 1);
}

inline int query(SegNode *a, SegNode *b, int l, int r, const int &amp;x, const int &amp;y) {
	static int _x = 0, _y = 0;
	if (x &lt;= l &amp;&amp; r &lt;= y)
		return b-&gt;sum - a-&gt;sum + (_y - _x) * (r - l + 1);
	int ret = 0, mid = (l + r) &gt;&gt; 1;
	_x += a-&gt;lazy, _y += b-&gt;lazy;
	if (x &lt;= mid) ret += query(a-&gt;ls, b-&gt;ls, l, mid, x, y);
	if (y &gt;  mid) ret += query(a-&gt;rs, b-&gt;rs, mid + 1, r, x, y);
	_x -= a-&gt;lazy, _y -= b-&gt;lazy;
	return ret;
}

struct edge {
	int to;
	edge *nxt;
} edge_mset[MaxN], *cedge = edge_mset, *g[MaxN];

int in[MaxN], fa[MaxN], top[MaxN], dfn, son[MaxN], size[MaxN];

inline void d1(int u) {
	int v;
	size[u] = 1;
	for (edge *it = g[u]; it; it = it-&gt;nxt) {
		v = it-&gt;to;
		d1(v);
		if (size[v] &gt; size[son[u]]) son[u] = v;
		size[u] += size[v];
	}
}

inline void d2(int u, int anc) {
	top[u] = anc;
	in[u] = ++dfn;
	if (son[u]) d2(son[u], anc);
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if (!in[it-&gt;to]) d2(it-&gt;to, it-&gt;to);
}

inline void update(int u) {
	int id = u;
	while (u) {
		modify(root[id], root[id], 1, dfn, in[top[u]], in[u]);
		u = fa[top[u]];
	}
}

inline int sum(int u, int l, int r) {
	static int ret;
	ret = 0;
	while (u) {
		//printf(&quot;%d\n&quot;, query(root[0], root[l - 1], 1, dfn, in[top[u]], in[u]));
		//printf(&quot;%d\n&quot;, query(root[0], root[r    ], 1, dfn, in[top[u]], in[u]));
		ret += query(root[l - 1], root[r], 1, dfn, in[top[u]], in[u]);
		ret %= mod;
		u = fa[top[u]];
	}
	return ret;
}

int main() {
	int n, q, x, l, r;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
	for (register int i = 2; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		fa[i] = ++x;
		*cedge = (edge) {i, g[x]};
		g[x] = cedge++;
	}
	d1(1);
	d2(1, 1);
	*cSegNode = (SegNode) {0, 0, cSegNode, cSegNode};
	root[0] = cSegNode;
	for (register int i = 1; i &lt;= n; ++i) {
		root[i] = root[i - 1];
		update(i);
		//printf(&quot;%d\n&quot;, root[i]-&gt;sum);
	}
	while (q--) {
		scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;x);
		printf(&quot;%d\n&quot;, sum(x + 1, l + 1, r + 1));
	}
	return 0;
}<pre><h2>Problem3668</h2><pre>#include &lt;cstdio&gt;
#define N 100000
char type[N];
int opt[N];
bool cal(int atk, const int &amp;pos, const int &amp;n) {
	for (int i = 0, t; i &lt; n; ++i) {
		t = (opt[i] &amp; pos) ? 1 : 0;
		if (type[i] == 'A')
		  atk &amp;= t;
		else if (type[i] == 'O')
		  atk |= t;
		else 
		  atk ^= t;
	}
	return atk;
}
int main() {
	int n, m;
	char ts[5];
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (register int i = 0; i &lt; n; ++i) {
		scanf(&quot;%s%d&quot;, ts, opt + i);
		type[i] = *ts;
	}
	int ans = 0, atk = 0;
	for (register int i = 1 &lt;&lt; 30; i; i &gt;&gt;= 1) {
		if (cal(0, i, n))
		  ans ^= i;
		else if (cal(1, i, n) &amp;&amp; (atk ^ i) &lt;= m) {
			ans ^= i;
			atk ^= i;
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MaxN = 50005, MaxM = 100005;
inline void gi(int &amp;a) {
	static char c;
	do c = getchar(); while (c &lt; '0');
	for (a = c - '0'; '-' &lt; (c = getchar()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
}
struct Link {
	int u, v, a, b;
} e[MaxM];
bool operator &lt; (const Link &amp;a, const Link &amp;b) {
	return a.a &lt; b.a;
}
struct edge {
	int to, v;
	edge *nxt;
} edge_mset[MaxM &lt;&lt; 1], *cedge = edge_mset, *g[MaxN];
inline void add_edge(int u, int v, int w) {
	*cedge = (edge) { v, w, g[u]};
	g[u] = cedge++;
}
int d[MaxN], heap[MaxN], pos[MaxN], top;
inline void swn(int &amp;a, int &amp;b) {
	swap(a, b);
	swap(pos[a], pos[b]);
}
inline void adj(int x) {
	for (int p = pos[x]; (p &gt;&gt; 1) &amp;&amp; d[heap[p]] &lt; d[heap[p &gt;&gt; 1]]; p &gt;&gt;= 1)
		swn(heap[p], heap[p &gt;&gt; 1]);
}
inline void push(int x) {
	heap[pos[x] = ++top] = x;
	adj(x);
}
inline void pop() {
	swn(heap[1], heap[top]);
	pos[heap[top]] = 0;
	heap[top--] = 0;
    for (int u = 1, p; u &lt; top; u = p) {
		p = d[heap[u &lt;&lt; 1]] &lt; d[heap[u &lt;&lt; 1 | 1]] ? (u &lt;&lt; 1) : (u &lt;&lt; 1 | 1);
		if (d[heap[p]] &lt; d[heap[u]])
			swn(heap[u], heap[p]);
		else
			break;
	}
}
inline void SPFA() {
	for (int u; top; ) {
		u = heap[1]; pop();
		for (edge *it = g[u]; it; it = it-&gt;nxt)
			if (max(d[u], it-&gt;v) &lt; d[it-&gt;to]) {
				d[it-&gt;to] = max(d[u], it-&gt;v);
				if (pos[it-&gt;to]) adj(it-&gt;to);
				else push(it-&gt;to);
			}
	}
}
int main() {
	int n, m, u, v, i, a, b, ans = 0x3f3f3f3f;
	gi(n), gi(m);
	for (i = 0; i &lt; m; ++i) gi(e[i].u), gi(e[i].v), gi(e[i].a), gi(e[i].b);
	sort(e, e + m);
	memset(d, 63, sizeof d);
	d[1] = 0;
	for (i = 0; i &lt; m; ++i) {
		u = e[i].u, v = e[i].v, a = e[i].a, b = e[i].b;
		add_edge(u, v, b);
		add_edge(v, u, b);
		if (d[u] &gt; d[v]) swap(u, v);
		if (max(d[u], b) &lt; d[v])
			d[v] = max(d[u], b), push(v);
		if (a ^ e[i + 1].a)
			SPFA();
		ans = min(ans, a + d[n]);
	}
	printf(&quot;%d\n&quot;, ans &lt; 0x3f3f3f3f ? ans : -1);
	return 0;
}<pre><h2>Problem3669</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int BUF = 1&lt;&lt;16|127;
inline char gc() {
    static char b[BUF], *s = b, *e = b;
    if (s == e) e = (s = b) + fread(b, 1, BUF, stdin);
    return (s == e) ? EOF : *s++;
}
 
inline void gi(int &amp;a) {
    static char c;
    while (c = gc(), c &lt; '0'); a = c - '0';
    while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

const int MaxN = 50005, MaxM = 100003;

struct edge {
	int u, v, a, b;
} e[MaxM];

bool operator &lt; (const edge &amp;a, const edge &amp;b) {
	return a.a &lt; b.a;
}

int f[MaxN];
int gf(int u) {
	return (f[u] ^ u) ? f[u] = gf(f[u]) : u;
}
struct LCA {
	struct node {
		int val;
		bool rev;
		node *fa, *ch[2], *mx;
	} node_mset[MaxN + MaxM], *nil;
	void Init(const int &amp;n) {
		nil = node_mset;
		*nil = (node) {0, false, nil, {nil, nil}, nil};
		for (int i = 1; i &lt;= n; ++i) node_mset[i] = *nil;
	}
	inline node *num(const int &amp;x) {
		return node_mset + x;
	}
	inline bool isrt(node *u) {
		return (u-&gt;fa-&gt;ch[0] != u) &amp;&amp; (u-&gt;fa-&gt;ch[1] != u);
	}
	inline bool which(node *u) {
		return u-&gt;fa-&gt;ch[1] == u;
	}
	void maintain(node *u) {
		u-&gt;mx = u;
		if (u-&gt;ch[0]-&gt;mx-&gt;val &gt; u-&gt;mx-&gt;val)
			u-&gt;mx = u-&gt;ch[0]-&gt;mx;
		if (u-&gt;ch[1]-&gt;mx-&gt;val &gt; u-&gt;mx-&gt;val)
			u-&gt;mx = u-&gt;ch[1]-&gt;mx;
	}
	void rot(node *u) {
		node *f = u-&gt;fa;
		int d = which(u);
		if ((f-&gt;ch[d] = u-&gt;ch[d ^ 1]) != nil)
			f-&gt;ch[d]-&gt;fa = f;
		u-&gt;ch[d ^ 1] = f;
		u-&gt;fa = f-&gt;fa;
		if (!isrt(f)) f-&gt;fa-&gt;ch[which(f)] = u;
		f-&gt;fa = u;
		maintain(f);
	}
	void pd(node *u) {
		if (!isrt(u)) pd(u-&gt;fa);
		if (u-&gt;rev) {
			u-&gt;ch[0]-&gt;rev ^= true;
			u-&gt;ch[1]-&gt;rev ^= true;
			swap(u-&gt;ch[0], u-&gt;ch[1]);
			u-&gt;rev = false;
		}
	}
	void splay(node *u) {
		pd(u);
		for (node *f; !isrt(u); rot(u))
			if (!isrt(f = u-&gt;fa)) rot(which(u) == which(f) ? f : u);
		maintain(u);
	}
	void access(node *x) {
		for (node *y = nil; x != nil; x = x-&gt;fa)
			splay(x), x-&gt;ch[1] = y, maintain(y = x);
	}
	void mrt(node *u) {
		access(u);
		splay(u);
		u-&gt;rev ^= 1;
	}
	void link(node *u, node *v) {
		mrt(u);
		u-&gt;fa = v;
		access(u);
	}
	void cut(node *u) {
		splay(u);
		u-&gt;ch[0]-&gt;fa = u-&gt;fa;
		u-&gt;ch[1]-&gt;fa = nil;
		u-&gt;fa = u-&gt;ch[0] = u-&gt;ch[1] = nil;
		u-&gt;mx = u;
	}
	void add_edge(int u, int v, int w) {
		node *_u = num(u), *_v = num(v), *_w = num(w);
		if (gf(u) == gf(v)) {
			mrt(_u);
			access(_v);
			splay(_v);
			if (_v-&gt;mx-&gt;val &lt; _w-&gt;val)
				return;
			cut(_v-&gt;mx);
			maintain(_v);
		} else
			f[gf(u)] = gf(v);
		link(_u, _w);
		link(_v, _w);  
	}
	int query(int u, int v) {
		node *_u = num(u), *_v = num(v);
		mrt(_u);
		access(_v);
		splay(_v);
		return _v-&gt;mx-&gt;val;
	}
} tree;

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, m, i, ans = 0x3f3f3f3f, idx;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 0; i &lt; m; ++i) gi(e[i].u), gi(e[i].v), gi(e[i].a), gi(e[i].b);
	sort(e, e + m);
	tree.Init(n + m);
	for (idx = 1; idx &lt;= n; ++idx) f[idx] = idx;
	for (i = 0; i &lt; m; ++i, ++idx) {
		tree.num(idx)-&gt;val = e[i].b;
		tree.add_edge(e[i].u, e[i].v, idx);
		//printf(&quot;%d %d %d %d\n&quot;, e[i].u, e[i].v, e[i].a, e[i].b);
		if (gf(1) == gf(n)) {
			ans = min(ans, e[i].a + tree.query(1, n));
			//printf(&quot;%d %d\n&quot;, i, tree.query(1, n));
		}
	}
	printf(&quot;%d\n&quot;, ans &lt; 0x3f3f3f3f ? ans : -1);
	return 0;
}<pre><h2>Problem3670</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MAXN = 1e6 + 3;
const int MOD = 1e9 + 7;

char s[MAXN];
int f[MAXN], g[MAXN];

int ract() {
  int n = strlen(s + 1);
  int ans = 1;
  g[0] = -1;
  for (int i = 2, j = 0, k = 0; i &lt;= n; i++) {
    while (j &amp;&amp; s[i] != s[j + 1])
      j = f[j];
    if (s[i] == s[j + 1])
      j++;
    f[i] = j;
    g[i] = g[j] + 1;
    while (k &amp;&amp; (s[i] != s[k + 1] || (k + 1) &gt; (i / 2)))
      k = f[k];
    if (s[i] == s[k + 1])
      k++;
    ans = ans * (g[k] + 2ll) % MOD;
  }
  return ans;
}

int main() {
  // freopen(&quot;in&quot;, &quot;r&quot;, stdin);
  int orz;
  scanf(&quot;%d\n&quot;, &amp;orz);
  while (orz--) {
    fgets(s + 1, MAXN, stdin);
    printf(&quot;%d\n&quot;, ract());
  }
  return 0;
}<pre><h2>Problem3670</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MAXN = 1e6 + 3;
const int MOD = 1e9 + 7;

char s[MAXN];
int f[MAXN], g[MAXN];

inline int ract() {
  int n = strlen(s + 1);
  int ans = 1;
  g[0] = -1;
  for (register int i = 2, j = 0, k = 0; i &lt;= n; i++) {
    while (j &amp;&amp; s[i] != s[j + 1])
      j = f[j];
    if (s[i] == s[j + 1])
      j++;
    f[i] = j;
    g[i] = g[j] + 1;
    while (k &amp;&amp; (s[i] != s[k + 1] || (k + 1) &gt; (i / 2)))
      k = f[k];
    if (s[i] == s[k + 1])
      k++;
    ans = ans * (g[k] + 2ll) % MOD;
  }
  return ans;
}

int main() {
  // freopen(&quot;in&quot;, &quot;r&quot;, stdin);
  int orz;
  scanf(&quot;%d\n&quot;, &amp;orz);
  while (orz--) {
    fgets(s + 1, MAXN, stdin);
    printf(&quot;%d\n&quot;, ract());
  }
  return 0;
}<pre><h2>Problem3671</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int BufferSize = 1 &lt;&lt; 16 | 1;
inline char gc() {
	static char buffer[BufferSize], *s(buffer), *t(buffer);
	if(s == t) {
		t = (s = buffer) + fread(buffer, 1, BufferSize, stdin);
		if (s == t) return EOF;
	}
	return *s++;
}
inline int gi() {
	static int a;
	static char c, f;
	f = 0;
	while (!isdigit(c = gc())) f |= c == '-';
	a = c ^ 48;
	while (isdigit(c = gc())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (c ^ 48);
	return f ? -a : a;
}

static const int maxn(5007), maxm(25000007);
int n, m, q, x[maxm], T[maxm], tl[maxn], tr[maxn], high[maxn], low[maxn];
int ans[maxn&lt;&lt;1], cnt;
short idy[maxm];
int main() {
	x[0] = gi(); int a = gi(), b = gi(), c = gi(), d = gi();
	n = gi(); m = gi(); q = gi();
	for(int i = 1; i &lt;= n * m; ++i) {
		x[i] = ((1ll * a * x[i-1] * x[i-1]) % d + (1ll * b * x[i-1]) % d + c) % d;
		T[i] = i;
	}
	for(int i = 1; i &lt;= n * m; ++i) swap(T[i], T[x[i] % i + 1]);
	while(q--) {
		int x = gi(), y = gi();
		if(x != y) swap(T[x], T[y]);
	}
	for(int i = 1; i &lt;= n * m; ++i)
		x[T[i]] = (i - 1) / m + 1, idy[T[i]] = (i - 1) % m + 1;
	for(int i = 1; i &lt;= m; ++i) tl[i] = 1, tr[i] = m, high[i] = n + 1, low[i] = 0;
	high[1] = low[1] = 1; high[m] = low[m] = n;
	for(int i = 1; i &lt;= n * m; ++i) if(i != T[1] &amp;&amp; i != T[n*m]) {
			int X = x[i], y = idy[i];
			if((y == 1 || low[tl[y]] &lt;= X) &amp;&amp; (y == m || X &lt;= high[tr[y]])) {
				ans[++cnt] = i;
				for(int j = tl[y]; j &lt; y; ++j) tr[j] = y;
				for(int j = y + 1; j &lt;= tr[y]; j++) tl[j] = y;
				low[y] = max(low[y], X);
				high[y] = min(high[y], X);
			}
		} else ans[++cnt] = i;

	for(int i = 1; i &lt; cnt; ++i) printf(&quot;%d &quot;, ans[i]);
	printf(&quot;%d\n&quot;, ans[cnt]);

	return 0;
}

<pre><h2>Problem3672</h2><pre>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int D = 1 &lt;&lt; 23;
char in[D], *I, *end;
#define getchar() (I == end ? I = in, end = in + fread(in, 1, D, stdin), *I++ : *I++)
template&lt;typename Tp&gt; void read(Tp &amp;x) {
    static char c, f;
    for(f = 0; !isdigit(c = getchar()); ) f |= (c == '-');
    for(x = 0; isdigit(c); c = getchar()) x = x * 10 + c - '0';
    if(f) x = -x;
}
char out[D], *O = out;
#define putchar(c) (*O++ = c)
template&lt;typename Tp&gt; void write(Tp x, char ch = 0) {
	static int stk[20], top;
	if(!x) putchar('0');
	else {
		if(x &lt; 0) putchar('-'), x = -x;
		for(; x; x /= 10) stk[top++] = x % 10;
		while(top) putchar(stk[--top] + '0');
	}
	if(ch) putchar(ch);
}

typedef long long LL;
const int N = 200000 + 10;

typedef long double ld;

struct Point {
	LL x, y;
	Point() {}
	Point(LL x, LL y) : x(x), y(y) {}
	Point operator - (const Point &amp;rhs) const {
		return Point(x - rhs.x, y - rhs.y);
	}
	bool operator &lt; (const Point &amp;rhs) const {
		if(x != rhs.x) return x &lt; rhs.x;
		return y &lt; rhs.y;
	}
	LL f(int k) const {
		return -k * x + y;
	}
	ld slope() const {
		return (ld) y / x;
	}
} pool[N * 20];
int tot;

ld Cross(const Point &amp;a, const Point &amp;b) {
	return (ld) a.x * b.y - (ld) a.y * b.x;
}

#define eps 1e-7

double pool_d[N * 20];

struct Data {
	Point *ch;
	double *sl;
	int n;
	Point *end() const {return ch + n;}
	void set() {ch = pool + tot, sl = pool_d + tot, n = 0;}
	void push_back(const Point &amp;p) {
		while(n &gt;= 2 &amp;&amp; Cross(p - ch[n-2], ch[n-1] - ch[n-2]) &gt; -eps) --n;
		ch[n++] = p;
	}
	void merge(const Data &amp;a, const Data &amp;b) {	
		set();
		for(Point *p = a.ch, *q = b.ch; p != a.end() || q != b.end(); ) {
			if(q == b.end() || (p != a.end() &amp;&amp; *p &lt; *q)) push_back(*p++);
			else push_back(*q++);
		}
		for(int i = 0; i+1 &lt; n; i++) {
			sl[i] = (ch[i+1] - ch[i]).slope();
		}
		tot += n;
	}
	LL query(LL k) const {
		int l = lower_bound(sl, sl + n - 1, k) - sl;
		return ch[l].f(k);
	}
	LL query2(LL k) const {
		int l = 0, r = n-1;
		while(r - l &gt;= 3) {
			int m1 = l + (r - l) / 3;
			int m2 = r - (r - l) / 3;
			if(ch[m1].f(k) &lt; ch[m2].f(k)) r = m2;
			else l = m1;
		}
		LL res = 1LL &lt;&lt; 62;
		for(int i = l; i &lt;= r; i++) res = min(res, ch[i].f(k));
		return res;
	}
} da[N * 4];

int last[20];

#define mid ((l + r) &gt;&gt; 1)
#define ls s &lt;&lt; 1, l, mid, dep + 1
#define rs s &lt;&lt; 1 | 1, mid + 1, r, dep + 1
void insert(int s, int l, int r, int dep, int pos, const Point &amp;p) {
	if(r == pos) {
		int &amp;lst = last[dep];
		if(lst) da[lst].merge(da[lst &lt;&lt; 1], da[lst &lt;&lt; 1 | 1]);
		lst = l == r ? 0 : s;
	}
	
	if(l == r) {
		da[s].set(), da[s].push_back(p), ++tot;
		return;
	}
	if(pos &lt;= mid) insert(ls, pos, p);
	else insert(rs, pos, p);

}

void erase(int s, int l, int r, int dep, int pos) {
	da[s].n = 0;
	if(l == r) return;
	if(last[dep] == s) last[dep] = 0;
	
	if(pos &lt;= mid) erase(ls, pos);
	else erase(rs, pos);
}

LL query(int s, int l, int r, int dep, int L, int R, LL k) {
	if(da[s].n &amp;&amp; (L &lt;= l &amp;&amp; r &lt;= R)) return da[s].query(k);
	LL res = 1LL &lt;&lt; 62;
	if(L &lt;= mid) res = min(res, query(ls, L, R, k));
	if(mid &lt; R) res = min(res, query(rs, L, R, k));
	return res;
}
vector&lt;int&gt; G[N];
LL dis[N], dp[N], low[N], q[N];
int n, p[N];

void dfs(int u, LL s[], int dep) {
	s[dep] = dis[u];
	insert(1, 0, n-1, 0, dep, Point(dis[u], dp[u]));
	for(unsigned i = 0; i &lt; G[u].size(); i++) {
		int v = G[u][i];
		int t = lower_bound(s, s + dep, dis[v] - low[v]) - s;
		dp[v] = query(1, 0, n-1, 0, t, dep, p[v]);
		dp[v] += dis[v] * p[v] + q[v];
		dfs(v, s, dep + 1);
	}
	erase(1, 0, n-1, 0, dep);
}

int main() {

	read(n); int fa; read(fa);
	for(int u = 2; u &lt;= n; u++) {
		read(fa), read(dis[u]); dis[u] += dis[fa];
		read(p[u]), read(q[u]), read(low[u]);
		G[fa].push_back(u);
	}
	
	dfs(1, new LL[N], 0);

	for(int i = 2; i &lt;= n; i++) {
		//write(dp[i], '\n');
		printf(&quot;%lld\n&quot;, dp[i]);
	}

	return /*fwrite(out, 1, O - out, stdout), */0;
}
<pre><h2>Problem3672</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define bus 1&lt;&lt;20
char B[bus],*S=B,*E=B;
#define gc() ((S==E&amp;&amp;(E=(S=B)+fread(B,1,bus,stdin),S==E))?EOF:*S++)
template&lt;class integer&gt;inline void gi(integer&amp;a) {
	static char c;
	for(;c=gc(),c&lt;'0';);a=c-'0';
	while(c=gc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
}
template&lt;class integer&gt;inline void oi(integer a) {
	static char st[20],*s; s=st+18;
	if(a==0) {puts(&quot;0&quot;);return;}
	if(a&lt;0) putchar('-'),a=-a;
	while(a)*s--=a%10+'0',a/=10;
	puts(s+1);
}
template&lt;class data&gt;inline void cmin(data&amp;a,const data&amp;b){if(b&lt;a)a=b;}
typedef long long ll;
typedef long double ld;
typedef double db;
#define N 200010
#define eps 1e-9
/**********************************/
struct vec {
	ll x,y;
	vec(){}
	vec(ll _x,ll _y) : x(_x),y(_y){}
	vec operator - (const vec&amp;a) const {return vec(x-a.x,y-a.y);}
	bool operator &lt; (const vec&amp;a) const {return (x^a.x)?x&lt;a.x:y&lt;a.y;}
	ld operator * (const vec&amp;a) const {return (ld)x*a.y-(ld)y*a.x;}
	ll f(int k) const {return -k*x+y;}
	ld slope() const {return (ld)y/x;}
}MSET[N*20];
db PSET[N*20];int stp;
class Data {
protected:
	vec*v;db*sl;int n;
public:
	vec*begin() const {return v;}
	vec*end() const {return v+n;}
	void set() {v=MSET+stp;sl=PSET+stp;n=0;}
	bool empty() const {return n==0;}
	void clr() {n=0;}
	void pb(const vec&amp;a) {
		while(1&lt;n&amp;&amp;(a-v[n-2])*(v[n-1]-v[n-2])&gt;-eps)--n;
		v[n++]=a;
	}
	void merge(const Data&amp;a,const Data&amp;b) {
		set();
		for(vec*p=a.begin(),*q=b.begin();p!=a.end()||q!=b.end();)
			if(q==b.end()||(p!=a.end()&amp;&amp;*p&lt;*q)) pb(*p++);
			else pb(*q++);
		for(int i=0;i+1&lt;n;++i)
			sl[i]=(v[i+1]-v[i]).slope();
		stp+=n;
	}
	ll query(const ll&amp;a) const {
		int l=lower_bound(sl,sl+n-1,a)-sl;
		return v[l].f(a);
	}
}da[N&lt;&lt;2];
int lst[20],n,p[N];
ll dis[N],dp[N],low[N],q[N],s[N];
struct edge{int to;edge*nt;}CD[N],*cd=CD,*hd[N];
inline void adde(const int&amp;a,const int&amp;b){cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++;}
void insert(const int&amp;pos,const vec&amp;v){
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		if(r==pos) {
			int &amp;lt=lst[dep];
			if(lt) da[lt].merge(da[lt&lt;&lt;1],da[lt&lt;&lt;1|1]);
			lt=(l==r)?0:u;
		}
		if(l==r) {da[u].set();da[u].pb(v);++stp;break;}
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
void erase(const int&amp;pos) {
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		da[u].clr();
		if(l==r) break;
		if(lst[dep]==u)lst[dep]=0;
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
ll query(int u,int l,int r,int dep,const int&amp;x,const int&amp;y,const ll&amp;k) {
	if(!da[u].empty()&amp;&amp;(x&lt;=l&amp;&amp;r&lt;=y)) return da[u].query(k);
	ll ret=1LL&lt;&lt;60; int md=l+r&gt;&gt;1;
	if(x&lt;=md) cmin(ret,query(u&lt;&lt;1,l,md,dep+1,x,y,k));
	if(md&lt; y) cmin(ret,query(u&lt;&lt;1|1,md+1,r,dep+1,x,y,k));
	return ret;
}
void dfs(int u,int dep) {
	s[dep]=dis[u];
	insert(dep,vec(dis[u],dp[u]));
	int v,t; edge*it;
	for(it=hd[u];it;it=it-&gt;nt) {
		v=it-&gt;to; t=lower_bound(s,s+dep,dis[v]-low[v])-s;
		dp[v]=query(1,0,n-1,0,t,dep,p[v]);
		dp[v]+=dis[v]*p[v]+q[v];
		dfs(v,dep+1);
	}
	erase(dep);
}
int main() {
	gi(n);
	int fa; gi(fa);
	for(int i=2;i&lt;=n;++i) {
		gi(fa),gi(dis[i]);
		gi(p[i]),gi(q[i]),gi(low[i]);
		adde(fa,i);
		dis[i]+=dis[fa];
	}
	dfs(1,0);
	for(int i=2;i&lt;=n;++i)oi(dp[i]);
	return 0;
}<pre><h2>Problem3672</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define bus 1&lt;&lt;17
char B[bus],*S=B,*E=B;
#define gc() ((S==E&amp;&amp;(E=(S=B)+fread(B,1,bus,stdin),S==E))?EOF:*S++)
template&lt;class integer&gt;inline void gi(integer&amp;a) {
	static char c;
	for(;c=gc(),c&lt;'0';);a=c-'0';
	while(c=gc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
}
template&lt;class integer&gt;inline void oi(integer a) {
	static char st[20],*s; s=st+18;
	if(a==0) {puts(&quot;0&quot;);return;}
	if(a&lt;0) putchar('-'),a=-a;
	while(a)*s--=a%10+'0',a/=10;
	puts(s+1);
}
template&lt;class data&gt;inline void cmin(data&amp;a,const data&amp;b){if(b&lt;a)a=b;}
typedef long long ll;
typedef long double ld;
typedef double db;
#define N 200010
#define eps 1e-9
/**********************************/
struct vec {
	ll x,y;
	vec(){}
	vec(ll _x,ll _y) : x(_x),y(_y){}
	vec operator - (const vec&amp;a) const {return vec(x-a.x,y-a.y);}
	bool operator &lt; (const vec&amp;a) const {return (x^a.x)?x&lt;a.x:y&lt;a.y;}
	ld operator * (const vec&amp;a) const {return (ld)x*a.y-(ld)y*a.x;}
	ll f(int k) const {return -k*x+y;}
	ld slope() const {return (ld)y/x;}
}MSET[N*20];
db PSET[N*20];int stp;
class Data {
protected:
	vec*v;db*sl;int n;
public:
	vec*begin() const {return v;}
	vec*end() const {return v+n;}
	void set() {v=MSET+stp;sl=PSET+stp;n=0;}
	bool empty() const {return n==0;}
	void clr() {n=0;}
	void pb(const vec&amp;a) {
		while(1&lt;n&amp;&amp;(a-v[n-2])*(v[n-1]-v[n-2])&gt;-eps)--n;
		v[n++]=a;
	}
	void merge(const Data&amp;a,const Data&amp;b) {
		set();
		for(vec*p=a.begin(),*q=b.begin();p!=a.end()||q!=b.end();)
			if(q==b.end()||(p!=a.end()&amp;&amp;*p&lt;*q)) pb(*p++);
			else pb(*q++);
		for(int i=0;i+1&lt;n;++i)
			sl[i]=(v[i+1]-v[i]).slope();
		stp+=n;
	}
	ll query(const ll&amp;a) const {
		int l=lower_bound(sl,sl+n-1,a)-sl;
		return v[l].f(a);
	}
}da[N&lt;&lt;2];
int lst[20],n,p[N];
ll dis[N],dp[N],low[N],q[N],s[N];
struct edge{int to;edge*nt;}CD[N],*cd=CD,*hd[N];
inline void adde(const int&amp;a,const int&amp;b){cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++;}
void insert(const int&amp;pos,const vec&amp;v){
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		if(r==pos) {
			int &amp;lt=lst[dep];
			if(lt) da[lt].merge(da[lt&lt;&lt;1],da[lt&lt;&lt;1|1]);
			lt=(l==r)?0:u;
		}
		if(l==r) {da[u].set();da[u].pb(v);++stp;break;}
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
void erase(const int&amp;pos) {
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		da[u].clr();
		if(l==r) break;
		if(lst[dep]==u)lst[dep]=0;
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
ll query(int u,int l,int r,int dep,const int&amp;x,const int&amp;y,const ll&amp;k) {
	if(!da[u].empty()&amp;&amp;(x&lt;=l&amp;&amp;r&lt;=y)) return da[u].query(k);
	ll ret=1LL&lt;&lt;60; int md=l+r&gt;&gt;1;
	if(x&lt;=md) cmin(ret,query(u&lt;&lt;1,l,md,dep+1,x,y,k));
	if(md&lt; y) cmin(ret,query(u&lt;&lt;1|1,md+1,r,dep+1,x,y,k));
	return ret;
}
void dfs(int u,int dep) {
	s[dep]=dis[u];
	insert(dep,vec(dis[u],dp[u]));
	int v,t; edge*it;
	for(it=hd[u];it;it=it-&gt;nt) {
		v=it-&gt;to; t=lower_bound(s,s+dep,dis[v]-low[v])-s;
		dp[v]=query(1,0,n-1,0,t,dep,p[v]);
		dp[v]+=dis[v]*p[v]+q[v];
		dfs(v,dep+1);
	}
	erase(dep);
}
int main() {
	gi(n);
	int fa; gi(fa);
	for(int i=2;i&lt;=n;++i) {
		gi(fa),gi(dis[i]);
		gi(p[i]),gi(q[i]),gi(low[i]);
		adde(fa,i);
		dis[i]+=dis[fa];
	}
	dfs(1,0);
	for(int i=2;i&lt;=n;++i)oi(dp[i]);
	return 0;
}
<pre><h2>Problem3672</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define bus 1&lt;&lt;16
char B[bus],*S=B,*E=B;
#define gc() ((S==E&amp;&amp;(E=(S=B)+fread(B,1,bus,stdin),S==E))?EOF:*S++)
template&lt;class integer&gt;inline void gi(integer&amp;a) {
	static char c;
	for(;c=gc(),c&lt;'0';);a=c-'0';
	while(c=gc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
}
template&lt;class integer&gt;inline void oi(integer a) {
	static char st[20],*s; s=st+18;
	if(a==0) {puts(&quot;0&quot;);return;}
	if(a&lt;0) putchar('-'),a=-a;
	while(a)*s--=a%10+'0',a/=10;
	puts(s+1);
}
template&lt;class data&gt;inline void cmin(data&amp;a,const data&amp;b){if(b&lt;a)a=b;}
typedef long long ll;
typedef long double ld;
typedef double db;
#define N 200010
#define eps 1e-9
/**********************************/
struct vec {
	ll x,y;
	vec(){}
	vec(ll _x,ll _y) : x(_x),y(_y){}
	vec operator - (const vec&amp;a) const {return vec(x-a.x,y-a.y);}
	bool operator &lt; (const vec&amp;a) const {return (x^a.x)?x&lt;a.x:y&lt;a.y;}
	ld operator * (const vec&amp;a) const {return (ld)x*a.y-(ld)y*a.x;}
	ll f(int k) const {return -k*x+y;}
	ld slope() const {return (ld)y/x;}
}MSET[N*20];
db PSET[N*20];int stp;
class Data {
protected:
	vec*v;db*sl;int n;
public:
	vec*begin() const {return v;}
	vec*end() const {return v+n;}
	void set() {v=MSET+stp;sl=PSET+stp;n=0;}
	bool empty() const {return n==0;}
	void clr() {n=0;}
	void pb(const vec&amp;a) {
		while(1&lt;n&amp;&amp;(a-v[n-2])*(v[n-1]-v[n-2])&gt;-eps)--n;
		v[n++]=a;
	}
	void merge(const Data&amp;a,const Data&amp;b) {
		set();
		for(vec*p=a.begin(),*q=b.begin();p!=a.end()||q!=b.end();)
			if(q==b.end()||(p!=a.end()&amp;&amp;*p&lt;*q)) pb(*p++);
			else pb(*q++);
		for(int i=0;i+1&lt;n;++i)
			sl[i]=(v[i+1]-v[i]).slope();
		stp+=n;
	}
	ll query(const ll&amp;a) const {
		int l=lower_bound(sl,sl+n-1,a)-sl;
		return v[l].f(a);
	}
}da[N&lt;&lt;2];
int lst[20],n,p[N];
ll dis[N],dp[N],low[N],q[N],s[N];
struct edge{int to;edge*nt;}CD[N],*cd=CD,*hd[N];
inline void adde(const int&amp;a,const int&amp;b){cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++;}
void insert(const int&amp;pos,const vec&amp;v){
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		if(r==pos) {
			int &amp;lt=lst[dep];
			if(lt) da[lt].merge(da[lt&lt;&lt;1],da[lt&lt;&lt;1|1]);
			lt=(l==r)?0:u;
		}
		if(l==r) {da[u].set();da[u].pb(v);++stp;break;}
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
void erase(const int&amp;pos) {
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		da[u].clr();
		if(l==r) break;
		if(lst[dep]==u)lst[dep]=0;
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
ll query(int u,int l,int r,int dep,const int&amp;x,const int&amp;y,const ll&amp;k) {
	if(!da[u].empty()&amp;&amp;(x&lt;=l&amp;&amp;r&lt;=y)) return da[u].query(k);
	ll ret=1LL&lt;&lt;60; int md=l+r&gt;&gt;1;
	if(x&lt;=md) cmin(ret,query(u&lt;&lt;1,l,md,dep+1,x,y,k));
	if(md&lt; y) cmin(ret,query(u&lt;&lt;1|1,md+1,r,dep+1,x,y,k));
	return ret;
}
void dfs(int u,int dep) {
	s[dep]=dis[u];
	insert(dep,vec(dis[u],dp[u]));
	int v,t; edge*it;
	for(it=hd[u];it;it=it-&gt;nt) {
		v=it-&gt;to; t=lower_bound(s,s+dep,dis[v]-low[v])-s;
		dp[v]=query(1,0,n-1,0,t,dep,p[v]);
		dp[v]+=dis[v]*p[v]+q[v];
		dfs(v,dep+1);
	}
	erase(dep);
}
int main() {
	gi(n);
	int fa; gi(fa);
	for(int i=2;i&lt;=n;++i) {
		gi(fa),gi(dis[i]);
		gi(p[i]),gi(q[i]),gi(low[i]);
		adde(fa,i);
		dis[i]+=dis[fa];
	}
	dfs(1,0);
	for(int i=2;i&lt;=n;++i)oi(dp[i]);
	return 0;
}
<pre><h2>Problem3672</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
template&lt;class integer&gt;inline void gi(integer&amp;a) {
	static char c;
	for(;c=getchar(),c&lt;'0';);a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
}
template&lt;class data&gt;inline void cmin(data&amp;a,data b){if(b&lt;a)a=b;}
typedef long long ll;
typedef long double ld;
typedef double db;
#define N 200010
#define eps 1e-9
/**********************************/
struct vec {
	ll x,y;
	vec(){}
	vec(ll _x,ll _y) : x(_x),y(_y){}
	vec operator - (const vec&amp;a) const {return vec(x-a.x,y-a.y);}
	bool operator &lt; (const vec&amp;a) const {return (x^a.x)?x&lt;a.x:y&lt;a.y;}
	ld operator * (const vec&amp;a) const {return (ld)x*a.y-(ld)y*a.x;}
	ll f(int k) const {return -k*x+y;}
	ld slope() const {return (ld)y/x;}
}MSET[N*20];
db PSET[N*20];int stp;
class Data {
protected:
	vec*v;db*sl;int n;
public:
	vec*begin() const {return v;}
	vec*end() const {return v+n;}
	void set() {v=MSET+stp;sl=PSET+stp;n=0;}
	bool empty() const {return n==0;}
	void clr() {n=0;}
	void pb(const vec&amp;a) {
		while(1&lt;n&amp;&amp;(a-v[n-2])*(v[n-1]-v[n-2])&gt;-eps)--n;
		v[n++]=a;
	}
	void merge(const Data&amp;a,const Data&amp;b) {
		set();
		for(vec*p=a.begin(),*q=b.begin();p!=a.end()||q!=b.end();)
			if(q==b.end()||(p!=a.end()&amp;&amp;*p&lt;*q)) pb(*p++);
			else pb(*q++);
		for(int i=0;i+1&lt;n;++i)
			sl[i]=(v[i+1]-v[i]).slope();
		stp+=n;
	}
	ll query(ll a) const {
		int l=lower_bound(sl,sl+n-1,a)-sl;
		return v[l].f(a);
	}
}da[N&lt;&lt;2];
int lst[20],n,p[N];
ll dis[N],dp[N],low[N],q[N],s[N];
struct edge{int to;edge*nt;}CD[N],*cd=CD,*hd[N];
inline void adde(int a,int b){cd-&gt;to=b,cd-&gt;nt=hd[a],hd[a]=cd++;}
void insert(int pos,const vec&amp;v){
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		if(r==pos) {
			int &amp;lt=lst[dep];
			if(lt) da[lt].merge(da[lt&lt;&lt;1],da[lt&lt;&lt;1|1]);
			lt=(l==r)?0:u;
		}
		if(l==r) {da[u].set();da[u].pb(v);++stp;break;}
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
void erase(int pos) {
	int u=1,l=0,r=n-1,md,dep=0;
	while(true) {
		da[u].clr();
		if(l==r) break;
		if(lst[dep]==u)lst[dep]=0;
		md=l+r&gt;&gt;1;
		(pos&lt;=md)?(u=u&lt;&lt;1,r=md):(u=u&lt;&lt;1|1,l=md+1);
		++dep;
	}
}
ll query(int u,int l,int r,int dep,int x,int y,ll k) {
	if(!da[u].empty()&amp;&amp;(x&lt;=l&amp;&amp;r&lt;=y)) return da[u].query(k);
	ll ret=1LL&lt;&lt;60; int md=l+r&gt;&gt;1;
	if(x&lt;=md) cmin(ret,query(u&lt;&lt;1,l,md,dep+1,x,y,k));
	if(md&lt; y) cmin(ret,query(u&lt;&lt;1|1,md+1,r,dep+1,x,y,k));
	return ret;
}
void dfs(int u,int dep) {
	s[dep]=dis[u];
	insert(dep,vec(dis[u],dp[u]));
	int v,t; edge*it;
	for(it=hd[u];it;it=it-&gt;nt) {
		v=it-&gt;to; t=lower_bound(s,s+dep,dis[v]-low[v])-s;
		dp[v]=query(1,0,n-1,0,t,dep,p[v]);
		dp[v]+=dis[v]*p[v]+q[v];
		dfs(v,dep+1);
	}
	erase(dep);
}
int main() {
	gi(n);
	int fa; gi(fa);
	for(int i=2;i&lt;=n;++i) {
		gi(fa),gi(dis[i]);
		gi(p[i]),gi(q[i]),gi(low[i]);
		adde(fa,i);
		dis[i]+=dis[fa];
	}
	dfs(1,0);
	for(int i=2;i&lt;=n;++i)printf(&quot;%lld\n&quot;,dp[i]);
	return 0;
}

<pre><h2>Problem3675</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

typedef unsigned int uint;

#define getchar_unlocked getchar

inline uint next_unsigned_int() {
	static char c;
	static uint a;
	do c = getchar_unlocked(); while (c &lt; 48);
	a = c ^ 48;
	while (47 &lt; (c = getchar_unlocked()))
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (c ^ 48);
	return a;
}

int main() {

#ifndef JUDGE_ONLINE
	//freopen(&quot;20&quot;, &quot;r&quot;, stdin);
#endif

	static const uint maxn(1e5 + 7);
	static uint n, k, pre[202][maxn];
	static unsigned long long pool[2][maxn], *f = pool[0], *g = pool[1], s[maxn], S;

	n = next_unsigned_int(), k = next_unsigned_int() + 1;

	s[0] = 0;
	for (register int i = 0; i &lt; n; ++i) 
	  s[i + 1] = s[i] + next_unsigned_int();
	S = s[n];


	for (register int i = 1; i &lt;= n; ++i)
	  f[i] = s[i] * (S - s[i]);

	for (register int j = 2; j &lt;= k; ++j) {
		static uint q[maxn], *l, *r;
		static long long y[maxn], range_sum;
		q[0] = 0;
		l = r = q;
		std::swap(f, g);
		for (register int i = 1; i &lt;= n; ++i) {
			while (l &lt; r &amp;&amp; y[l[1]] - y[*l] &gt;= (s[l[1]] - s[*l]) * s[i] * -2ll)
			  ++l;
			range_sum = s[i] - s[*l];
			f[i] = g[*l] + range_sum * (S - range_sum);
			pre[j][i] = *l;
			y[i] = g[i] - S * s[i] -s[i] * s[i];
			while (l &lt; r &amp;&amp; ((s[*r] ^ s[i]) ? (y[i] - y[*r]) : (y[i] &gt;= y[*r])) * (s[*r] - s[r[-1]]) &gt; (y[*r] - y[r[-1]]) * (s[i] - s[*r])) --r;
			if (s[*r] ^ s[i]) *(++r) = i;
			else if (l == r &amp;&amp; y[i] &gt;= y[*l]) *(++r) = i;
		}
	}

	printf(&quot;%llu\n&quot;, f[n] &gt;&gt; 1);

	//for (register int i = k, t = n; i ^ 1; --i)
	//  printf(&quot;%d &quot;, t = pre[i][t]);
	//puts(&quot;&quot;);
	return 0;
}

<pre><h2>Problem3676</h2><pre>#include &lt;cstdio&gt;
const int N = 300003;
char s[N];
int fa[N], l[N], cnd, ch[26][N], siz[N], last;
long long ans;
void ca(const long long &amp;t) {
	if (ans &lt; t) ans = t;
}
int main() {
	gets(s+1);
	//scanf(&quot;%s&quot;, s+1);
	fa[0] = fa[1] = 1;
	l[1] = -1;
	cnd = 1;
	for (int i = 1, v, k; s[i]; ++i) {
		int &amp;u = last;
		while (s[i - l[u] - 1] ^ s[i]) u = fa[u];
		if (!ch[s[i] - 'a'][u]) {
			v = ++cnd;
			k = fa[u];
			l[v] = l[u] + 2;
			while (s[i - l[k] - 1] ^ s[i]) k = fa[k];
			fa[v] = ch[s[i] - 'a'][k];
			ch[s[i] - 'a'][u] = v;
		}
		u = ch[s[i] - 'a'][u];
		++siz[u];
	}
	for (int i = cnd; i; --i) {
		siz[fa[i]] += siz[i];
		ca((long long)siz[i] * l[i]);
	}
	printf(&quot;%lld\n&quot;, ans);
}
<pre><h2>Problem3677</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

struct FI {
	char b[5 &lt;&lt; 20], *s;
	FI() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 20, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		while (*s &lt; 48) ++s;
		a = *s++ - 48;
		while (47 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
	}
} io;

const int MaxN = 200005, inf = 0x3f3f3f3f;

struct edge {
	int to, weight;
	edge *nxt;
} edge_mset[MaxN &lt;&lt; 1], *cedge = edge_mset, *g[MaxN];

inline void add_edge(int u, int v, int w) {
	*cedge = (edge) {v, w, g[u]};
	g[u] = cedge++;
}

inline void cmax(int &amp;a, const int &amp;b) {
    if (a &lt; b) a = b;
}

int dp[MaxN][2], mx[MaxN][2], cost[MaxN], fa[MaxN], ans;

inline void dfs(int u) {
    int v, temp;
    mx[u][0] = mx[u][1] = -inf;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if ((v = it-&gt;to) ^ fa[u]) {
            fa[v] = u;
            cost[v] = it-&gt;weight;
            dfs(v);
            temp = max(it-&gt;weight + dp[v][1], dp[v][0]);
            dp[u][0] += temp;
            temp = it-&gt;weight + dp[v][0] - temp;
            if (temp &gt; mx[u][0])
                mx[u][1] = mx[u][0], mx[u][0] = temp;
            else if (temp &gt; mx[u][1])
                mx[u][1] = temp;
        }
    dp[u][1] = dp[u][0] + mx[u][0];
}

inline void change_root(int u) {
    int m0 = mx[u][0], m1 = mx[u][1], dp0 = dp[u][0], dp1 = dp[u][1];
    if (u ^ 1) {
        int temp = max(cost[u] + dp[fa[u]][1], dp[fa[u]][0]);
        dp[u][0] += temp;
        temp = cost[u] + dp[fa[u]][0] - temp;
        if (temp &gt; mx[u][0])
            mx[u][1] = mx[u][0], mx[u][0] = temp;
        else if (temp &gt; mx[u][1])
            mx[u][1] = temp;
    }
    cmax(ans, dp[u][0]);
    int v, t0, t1, temp;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if ((v = it-&gt;to) ^ fa[u]) {
            t0 = dp[u][0], t1 = dp[u][1];
            temp = max(it-&gt;weight + dp[v][1], dp[v][0]);
            dp[u][0] -= temp;
            temp = it-&gt;weight + dp[v][0] - temp;
            dp[u][1] = dp[u][0] + (temp == mx[u][0] ? mx[u][1] : mx[u][0]);
            change_root(v);
            dp[u][0] = t0;
            dp[u][1] = t1;
        }
    mx[u][0] = m0;
    mx[u][1] = m1;
    dp[u][0] = dp0;
    dp[u][1] = dp1;
}

int main() {
	int n, u, v, w;
	io.gi(n);
	for (register int i = 1; i &lt; n; ++i) {
		io.gi(u), io.gi(v), io.gi(w);
		add_edge(u, v, w);
		add_edge(v, u, w);
	}
    dfs(1);
    change_root(1);
    printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem3677</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

struct FI {
	char b[5 &lt;&lt; 20], *s;
	FI() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 20, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		while (*s &lt; 48) ++s;
		a = *s++ - 48;
		while (47 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
	}
} io;

const int MaxN = 200005, inf = 0x3f3f3f3f;

struct edge {
	int to, weight;
	edge *nxt;
} edge_mset[MaxN &lt;&lt; 1], *cedge = edge_mset, *g[MaxN];

inline void add_edge(int u, int v, int w) {
	*cedge = (edge) {v, w, g[u]};
	g[u] = cedge++;
}

inline void cmax(int &amp;a, const int &amp;b) {
    if (a &lt; b) a = b;
}

int dp[MaxN][2], mx[MaxN][2], cost[MaxN], fa[MaxN], ans;

inline void dfs(int u) {
    int v, temp;
    mx[u][0] = mx[u][1] = -inf;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if ((v = it-&gt;to) ^ fa[u]) {
            fa[v] = u;
            cost[v] = it-&gt;weight;
            dfs(v);
            temp = max(it-&gt;weight + dp[v][1], dp[v][0]);
            dp[u][0] += temp;
            temp = it-&gt;weight + dp[v][0] - temp;
            if (temp &gt; mx[u][0])
                mx[u][1] = mx[u][0], mx[u][0] = temp;
            else if (temp &gt; mx[u][1])
                mx[u][1] = temp;
        }
    dp[u][1] = dp[u][0] + mx[u][0];
}

inline void change_root(int u) {
    int m0 = mx[u][0], m1 = mx[u][1], dp0 = dp[u][0], dp1 = dp[u][1];
    if (u ^ 1) {
        int temp = max(cost[u] + dp[fa[u]][1], dp[fa[u]][0]);
        dp[u][0] += temp;
        temp = cost[u] + dp[fa[u]][0] - temp;
        if (temp &gt; mx[u][0])
            mx[u][1] = mx[u][0], mx[u][0] = temp;
        else if (temp &gt; mx[u][1])
            mx[u][1] = temp;
    }
    cmax(ans, dp[u][0]);
    int v, t0, t1, temp;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if ((v = it-&gt;to) ^ fa[u]) {
            t0 = dp[u][0], t1 = dp[u][1];
            temp = max(it-&gt;weight + dp[v][1], dp[v][0]);
            dp[u][0] -= temp;
            temp = it-&gt;weight + dp[v][0] - temp;
            dp[u][1] = dp[u][0] + (temp == mx[u][0] ? mx[u][1] : mx[u][0]);
            change_root(v);
            dp[u][0] = t0;
            dp[u][1] = t1;
        }
    mx[u][0] = m0;
    mx[u][1] = m1;
    dp[u][0] = dp0;
    dp[u][1] = dp1;
}

int main() {
	int n, u, v, w;
	io.gi(n);
	for (register int i = 1; i &lt; n; ++i) {
		io.gi(u), io.gi(v), io.gi(w);
		add_edge(u, v, w);
		add_edge(v, u, w);
	}
    dfs(1);
    change_root(1);
    printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem3685</h2><pre>#include &lt;cstdio&gt;

inline char gc() {
	static char b[1 &lt;&lt; 16], *s = b, *e = b;
	if (s == e) e = (s = b) + fread(b, 1, 1 &lt;&lt; 16, stdin);
	return (s == e) ? EOF : *s++;
}

inline void gi(int &amp;a) {
	static int c;
	while (c = getchar(), c &lt; '0');
	a = c - '0';
	while (c = getchar(), '-' &lt; c)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

int c[2048699], seg;

inline void add(int x) {
	if (c[x += ::seg])
	  return;
	for (; x; x &gt;&gt;= 1)
	  ++c[x];
}
inline void del(int x) {
	if (!c[x += ::seg])
	  return;
	for (; x; x &gt;&gt;= 1)
	  --c[x];
}
inline int gmin() {
	if (!c[1])
	  return 0;
	static int x;
	for (x = 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1] ? x &lt;&lt; 1 : x &lt;&lt; 1 | 1));
	return x - ::seg;
}
inline int gmax() {
	if (!c[1])
	  return 0;
	static int x;
	for (x = 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1 | 1] ? x &lt;&lt; 1 | 1 : x &lt;&lt; 1));
	return x - ::seg;
}
inline int pred(int x) {
	for (x += ::seg; x ^ 1; x &gt;&gt;= 1)
	  if ((x &amp; 1) &amp;&amp; c[x &gt;&gt; 1] &gt; c[x]) break;
	if (x == 1) return 0;
	for (x ^= 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1 | 1] ? x &lt;&lt; 1 | 1 : x &lt;&lt; 1));
	return x - ::seg;
}
inline int succ(int x) {
	for (x += ::seg; x ^ 1; x &gt;&gt;= 1)
	  if ((~x &amp; 1) &amp;&amp; c[x &gt;&gt; 1] &gt; c[x]) break;
	if (x == 1) return 0;
	for (x ^= 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1] ? x &lt;&lt; 1 : x &lt;&lt; 1 | 1));
	return x - ::seg;
}

int main() {
	int n, m, opt, x;
	gi(n), gi(m);
	for (::seg = 1; ::seg &lt;= n; ::seg &lt;&lt;= 1);
	while (m--) {
		gi(opt);
		if ((opt ^ 3) &amp;&amp; (opt ^ 4))
		  gi(x), ++x;
		if (opt == 1) add(x);
		else if (opt == 2) del(x);
		else if (opt == 3) printf(&quot;%d\n&quot;, gmin() - 1);
		else if (opt == 4) printf(&quot;%d\n&quot;, gmax() - 1);
		else if (opt == 5) printf(&quot;%d\n&quot;, pred(x) - 1);
		else if (opt == 6) printf(&quot;%d\n&quot;, succ(x) - 1);
		else puts(c[x + ::seg] ? &quot;1&quot; : &quot;-1&quot;);
	}
}
<pre><h2>Problem3685</h2><pre>#include &lt;cstdio&gt;

inline char gc() {
	static char b[1 &lt;&lt; 16], *s = b, *e = b;
	if (s == e) e = (s = b) + fread(b, 1, 1 &lt;&lt; 16, stdin);
	return (s == e) ? EOF : *s++;
}

inline void gi(int &amp;a) {
	static int c;
	while (c = gc(), c &lt; '0');
	a = c - '0';
	while (c = gc(), '-' &lt; c)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

int c[2048699], seg;

inline void add(int x) {
	if (c[x += ::seg])
	  return;
	for (; x; x &gt;&gt;= 1)
	  ++c[x];
}
inline void del(int x) {
	if (!c[x += ::seg])
	  return;
	for (; x; x &gt;&gt;= 1)
	  --c[x];
}
inline int gmin() {
	if (!c[1])
	  return 0;
	static int x;
	for (x = 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1] ? x &lt;&lt; 1 : x &lt;&lt; 1 | 1));
	return x - ::seg;
}
inline int gmax() {
	if (!c[1])
	  return 0;
	static int x;
	for (x = 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1 | 1] ? x &lt;&lt; 1 | 1 : x &lt;&lt; 1));
	return x - ::seg;
}
inline int pred(int x) {
	for (x += ::seg; x ^ 1; x &gt;&gt;= 1)
	  if ((x &amp; 1) &amp;&amp; c[x &gt;&gt; 1] &gt; c[x]) break;
	if (x == 1) return 0;
	for (x ^= 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1 | 1] ? x &lt;&lt; 1 | 1 : x &lt;&lt; 1));
	return x - ::seg;
}
inline int succ(int x) {
	for (x += ::seg; x ^ 1; x &gt;&gt;= 1)
	  if ((~x &amp; 1) &amp;&amp; c[x &gt;&gt; 1] &gt; c[x]) break;
	if (x == 1) return 0;
	for (x ^= 1; x &lt;= ::seg; x = (c[x &lt;&lt; 1] ? x &lt;&lt; 1 : x &lt;&lt; 1 | 1));
	return x - ::seg;
}

int main() {
	int n, m, opt, x;
	gi(n), gi(m);
	for (::seg = 1; ::seg &lt;= n; ::seg &lt;&lt;= 1);
	while (m--) {
		gi(opt);
		if ((opt ^ 3) &amp;&amp; (opt ^ 4))
		  gi(x), ++x;
		if (opt == 1) add(x);
		else if (opt == 2) del(x);
		else if (opt == 3) printf(&quot;%d\n&quot;, gmin() - 1);
		else if (opt == 4) printf(&quot;%d\n&quot;, gmax() - 1);
		else if (opt == 5) printf(&quot;%d\n&quot;, pred(x) - 1);
		else if (opt == 6) printf(&quot;%d\n&quot;, succ(x) - 1);
		else puts(c[x + ::seg] ? &quot;1&quot; : &quot;-1&quot;);
	}
}<pre><h2>Problem3720</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 30003
#define inf 2147483647
//#define inf 20
struct edge {
	int t;
	edge *n;
} me[N * 3], *g[N &lt;&lt; 1], *ce = me;
#define adde(a, b) (*ce = (edge){b, g[a]}, g[a] = ce++)
typedef int arrN2[N &lt;&lt; 1];
arrN2 w, pre, in, ou, anc, fa, stk, dq, flag;
int n, dfn, _flag, totnode, *stktp;
struct node {
	int sum;
	node *ls, *rs;
} mset[2000001], *rt[N &lt;&lt; 1], *cnode;
void Insert(node *x, node * &amp;y, int l, int r, const int &amp;val) {
	*(y = ++cnode) = *x;
	++y-&gt;sum;
	if (l &gt;= r)
	  return;
	int m = ((long long)l + r) &gt;&gt; 1;
	if (val &lt;= m)
	  Insert(x-&gt;ls, y-&gt;ls, l, m, val);
	else 
	  Insert(x-&gt;rs, y-&gt;rs, m + 1, r, val);
}
int Query(node *x, node *y, const int &amp;p) {
	static int l, r, m, ret;
	for (l = 0, r = inf, ret = 0; (l ^ r) &amp;&amp; (x-&gt;sum ^ y-&gt;sum);) {
		m = ((long long)l + r) &gt;&gt; 1;
		if (p &lt;= m) {
			ret += y-&gt;rs-&gt;sum - x-&gt;rs-&gt;sum;
			x = x-&gt;ls;
			y = y-&gt;ls;
			r = m;
		} else
		  x = x-&gt;rs, y = y-&gt;rs, l = m + 1;
	}
	return ret;
}
void dfs(int u) {
	dq[in[u] = ++dfn] = u;
	for (edge *it = g[u]; it; it = it-&gt;n)
	  if (it-&gt;t ^ fa[u]) {
		  fa[it-&gt;t] = u;
		  dfs(it-&gt;t);
	  }
	ou[u] = dfn;
}
void rebuild() {
	++_flag;
	n = totnode;
	cnode = mset;
	stktp = stk;
	dfn = 0;
	dfs(1);
	for (int i = 1; i &lt;= n; ++i) {
		Insert(rt[i - 1], rt[i], 0, inf, w[dq[i]]);
		anc[i] = in[i];
	}
}
void dfsquery(int u, const int &amp;x, int &amp;v) {
	if (x &lt; w[u])
	  ++v;
	for (edge *it = g[u]; it; it = it-&gt;n)
	  dfsquery(it-&gt;t, x, v);
}
int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	//freopen(&quot;t.out&quot;, &quot;w&quot;, stdout);
	int m, u, v, i, Count = 0, lastans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		adde(u, v);
		adde(v, u);
	}
	for (i = 1; i &lt;= n; ++i) 
	  scanf(&quot;%d&quot;, w + i);
	totnode = n;
	*rt = mset;
	**rt = (node){0, *rt, *rt};
	rebuild();
	scanf(&quot;%d&quot;, &amp;m);
	while (m--) {
		scanf(&quot;%d%d%d&quot;, &amp;i, &amp;u, &amp;v);
		//printf(&quot;%d\n&quot;, m);
		u ^= lastans;
		v ^= lastans;
		if (i) {
			if (i &amp; 1) {
				if (u &lt;= n &amp;&amp; (flag[u] ^ _flag)) {
					flag[u] = _flag;
					pre[u] = w[u];
					*stktp++ = u;
				}
				w[u] = v;
			} else {
				++totnode;
				adde(u, totnode);
				anc[totnode] = anc[u];
				w[totnode] = v;
			}
			if (++Count &gt; 3000) {
			  rebuild();
			  Count = 0;
			}
		} else {
			lastans = 0;
			if (u &lt;= n) {
				lastans = Query(rt[in[u] - 1], rt[ou[u]], v);
				for (int *it = stk; it &lt; stktp; ++it) 
				  if (in[u] &lt;= in[*it] &amp;&amp; ou[u] &gt;= in[*it]){
					  if (pre[*it] &gt; v)
						--lastans;
					  if (w[*it] &gt; v)
						++lastans;
				  }
				for (i = n + 1; i &lt;= totnode; ++i)
				  if (w[i] &gt; v &amp;&amp; in[u] &lt;= anc[i] &amp;&amp; ou[u] &gt;= anc[i])
					++lastans;
			} else 
			  dfsquery(u, v, lastans);
			printf(&quot;%d\n&quot;, lastans);
		}
	}
	return 0;
}<pre><h2>Problem3729</h2><pre>#include &lt;cstdio&gt;

const int maxn(200010);

inline int min(const int &amp;a, const int &amp;b) {
    return a &lt; b ? a : b;
}

inline int gi() {
    static int a;
    static char c;
    do c = getchar_unlocked(); while (c &lt; 48);
    a = c - 48;
    while (47 &lt; (c = getchar_unlocked()))
        a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48;
    return a;
}

struct node {
    int val, s0, s1, dep, mindep;
    node *ch[2], *fa;
    inline void maintain() {
        s0 = ch[0]-&gt;s0 ^ ch[1]-&gt;s0;
        s1 = ch[0]-&gt;s1 ^ ch[1]-&gt;s1;
        if (dep &amp; 1)
            s1 ^= val;
        else
            s0 ^= val;
        mindep = min(dep, min(ch[0]-&gt;mindep, ch[1]-&gt;mindep));
    }
    inline bool which() const {
        return this == fa-&gt;ch[1];
    }
} *f[maxn], *nil, *root;

inline node *newnode(int dep = maxn, int val = 0) {
    static node node_mset[maxn], *cnode = node_mset;
    *cnode = (node) {val, 0, 0, dep, dep, {nil, nil}, nil};
    return cnode++;
}

inline void rot(node *u) {
    static int d;
    static node *f;
    f = u-&gt;fa;
    d = u-&gt;which();
    if ((f-&gt;ch[d] = u-&gt;ch[d ^ 1]) != nil)
        f-&gt;ch[d]-&gt;fa = f;
    if ((u-&gt;fa = f-&gt;fa) != nil)
        f-&gt;fa-&gt;ch[f-&gt;which()] = u;
    u-&gt;ch[d ^ 1] = f;
    f-&gt;fa = u;
    f-&gt;maintain();
}

inline void splay(node *u, node *tag) {
    for (static node *f; (f = u-&gt;fa) != tag; rot(u))
        if (f-&gt;fa != tag) rot(u-&gt;which() == f-&gt;which() ? f : u);
    u-&gt;maintain();
    if (tag == nil) root = u;
}

inline node *find_node(node *x, int y) {
    while (true) {
        if (x-&gt;ch[0]-&gt;mindep &lt;= y)
            x = x-&gt;ch[0];
        else if (x-&gt;dep &lt;= y)
            return x;
        else
            x = x-&gt;ch[1];
    }
}

struct edge {
    int to;
    edge *nxt;
} *g[maxn];

inline void add_edge(int u, int v) {
    static edge edge_mset[maxn * 2], *cedge = edge_mset;
    *cedge = (edge) {v, g[u]};
    g[u] = cedge++;
}

int dep[maxn], dq[maxn], dfn, sg[maxn];

void dfs(int u) {
    dq[++dfn] = u;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if (!dep[it-&gt;to]) {
            dep[it-&gt;to] = dep[u] + 1;
            dfs(it-&gt;to);
        }
}

node *build(int l, int r) {
    if (l &gt; r) return nil;
    int mid = (l + r) &gt;&gt; 1;
    node *u = newnode(dep[dq[mid]], sg[dq[mid]]);
    f[dq[mid]] = u;
    if ((u-&gt;ch[0] = build(l, mid - 1)) != nil)
        u-&gt;ch[0]-&gt;fa = u;
    if ((u-&gt;ch[1] = build(mid + 1, r)) != nil)
        u-&gt;ch[1]-&gt;fa = u;
    u-&gt;maintain();
    return u;
}

inline void Print_Tree();

inline bool win(int u) {
    node *l = f[u], *r;
    Print_Tree();
    splay(l, nil);
    Print_Tree();
    r = find_node(l-&gt;ch[1], dep[u]);
    splay(r, l);
    Print_Tree();
    if (dep[u] &amp; 1)
        return r-&gt;ch[0]-&gt;s0;
    else
        return r-&gt;ch[0]-&gt;s1;
}

inline void modify(int u, int x) {
    splay(f[u], nil);
    root-&gt;val = x;
    root-&gt;maintain();
}

inline void add_son(int u, int v, int x) {
    dep[v] = dep[u] + 1;
    sg[v] = x;
    node *l = f[u], *r, *n;
    splay(l, nil);
    r = find_node(l-&gt;ch[1], dep[u]);
    splay(r, l);
    f[v] = n = newnode(dep[v], sg[v]);
    n-&gt;ch[0] = r-&gt;ch[0];
    n-&gt;ch[0]-&gt;fa = n;
    n-&gt;fa = r;
    r-&gt;ch[0] = n;
    n-&gt;maintain();
    r-&gt;maintain();
    l-&gt;maintain();
}

void Print_Tree(node *u) {
    if (u-&gt;ch[0] != nil)
        Print_Tree(u-&gt;ch[0]);
    printf(&quot;%d &quot;, u-&gt;val);
    if (u-&gt;ch[1] != nil)
        Print_Tree(u-&gt;ch[1]);
}

inline void Print_Tree() {
    //Print_Tree(root);
    //puts(&quot;&quot;);
}

int main() {
    int n = gi(), L = gi() + 1;
    for (register int i = 1; i &lt;= n; ++i)
        sg[i] = gi() % L;
    for (register int i = 1, a, b; i &lt; n; ++i)
        add_edge(a = gi(), b = gi()), add_edge(b, a);
    dep[1] = dep[0] = 1;
    dfs(1);
    nil = newnode();
    nil-&gt;ch[0] = nil-&gt;ch[1] = nil-&gt;fa = nil;
    root = build(1, n + 1);
    for (int m = gi(), opt, a, b, c, cnt = 0; m; --m) {
        opt = gi();
        if (opt == 1) {
            a = gi() ^ cnt;
            if (win(a))
                puts(&quot;MeiZ&quot;), ++cnt;
            else
                puts(&quot;GTY&quot;);
        } else if (opt == 2) {
            a = gi() ^ cnt, b = gi() ^ cnt;
            modify(a, b % L);
        } else {
            a = gi() ^ cnt, b = gi() ^ cnt, c = gi() ^ cnt;
            add_son(a, b, c % L);
        }
    }
    return 0;
}
<pre><h2>Problem3731</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MaxN = 1e5 + 5, Block_Cnt = 2e5 + 5;
namespace FastIO {
	const int buffersize = (1 &lt;&lt; 16) | (0x3f);
	int a;
	char b[buffersize], *s = b, *e = b, c;
	inline char gc() {
		if (s == e) {
			s = b;
			e = b + fread(b, 1, buffersize, stdin);
			if (s == e)
			  return EOF;
		}
		return *s++;
	}
	inline int gi() {
		do c = gc(); while (c &lt; 48);
		for (a = c - 48; 47 &lt; (c = gc()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48);
		return a;
	}
}
struct Block {
	vector&lt;int&gt;a;
#define all a.begin(), a.end()
	void insert(const int &amp;x) {
		a.insert(lower_bound(all, x + 1), x);
	}
	void erase(const int &amp;x) {
		a.erase(lower_bound(all, x));
	}
	void modify(const int &amp;pre, const int &amp;cur) {
		erase(pre);
		insert(cur);
	}
	int query(const int &amp;x) const {
		int t = upper_bound(all, x) - a.begin() + 1;
		return a.size() - t + 1;
	}
	int size() const {
		return a.size();
	}
}block[Block_Cnt];
struct edge {
	int to;
	bool ban;
	edge *nxt;
} edge_mset[MaxN * 3], *head[MaxN &lt;&lt; 1], *block_head[Block_Cnt], *from[MaxN &lt;&lt; 1], *block_from[Block_Cnt], *cedge = edge_mset;
#define over(u) for (edge *it = u; it; it = it-&gt;nxt)
inline void add_edge(edge **_g, int u, int v) {
	*cedge = (edge) {v, false, _g[u]};
	_g[u] = cedge;
	if (_g == head)
	  from[v] = cedge++;
	else
	  block_from[v] = cedge++;
}
int n, m, cnt, block_size, ans;
typedef int arr[MaxN &lt;&lt; 1];
arr fa, a, belong;
void dfs(int u) {
	if (!fa[u] || block[belong[fa[u]]].size() &gt;= block_size) {
		belong[u] = ++cnt;
		add_edge(block_head, belong[fa[u]], cnt);
	} else
	  belong[u] = belong[fa[u]];
	block[belong[u]].insert(a[u]);
	over(head[u])
		if (it-&gt;to ^ fa[u]) {
			fa[it-&gt;to] = u;
			from[it-&gt;to] = it;
			dfs(it-&gt;to);
		} else
		  it-&gt;ban = true;
}
void inblock(int x, const int &amp;y) {
	ans += block[x].query(y);
	over(block_head[x])
		if (!it-&gt;ban)
		  inblock(it-&gt;to, y);
}
void getans(int x, const int &amp;y) {
	if (a[x] &gt; y) ++ans;
	over(head[x]) if (!it-&gt;ban) {
		if (belong[it-&gt;to] ^ belong[x])
		  inblock(belong[it-&gt;to], y);
		else
		  getans(it-&gt;to, y);
	} 
}
void split(int u, bool flag, int nb, int z, int pb) {
	flag |= u == z;
	if (flag) {
		block[pb].erase(a[u]);
		block[belong[u] = nb].insert(a[u]);
	} 
	over(head[u]) if (!it-&gt;ban) {
		if (belong[it-&gt;to] == pb)
		  split(it-&gt;to, flag, nb, z, pb);
		else if (flag) {
			block_from[belong[it-&gt;to]]-&gt;ban = true;
			add_edge(block_head, nb, belong[it-&gt;to]);
		}
	}
}
int main() {
	int i, x, y;
	n = FastIO::gi();
	for (i = 1; i &lt; n; ++i) {
		x = FastIO::gi();
		y = FastIO::gi();
		add_edge(head, x, y);
		add_edge(head, y, x);
	}
	for (i = 1; i &lt;= n; ++i)
	  a[i] = FastIO::gi();
	block_size = (int)(sqrt(n * log2(n)) + 1e-7);
	dfs(1);
	for (m = FastIO::gi(); m; --m) {
		i = FastIO::gi();
		x = FastIO::gi() ^ ans;
		if (i ^ 3) y = FastIO::gi() ^ ans;
		if (!i) {
			ans = 0;
			getans(x, y);
			printf(&quot;%d\n&quot;, ans);
		} else if (i &lt; 2) {
			block[belong[x]].modify(a[x], y);
			a[x] = y;
		} else if (i &lt; 3) {
			++n;
			a[n] = y;
			fa[n] = x;
			add_edge(head, x, n);
			if (block[belong[x]].size() &gt;= block_size) {
				belong[n] = ++cnt;
				add_edge(block_head, belong[x], cnt);
			} else 
			  belong[n] = belong[x];
			block[belong[n]].insert(y);
		} else {
			if (belong[x] ^ belong[fa[x]])
			  block_from[belong[x]]-&gt;ban = true;
			else {
				for (y = x; fa[y] &amp;&amp; belong[fa[y]] == belong[x]; y = fa[y]);
				split(y, 0, ++cnt, x, belong[x]);
			}
			from[x]-&gt;ban = true;
			fa[x] = 0;
		}
	}
	return 0;
}<pre><h2>Problem3731</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;utility&gt;
#include &lt;bitset&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
using namespace std;
typedef long long ll;
typedef double D;
typedef pair&lt;int,int&gt; pr;
const int infi=2147483647;
const int mod=1000000007;
const D eps=1e-6;
const int N=500010;
const int M=100010;
const int Q=200010;
const int size=6000;
struct Treap* null;
struct Treap{
    Treap *fa,*son[2];
    int key,data,sz;
    void newnode(int x) {
        data=x; key=rand(); sz=1;
        fa=son[0]=son[1]=null;
    }
    void updata() { sz=son[0]-&gt;sz+son[1]-&gt;sz+1;}
    void rotate() {
        Treap *x=this,*y=x-&gt;fa,*z=y-&gt;fa;
        int w=(y-&gt;son[0]==x);
        if (z!=null) z-&gt;son[z-&gt;son[1]==y]=x;
        x-&gt;fa=y-&gt;fa; y-&gt;fa=x;
        if (x-&gt;son[w]!=null) x-&gt;son[w]-&gt;fa=y;
        y-&gt;son[w^1]=x-&gt;son[w]; x-&gt;son[w]=y; 
        y-&gt;updata(); x-&gt;updata();
    }
    void insert(Treap *&amp;y) {
        Treap *x=this; x-&gt;sz++;
        if (y-&gt;data&gt;x-&gt;data) {
            if (x-&gt;son[1]!=null) x-&gt;son[1]-&gt;insert(y);
            else x-&gt;son[1]=y,y-&gt;fa=x;
            if (x-&gt;son[1]-&gt;key&lt;x-&gt;key) x-&gt;son[1]-&gt;rotate();
        } else {
            if (x-&gt;son[0]!=null) x-&gt;son[0]-&gt;insert(y);
            else x-&gt;son[0]=y,y-&gt;fa=x;
            if (x-&gt;son[0]-&gt;key&lt;x-&gt;key) x-&gt;son[0]-&gt;rotate();
        } x-&gt;updata();
    }
    Treap* merge(Treap *fat,Treap *x,Treap *y) {
        if (x==null&amp;&amp;y==null) return null;
        if (x==null) {
            y-&gt;fa=fat;
            return y;
        }
        if (y==null) {
            x-&gt;fa=fat;
            return x;
        }
        if (x-&gt;key&lt;y-&gt;key) {
            x-&gt;son[1]=merge(x,x-&gt;son[1],y);
            x-&gt;fa=fat; x-&gt;updata();
            return x;
        } else {
            y-&gt;son[0]=merge(y,x,y-&gt;son[0]);
            y-&gt;fa=fat; y-&gt;updata();
            return y;
        }
    }
    void clear() {
        if (this==null) return;
        else this-&gt;updata();
        if (this-&gt;fa!=null) this-&gt;fa-&gt;clear();
    }
    void del() {
        Treap *x=this,*y=merge(x-&gt;fa,x-&gt;son[0],x-&gt;son[1]);
        x-&gt;fa-&gt;son[x-&gt;fa-&gt;son[1]==x]=y;
        x-&gt;fa-&gt;clear(); x-&gt;sz=1;
        x-&gt;fa=x-&gt;son[0]=x-&gt;son[1]=null;
    }
    int ask(int y) {
        if (this==null) return 0;
        Treap *x=this; int ans=0;
        if (x-&gt;data&gt;y) ans++;
        if (y&gt;=x-&gt;data) ans+=x-&gt;son[1]-&gt;ask(y);
        else {
            ans+=x-&gt;son[1]-&gt;sz;
            ans+=x-&gt;son[0]-&gt;ask(y);
        } return ans;
    }
    Treap* findroot() {
        if (this-&gt;fa==null) return this;
        else return this-&gt;fa-&gt;findroot();
    }
};
Treap pool[Q];
Treap* v[Q];
Treap* total;
int n,m,w[Q],lastans;
int pos[Q],sz[Q],fa[Q];
int g[Q],to[N],nxt[N],tot;
int G[Q],TO[N],NXT[N],TOT;
void read(int &amp;a) {
    char ch; while (!((ch=getchar())&gt;='0'&amp;&amp;ch&lt;='9'));
    a=ch-'0'; while ((ch=getchar())&gt;='0'&amp;&amp;ch&lt;='9') (a*=10)+=ch-'0';
}
void addedge(int x,int y) {
    to[++tot]=y; nxt[tot]=g[x]; g[x]=tot;
    to[++tot]=x; nxt[tot]=g[y]; g[y]=tot;
}
void ADDEDGE(int x,int y) {
    TO[++TOT]=y; NXT[TOT]=G[x]; G[x]=TOT;
}
void init() {
    total=pool; null=total++;
    null-&gt;fa=null-&gt;son[0]=null-&gt;son[1]=null;
    null-&gt;key=null-&gt;data=null-&gt;sz=0;
}
void dfs(int x,int fat) {
    int cur=pos[x],k; fa[x]=fat;
    for (k=g[x];k;k=nxt[k]) if (to[k]!=fat) {
        if (sz[cur]+1&lt;=size) {
            sz[pos[to[k]]=cur]++;
            Treap *t=v[cur]-&gt;findroot();
            t-&gt;insert(v[to[k]]);
        } else ADDEDGE(cur,pos[to[k]]);
        dfs(to[k],x);
    }
}
int query(int x,int y) {
    int k,ans=0; Treap *t;
    if (pos[x]==x) {
        t=v[x]-&gt;findroot();
        ans+=t-&gt;ask(y);
        for (k=G[x];k;k=NXT[k]) ans+=query(TO[k],y);
    } else {
        if (w[x]&gt;y) ans++;
        for (k=g[x];k;k=nxt[k]) if (to[k]!=fa[x]&amp;&amp;fa[to[k]]==x) ans+=query(to[k],y);
    } return ans;
}
void change(int x,int y) {
    Treap *t; w[x]=y;
    t=v[x]-&gt;findroot();
    if (t==v[x]) {
        if (t-&gt;son[0]!=null) t=t-&gt;son[0];
        else if (t-&gt;son[1]!=null) t=t-&gt;son[1];
        else {
            v[x]-&gt;data=y;
            return;
        }
    }
    v[x]-&gt;del();
    t=t-&gt;findroot();
    v[x]-&gt;data=y;
    t-&gt;insert(v[x]);
}
void add(int fat,int x,int y) {
    v[x]=total++; fa[x]=fat;
    addedge(fat,x); w[x]=y;
    v[x]-&gt;newnode(y);
    if (sz[fat]+1&lt;=size) {
        sz[pos[x]=pos[fat]]++;
        Treap *t=v[pos[fat]]-&gt;findroot();
        t-&gt;insert(v[x]);
    } else {
        sz[pos[x]=x]++;
        ADDEDGE(pos[fat],pos[x]);
    }
}
void delink(int X,int Y) {
    int K;
    if (TO[G[X]]==Y) G[X]=NXT[G[X]];
    else for (K=G[X];K;K=NXT[K]) {
        if (TO[NXT[K]]==Y) {
            NXT[K]=NXT[NXT[K]];
            return;
        }
    }
}
void cut(int x,int loc) {
    int k;
    if (pos[x]==x) delink(pos[fa[x]],x);
    else {
        v[x]-&gt;del(); sz[pos[x]]--;
        for (k=g[x];k;k=nxt[k]) {
            if (pos[to[k]]==pos[x]&amp;&amp;to[k]!=fa[x]&amp;&amp;fa[to[k]]==x) cut(to[k],loc);
            else if (to[k]!=fa[x]&amp;&amp;fa[to[k]]==x&amp;&amp;pos[to[k]]==to[k]) {
                delink(pos[loc],pos[to[k]]);
                ADDEDGE(loc,pos[to[k]]);
            }
        } sz[pos[x]=loc]++;
        if (pos[x]!=x) {
            Treap *t=v[loc]-&gt;findroot();
            t-&gt;insert(v[x]);
        }
    }
}
int main() {
    int i,x,y,k; init();
    for (read(n),i=1;i&lt;n;i++) {
        read(x); read(y);
        addedge(x,y);
    }
    for (i=1;i&lt;=n;i++) {
        read(w[i]); v[i]=total++;
        v[i]-&gt;newnode(w[i]);
        pos[i]=i;
    } dfs(1,0);
    for (read(m),i=1;i&lt;=m;i++) {
        read(k); read(x); x^=lastans;
        if (k!=3) read(y),y^=lastans;
        if (k==0) printf(&quot;%d\n&quot;,lastans=query(x,y));
        else if (k==1) change(x,y);
        else if (k==2) add(x,++n,y);
        else if (k==3) if (fa[x]) cut(x,x),fa[x]=0;
    }
    return 0;
}<pre><h2>Problem3743</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define MaxN 500003

struct edge {
	int from, to, cost;
	edge *nxt;
	edge() {}
	edge(int from, int to, int cost, edge *nxt) :
		from(from), to(to), cost(cost), nxt(nxt) {}
} edge_mset[MaxN &lt;&lt; 1], *curten_edge = edge_mset, *g[MaxN], *from[MaxN];

inline void add_edge(int a, int b, int c) {
	*curten_edge = edge(a, b, c, g[a]);
	g[a] = curten_edge++;
}

bool vis[MaxN], mark[MaxN];
int que[MaxN &lt;&lt; 1], home[MaxN];
long long d[MaxN], d0[MaxN], d1[MaxN];

inline void bfs(int s, long long *dis, bool fg) {
	int *l = que, *r = que, u, v;
	memset(vis, 0, sizeof vis);
	*r++ = s;
	dis[s] = 0;
	vis[s] = true;
	while (l &lt; r) {
		int u = *l++;
		for (edge *it = g[u]; it; it = it-&gt;nxt) {
			v = it-&gt;to;
			if (vis[v])
				continue;
			vis[v] = true;
			dis[v] = dis[u] + it-&gt;cost;
			*r++ = v;
			if (fg)
				from[v] = it;
		}
	}
}

inline void spfa(const int &amp;n) {
	int *l = que, *r = que, u, v;
	memset(d, 63, sizeof d);
	memset(vis, 0, sizeof vis);
	for (u = 1; u &lt;= n; ++u)
		if (mark[u]) {
			*r++ = u;
			vis[u] = true;
			d[u] = 0;
		}
	while (l &lt; r) {
		u = *l++;
		vis[u] = false;
		for (edge *it = g[u]; it; it = it-&gt;nxt) {
			v = it-&gt;to;
			if (d[v] &lt;= d[u] + it-&gt;cost)
				continue;
			d[v] = d[u] + it-&gt;cost;
			if (!vis[v]) {
				vis[v] = true;
				*r++ = v;
			}
		}
	}
}

#define max(a, b) (a &lt; b ? b : a)

int main() {
	int n, k, i, j, a, b, c, u;
	long long sum = 0LL;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for (i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
		add_edge(a, b, c);
		add_edge(b, a, c);
	}
	for (i = 0; i &lt; k; ++i)
		scanf(&quot;%d&quot;, home + i);
	bfs(*home, d0, true);

	mark[*home] = true;

	for (i = 1; i &lt; k; ++i)
		for (u = home[i]; !mark[u]; u = from[u]-&gt;from)
			sum += from[u]-&gt;cost, mark[u] = true;
	
	spfa(n);

	u = *home;
	for (i = 1; i &lt; k; ++i)
		if (d0[u] &lt; d0[home[i]])
			u = home[i];

	bfs(u, d1, false);

	u = *home;
	for (i = 1; i &lt; k; ++i)
		if (d1[u] &lt; d1[home[i]])
			u = home[i];

	bfs(u, d0, false);
	
	sum &lt;&lt;= 1;
	for (i = 1; i &lt;= n; ++i)
		printf(&quot;%lld\n&quot;, sum - max(d0[i], d1[i]) + (mark[i] ? 0 : (d[i] &lt;&lt; 1)));
		
	return 0;
}<pre><h2>Problem3744</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define N 50003

int tr[2][N], trend, a[N], ha[N], _tr;
int f[230][N], bel[N];

void add(int x) {
	for (; x &lt; trend; x += x &amp; -x) {
		if (tr[0][x] ^ _tr) {
			tr[0][x] = _tr;
			tr[1][x] = 0;
		}
		++tr[1][x];
	}
}

int sum(int x) {
	static int r;
	for (r = 0; x; x ^= x &amp; -x) 
	  if (tr[0][x] &gt;= _tr)
		r += tr[1][x];
	return r;
}

struct node {
	int sum;
	node *ls, *rs;
} mset[N * 20], *nodeit = mset, *rt[N];

void Insert(node *x, node * &amp;y, int l, int r, const int &amp;p) {
	*(y = ++nodeit) = *x;
	++y-&gt;sum;
	if (l &gt;= r) return;
	int m = (l + r) &gt;&gt; 1;
	if (p &lt;= m)
	  Insert(x-&gt;ls, y-&gt;ls, l, m, p);
	else
	  Insert(x-&gt;rs, y-&gt;rs, m + 1, r, p);
}

void Query(node *x, node * &amp;y, int l, int r, const int &amp;p, int &amp;v) {
	if (r &lt; p)
	  return (void)(v += y-&gt;sum - x-&gt;sum);
	int m = (l + r) &gt;&gt; 1;
	if (m + 1 &lt; p)
	  Query(x-&gt;rs, y-&gt;rs, m + 1, r, p, v);
	Query(x-&gt;ls, y-&gt;ls, l, m, p, v);
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);

	int n, m, l, r, i, j, *end, blo, ans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (blo = 1; blo * blo &lt;= n; ++blo);
	//blo = 28;
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, a + i);
		bel[i] = (i - 1) / blo + 1;
		ha[i] = a[i];
	}
	std::sort(ha + 1, ha + n + 1);
	end = std::unique(ha + 1, ha + n + 1);
	trend = end - ha;

	*rt = mset;
	**rt = (node) {0, *rt, *rt};

	for (i = 1; i &lt;= n; ++i) {
		a[i] = std::lower_bound(ha + 1, end, a[i]) - ha;
		Insert(rt[i - 1], rt[i], 1, trend - 1, a[i]);
	}

	for (i = 1; i &lt;= bel[n]; ++i) {
		++_tr;
		for (j = (i - 1) * blo + 1; j &lt;= n; ++j) {
			f[i][j] = f[i][j - 1] + sum(trend - 1) - sum(a[j]);
			add(a[j]);
		}
	}

	scanf(&quot;%d&quot;, &amp;m);

	while (m--) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		//printf(&quot;%d\n&quot;, m);
		l ^= ans, r ^= ans;
		if (bel[l] ^ bel[r]) {
			ans = f[bel[l] + 1][r];
			for (i = l, j = bel[l] * blo + 1; i &lt; j; ++i) 
			  if (a[i] &gt; 1) Query(rt[i], rt[r], 1, trend - 1, a[i], ans);
		} else {
			ans = 0;
			++_tr;
			for (i = l; i &lt;= r; ++i) {
				ans += sum(trend - 1) - sum(a[i]);
				add(a[i]);
			}
		}
		printf(&quot;%d\n&quot;, ans);
	}

	return 0;
}<pre><h2>Problem3811</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef unsigned long long ll;
inline ll readLL() {
    static ll n;
    static int ch;
    n = 0, ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) n = n * 10 + ch - '0', ch = getchar();
    return n;
}

const int MAX_N = 100000 + 3, MAX_BASE = 23;
int n, K;
ll a[MAX_N], b[MAX_N];

void solve1() {
    ll res = 0;
    for (int i = 0; i &lt; n; ++i) res |= a[i];
    printf(&quot;%llu&quot;, res / 2);
    if (res &amp; 1) puts(&quot;.5&quot;);
    else puts(&quot;&quot;);
}

void solve2() {
    ll ans = 0, res = 0;
    for (int i = 0; i &lt; 32; ++i)
        for (int j = 0; j &lt; 32; ++j) {
            bool flag = false;
            for (int k = 0; k &lt; n; ++k) if (a[k] &gt;&gt; i &amp; 1) { flag = true; break; }
            if (!flag) continue;
            flag = false;
            for (int k = 0; k &lt; n; ++k) if (a[k] &gt;&gt; j &amp; 1) { flag = true; break; }
            if (!flag) continue;

            flag = false;
            for (int k = 0; k &lt; n; ++k) if ((a[k] &gt;&gt; i &amp; 1) != (a[k] &gt;&gt; j &amp; 1)) { flag = true; break; }

            if (i + j - 1 - flag &lt; 0) res++;
            else {
                if (!flag) ans += 1LL &lt;&lt; (i + j - 1); // 1 / 2
                else ans += 1LL &lt;&lt; (i + j - 1 - 1); // 1 / 4
            }
        }

    ans += res &gt;&gt; 1, res &amp;= 1;
    printf(&quot;%llu&quot;, ans);
    if (res) puts(&quot;.5&quot;);
    else puts(&quot;&quot;);
}

void solve3() {
    vector&lt;int&gt; vec;
    for (int i = 0; i &lt; n; ++i)
        for (int j = MAX_BASE; j &gt;= 0; --j)
            if (a[i] &gt;&gt; j &amp; 1) {
                if (b[j]) a[i] ^= b[j];
                else {
                    b[j] = a[i];
                    vec.push_back(a[i]);
                    break;
                }
            }

    int all = vec.size();
    ll ans = 0, res = 0;
    for (int i = (1 &lt;&lt; all) - 1; i &gt;= 0; --i) {
        int val = 0;
        for (int j = 0; j &lt; (int)vec.size(); ++j) if (i &gt;&gt; j &amp; 1) val ^= vec[j];

        ll a = 0, b = 1;
        for (int j = 0; j &lt; K; ++j) {
            a *= val, b *= val;
            a += b &gt;&gt; all, b &amp;= (1 &lt;&lt; all) - 1;
        }

        ans += a, res += b;
        ans += res &gt;&gt; all, res &amp;= (1 &lt;&lt; all) - 1;
    }

    printf(&quot;%llu&quot;, ans);
    if (res) puts(&quot;.5&quot;);
    else puts(&quot;&quot;);
}

int main() {
    n = readLL(), K = readLL();
    for (int i = 0; i &lt; n; ++i) a[i] = readLL();

    if (K == 1) solve1();
    else if (K == 2) solve2();
    else solve3();
    return 0;
}<pre><h2>Problem3811</h2><pre>#include &lt;cstdio&gt;

typedef unsigned long long ul;

inline ul gul() {
	static ul a;
	static char c;
	do c = getchar_unlocked(); while (c &lt; 48);
	a = c - 48;
	while (47 &lt; (c = getchar_unlocked()))
		a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48;
	return a;
}

int n, k;
ul a[100004];

inline void case1() {
	ul res = 0;
	for (register int i = 0; i &lt; n; ++i) res |= a[i];
	printf(&quot;%llu&quot;, res &gt;&gt; 1);
	if (res &amp; 1) puts(&quot;.5&quot;);
	else puts(&quot;&quot;);
}

inline void case2() {
	ul res = 0, cnt = 0;
	bool flag;
	for (register int i = 0; i &lt; 32; ++i)
		for (register int j = 0; j &lt; 32; ++j) {
			flag = false;
			for (register int k = 0; k &lt; n; ++k)
				if (a[k] &gt;&gt; i &amp; 1) {
					flag = true;
					break;
				}
			if (!flag) continue;
			flag = false;
			for (register int k = 0; k &lt; n; ++k)
				if (a[k] &gt;&gt; j &amp; 1) {
					flag = true;
					break;
				}
			if (!flag) continue;
			flag = false;
			for (register int k = 0; k &lt; n; ++k)
				if ((a[k] &gt;&gt; i &amp; 1) ^ (a[k] &gt;&gt; j &amp; 1)) {
					flag = true;
					break;
				}

			if (i + j - 1 - flag &lt; 0)
				++cnt;
			else
				res += 1ULL &lt;&lt; (i + j - 1 - flag);
		}
	res += cnt &gt;&gt; 1;
	printf(&quot;%llu&quot;, res);
	if (cnt &amp; 1) puts(&quot;.5&quot;);
	else puts(&quot;&quot;);
}

ul b[25];
int c[25];

inline void case345() {
	int cnt = 0;
	for (register int i = 0; i &lt; n; ++i)
		for (register int j = 23; ~j; --j)
			if (a[i] &gt;&gt; j &amp; 1) {
				if (b[j]) a[i] ^= b[j];
				else {
					c[cnt++] = b[j] = a[i];
					break;
				}
			}
	
	ul res = 0, tot = 0;
	int all = 1 &lt;&lt; cnt, val;
	for (register int s = all - 1; ~s; --s) {
		val = 0;
		for (register int i = 0; i &lt; cnt; ++i)
			if (s &gt;&gt; i &amp; 1) val ^= c[i];
		ul a = 0, b = 1;
		for (register int i = 0; i &lt; k; ++i) {
			a *= val, b *= val;
			a += b &gt;&gt; cnt;
			b &amp;= all - 1;
		}
		
		res += a;
		tot += b;
		res += tot &gt;&gt; cnt;
		tot &amp;= all - 1;
	}

	printf(&quot;%llu&quot;, res);
	if (tot) puts(&quot;.5&quot;);
	else puts(&quot;&quot;);
}

int main() {
	n = gul(), k = gul();
	for (register int i = 0; i &lt; n; ++i)
		a[i] = gul();
	
	if (k == 1) case1();
	else if (k == 2) case2();
	else case345();
	
	return 0;
}<pre><h2>Problem3817</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;

int r;
double _r;

inline int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

inline int calc(int n, int a, int b, int c) {
	//// \sum_{i=1}^{n} \lfloor{{b * i + c} \over a}
	if (!n) return 0;
	int g = gcd(a, gcd(b, c));
	a /= g, b /= g, c /= g;
	long long m = ((long long)b * _r + c) / a;
	long long sum = n * (n + 1LL) / 2 * m;
	c -= m * a;
	m = ((long long)b * _r + c) / a * n;
	sum += n * m;
	return sum - calc(m, b * b * r - c * c, a * b, -a * c);
}

int main() {
	int o_o, n, t;
	scanf(&quot;%d&quot;, &amp;o_o);
	while (o_o--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;r);
		_r = sqrt(r);
		t = int(_r);
		if (t * t == r)
			printf(&quot;%d\n&quot;, t &amp; 1 ? (n &amp; 1 ? -1 : 0) : n);
		else
			printf(&quot;%d\n&quot;, n - ((calc(n, 1, 1, 0) - (calc(n, 2, 1, 0) &lt;&lt; 1)) &lt;&lt; 1));
	}
	return 0;
}<pre><h2>Problem3878</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define MAXN 100005

long long L, R;

struct Tag {
  long long a, b, c;
  Tag() {}
  Tag(long long _a, long long _b, long long _c) :
    a(_a), b(_b), c(_c) {}
  void clear() {
    a = 1;
    b = c = 0;
  }
  long long calc(long long x) {
    long long t = (a + b) * x + c;
    if (t &lt; L) return L;
    else if (t &gt; R) return R;
    else return t;
  }
};

Tag operator + (const Tag &amp;x, const Tag &amp;y) {
  return Tag(x.a * y.a, x.b * y.a + y.b, x.c * y.a + y.c);
}

Tag operator += (Tag &amp;x, const Tag &amp;y) {
  x = x + y;
  return x;
}

struct Node {
  Tag left, right, lazy_tag;
  Node *left_son, *right_son;
  Node() {
    left.clear();
    right.clear();
    lazy_tag.clear();
    left_son = right_son = NULL;
  }
} node_pool[MAXN * 4], *root;

Node *NewNode() {
  static Node *cur_node = node_pool;
  return cur_node++;
}

char p[MAXN];
bool mark[256];
int a[MAXN], x[MAXN], rank[MAXN];

bool compare(const int &amp;i, const int &amp;j) {
  return x[i] &lt; x[j];
}

void BuildTree(Node *(&amp;u), int l, int r) {
  u = NewNode();
  if (l == r) return;
  int mid = (l + r) / 2;
  BuildTree(u-&gt;left_son, l, mid);
  BuildTree(u-&gt;right_son, mid + 1, r);
}

void PushDown(Node *u, int l, int r) {
  if (l &gt;= r) return;
  u-&gt;left_son-&gt;lazy_tag += u-&gt;lazy_tag;
  u-&gt;left_son-&gt;left += u-&gt;lazy_tag;
  u-&gt;left_son-&gt;right += u-&gt;lazy_tag;
  u-&gt;right_son-&gt;lazy_tag += u-&gt;lazy_tag;
  u-&gt;right_son-&gt;left += u-&gt;lazy_tag;
  u-&gt;right_son-&gt;right += u-&gt;lazy_tag;
  u-&gt;lazy_tag.clear();
}

void Modify(Node *(&amp;u), int l, int r) {
  if (u-&gt;right.calc((long long)x[rank[r]]) != R &amp;&amp;
      u-&gt;left.calc((long long)x[rank[l]]) != L) return;
  PushDown(u, l, r);
  if (u-&gt;left.calc((long long)x[rank[l]]) == R) {
    u-&gt;left = u-&gt;right = u-&gt;lazy_tag = Tag(0, 0, R);
    return;
  }
  if (u-&gt;right.calc((long long)x[rank[r]]) == L) {
    u-&gt;left = u-&gt;right = u-&gt;lazy_tag = Tag(0, 0, L);
    return;
  }
  int mid = (l + r) / 2;
  Modify(u-&gt;left_son, l, mid);
  Modify(u-&gt;right_son, mid + 1, r);
  u-&gt;left = u-&gt;left_son-&gt;left;
  u-&gt;right = u-&gt;right_son-&gt;right;
}

void Solve(Node *(&amp;u), int l, int r) {
  PushDown(u, l, r);
  if (l == r) {
    x[rank[l]] = (int)u-&gt;left.calc((long long)x[rank[l]]);
  } else {
    int mid = (l + r) / 2;
    Solve(u-&gt;left_son, l, mid);
    Solve(u-&gt;right_son, mid + 1, r);
  }
}

int main() {
  int n, m;
  scanf(&quot;%d%lld%lld&quot;, &amp;n, &amp;L, &amp;R);
  mark['+'] = mark['-'] = mark['*'] = mark['@'] = true;
  for (int i = 1; i &lt;= n; ++i) {
    char &amp;ch = p[i];
    do {
      ch = getchar();
    } while (!mark[(int)ch]);
    scanf(&quot;%d&quot;, a + i);
  }
  scanf(&quot;%d&quot;, &amp;m);
  for (int i = 1; i &lt;= m; ++i) {
    rank[i] = i;
    scanf(&quot;%d&quot;, x + i);
  }
  std::sort(rank + 1, rank + m + 1, compare);

  BuildTree(root, 1, m);
  for (int i = 1; i &lt;= n; ++i) {
    static Tag v;
    switch (p[i])  {
    case '+' : v = Tag(1, 0, a[i]); break;
    case '-' : v = Tag(1, 0, -a[i]); break;
    case '*' : v = Tag(a[i], 0, 0); break;
    case '@' : v = Tag(1, a[i], 0); break;
    default : break;
    }
    root-&gt;lazy_tag += v;
    root-&gt;left += v;
    root-&gt;right += v;
    Modify(root, 1, m);
  }
  Solve(root, 1, m);
  for (int i = 1; i &lt;= m; ++i)
    printf(&quot;%d\n&quot;, x[i]);
  return 0;
}<pre><h2>Problem3879</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N = 5e5+100;
const int M = 3E6+100;
const ll MOD = 23333333333333333;
int n,m,len,data[M],Sa[N],hei[N];
int st[22][N],two[50],tmph[M];
char str[N];
int ask(int l,int r){
	int k = log2(r-l+1);
	return min(st[k][l] , st[k][r-two[k]+1]);
}
namespace Suf{
	int tmp[2][N*2],cot[N],tl[N];
	void sort(int n,char s[],int sa[]){
		int i,j,p=0,m='z'+1,*x=tmp[0],*y=tmp[1];
		for(i=0;i&lt;m;i++)cot[i]=0;
		for(i=0;i&lt;n;i++)cot[x[i]=s[i]]++;
		for(i=1;i&lt;m;i++)cot[i] += cot[i-1];
		for(i=n-1;i&gt;=0;i--)sa[--cot[x[i]]] = i;
		for(j=1;j&lt;n&amp;&amp;p&lt;n;j+=j,m=p){
			//sort 2
			for(p=0,i=n-j;i&lt;n;i++)y[p++] = i;
			for(i=0;i&lt;n;i++)if(sa[i] - j&gt;=0)y[p++] = sa[i] - j;
			for(i=0;i&lt;n;i++)tl[i] = x[y[i]];
			//sort 1
			for(i=0;i&lt;m;i++)cot[i]=0;
			for(i=0;i&lt;n;i++)cot[tl[i]]++;
			for(i=1;i&lt;m;i++)cot[i] += cot[i-1];
			for(i=n-1;i&gt;=0;i--)sa[--cot[tl[i]]] = y[i];
			//calc x
			swap(x,y);x[sa[0]] = 0;p = 1;
			for(i=1;i&lt;n;i++)
			if((sa[i]+j&lt;n)^(sa[i-1]+j&lt;n))x[sa[i]]=p++;
			else x[sa[i]]=y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+j]==y[sa[i-1]+j]?p-1:p++;
		}
	}
	void geth(int n,char s[],int sa[],int h[]){
		int i,j,k=0,*rk=tmp[0];
		for(i=0;i&lt;n;i++)rk[sa[i]] = i;
		for(i=0;i&lt;n;h[rk[i++]]=k)
		if(rk[i]-1&gt;=0)for(k?k--:0,j=sa[rk[i]-1];s[i+k]==s[j+k];k++);
		else k=0;
	}
	void getst(int n){
		int i,j,lgn = log2(n-1)+1;
		for(i=0;i&lt;n;i++)st[0][i] = hei[i];
		for(j=1;j&lt;=lgn;j++)
		for(i=1;i+two[j-1]&lt;n;i++)
		st[j][i] = min(st[j-1][i] , st[j-1][i+two[j-1]]);
	}
}
int scan(){
	char cc=' ';int re=0,fh=1;while(cc==' '||cc=='\r'||cc=='\n')cc=getchar();
	if(cc=='+')cc=getchar(),fh=1;if(cc=='-')cc=getchar(),fh=-1;
	while('0'&lt;=cc&amp;&amp;cc&lt;='9'){re=re*10+cc-'0';cc=getchar();}return re*fh;
}
bool cmp(int a,int b){return Suf::tmp[0][a] &lt; Suf::tmp[0][b];}
struct Node{Node(int a=0,ll b=0){i=a;d=b;}int i;ll d;};
deque&lt;int&gt;dui;
void print(){
	int i,j;
	printf(&quot;%s\n&quot;,str);
	for(i=0;i&lt;len;i++){
		printf(&quot;[%d %d]%s\n&quot;,hei[i],Sa[i],str+Sa[i]);
	}
}
bool better(int a,int b){return b&lt;=a;}
int main(){
	//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
	int i,j;
	for(two[0]=1,i=1;i&lt;=30;i++)two[i] = two[i-1]*2;
	scanf(&quot;%d%d&quot;,&amp;len,&amp;m);
	scanf(&quot;%s&quot;,str);
	Suf::sort(len,str,Sa);
	Suf::geth(len,str,Sa,hei);
	Suf::getst(len);
	//print();
	int *rk = Suf::tmp[0];
	while(m--){
		scanf(&quot;%d&quot;,&amp;n);for(i=1;i&lt;=n;i++)data[i] = scan()-1;
		sort(data+1,data+1+n,cmp);
		n = unique(data+1,data+1+n)-data-1;
		ll ans = 0,nans = 0;
		dui.clear();//dui.push_back(Node());
		dui.push_back(1);
		for(i=2;i&lt;=n;i++){
			tmph[i] = ask(rk[data[i-1]]+1,rk[data[i]]);
			while((j=dui.size())&gt;1 &amp;&amp; better(tmph[dui.back()],tmph[i])){
				nans = (nans - (ll)tmph[dui[j-1]]*(dui[j-1] - dui[j-2]))%MOD;
				dui.pop_back();
			}
			nans = (nans + (ll)tmph[i] * (i - dui[j-1]))%MOD;
			dui.push_back(i);
			ans = (ans + nans)%MOD;
		}
		//printf(&quot;\n&quot;);
		if(ans &lt; 0)ans += MOD;
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem3879</h2><pre>#include &lt;bits/stdc++.h&gt;
#define wlp while
#define rep(i, l, r) for (i = l; i &lt; r; ++i)
#define Rep(i, l, r) for (i = l; i &lt;= r; ++i)
#define N 500005

int sa[N], h[N], lg[N], tarr[4][N], st[19][N];
bool cmp(int *r, int i, int j, int l) {
	return r[i] == r[j] &amp;&amp; r[i + l] == r[j + l];
}
void da(char *a, int n, int m) {
	int i, j, p, *x = tarr[0], *y = tarr[1], *s = tarr[2], *v = tarr[3], *t;
	rep(i, 0, m) s[i] = 0;
	rep(i, 0, n) ++s[x[i] = a[i] - 'a'];
	rep(i, 1, m) s[i] += s[i - 1];
	for (i = n - 1; ~i; --i) sa[--s[x[i]]] = i;
	for (j = p = 1; p &lt; n; j &lt;&lt;= 1, m = p) {
		for (p = 0, i = n - j; i &lt; n; ++i) y[p++] = i;
		rep(i, 0, n) if (sa[i] &gt;= j) y[p++] = sa[i] - j;
		rep(i, 0, m) s[i] = 0;
		rep(i, 0, n) ++s[v[i] = x[y[i]]];
		rep(i, 1, m) s[i] += s[i - 1];
		for (i = n - 1; ~i; --i) sa[--s[v[i]]] = y[i];
		for (t = x, x = y, y = t, p = i = 1, x[sa[0]] = 0; i &lt; n; ++i)
			x[sa[i]] = cmp(y, sa[i], sa[i - 1], j) ? p - 1 : p++;
	}
}
void calheight(char *s, int n) {
	int i, j, k, *rk = tarr[0];
	rep(i, 0, n) rk[sa[i]] = i;
	for (i = k = 0; i &lt; n; h[rk[i++]] = k)
		if (rk[i]) for (k ? --k : 0, j = sa[rk[i] - 1]; s[i + k] == s[j + k]; ++k);
}
void initst(int n) {
	int i, j, lgn = lg[n - 1] + 1;
	rep(i, 0, n) st[0][i] = h[i];
	Rep(j, 1, lgn) rep(i, 1, n - (1 &lt;&lt; j - 1))
		st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; j - 1)]);
}
int ask(int l, int r) {
	static int t;
	t = lg[r - l + 1];
	return std::min(st[t][l], st[t][r - (1 &lt;&lt; t) + 1]);
}
bool _cp(const int &amp;a, const int &amp;b) {
	return tarr[0][a] &lt; tarr[0][b];
}
int stk[N], th[N], a[N];
char str[N];
int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int i, n, m, qk, *rk, tp;
	long long ans, _t;
	scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, str);
	lg[0] = -1;
	Rep(i, 1, n) lg[i] = lg[i&gt;&gt;1] + 1;
	da(str, n, 26);
	calheight(str, n);
	initst(n);
	
	rk = tarr[0];
	while (m--) {
		scanf(&quot;%d&quot;, &amp;qk);
		Rep(i, 1, qk) scanf(&quot;%d&quot;, a + i), --a[i];
		std::sort(a + 1, a + qk + 1, _cp);
		qk = std::unique(a + 1, a + qk + 1) - a - 1;
		ans = _t = 0;
		stk[tp = 1] = 1;
		Rep(i, 2, qk) {
			th[i] = ask(rk[a[i - 1]] + 1, rk[a[i]]);
			while (1 &lt; tp &amp;&amp; th[stk[tp]] &gt;= th[i]) {
				_t -= (long long)th[stk[tp]] * (stk[tp] - stk[tp - 1]);
				--tp;
			}
			_t += (long long)th[i] * (i - stk[tp]);
			stk[++tp] = i;
			ans += _t;
		}
		printf(&quot;%lld\n&quot;, ans);
	}
	
	return 0;
}<pre><h2>Problem3884</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 10000005
#define ll long long
int ina; char inc;
inline int geti() {
	while((inc=getchar())&lt;'0'||inc&gt;'9');ina=inc-'0';
	while((inc=getchar())&gt;='0'&amp;&amp;inc&lt;='9')ina=(ina&lt;&lt;3)+(ina&lt;&lt;1)+inc-'0';
	return ina;
}
int phi[N],f[N];
int getphi(int i) {
	if(phi[i]) return phi[i];
	int t=sqrt(i),j,res=i;
	for(j=2;j&lt;=t;++j) 
	if(i%j==0){
		res=res/j*(j-1);
		while(i%j==0) i/=j;
	}(i&gt;1)?res=res/i*(i-1):1;
	return phi[i]=res;
}
int mod_pow(ll a,ll b,int p) {
	ll ret=1LL; a%=p;
	for(;b;b&gt;&gt;=1,a=a*a%p) (b&amp;1)?ret=ret*a%p:1;
	return ret;
}
int cal(int p) {
	if(~f[p]) return f[p];
	int k=0,ph=getphi(p),res,t=p;
	while(~t&amp;1) t&gt;&gt;=1,++k;
	res=cal(ph); res=(res+ph-k%ph)%ph;
	res=mod_pow(2,res,t)%t;
	return f[p]=(res&lt;&lt;k);
}
int main() {
	memset(f,-1,sizeof f); f[1]=0;
	for(int i=geti();i;--i) printf(&quot;%d\n&quot;,cal(geti()));
	return 0;
}
<pre><h2>Problem3926</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 1e5 + 13;

struct node {
	int step;
	node *pre, *ch[10];
}node_mset[MaxN * 40], *cnode = node_mset, *root;

inline node *newnode(const int &amp;step) {
	cnode-&gt;step = step;
	return cnode++;
}

inline node *Insert(const int &amp;c, node *last) {
	node *p = last, *np = newnode(p-&gt;step + 1);
	for (; p &amp;&amp; !p-&gt;ch[c]; p = p-&gt;pre)
		p-&gt;ch[c] = np;
	if (!p)
		np-&gt;pre = root;
	else {
		node *q = p-&gt;ch[c];
		if (q-&gt;step == p-&gt;step + 1)
			np-&gt;pre = q;
		else {
			node *nq = newnode(p-&gt;step + 1);
			memcpy(nq-&gt;ch, q-&gt;ch, sizeof q-&gt;ch);
			nq-&gt;pre = q-&gt;pre;
			q-&gt;pre = np-&gt;pre = nq;
			for (; p &amp;&amp; p-&gt;ch[c] == q; p = p-&gt;pre)
				p-&gt;ch[c] = nq;
		}
	}
	return np;
}

struct edge {
	int to;
	edge *nxt;
} edge_mset[MaxN &lt;&lt; 1], *g[MaxN], *cedge = edge_mset;

inline void add_edge(int u, int v) {
	*cedge = (edge) {v, g[u]};
	g[u] = cedge++;
}

int col[MaxN];

void dfs(int u, int fa, node *last) {
	last = Insert(col[u], last);
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if (it-&gt;to ^ fa) dfs(it-&gt;to, u, last);
}

int main() {
	int n, c;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;c);
	for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, col + i);
	for (int i = 1, u, v; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		--u, --v;
		add_edge(u, v);
		add_edge(v, u);
	}
	root = newnode(0);
	for (int i = 0; i &lt; n; ++i)
		if (!g[i]-&gt;nxt) dfs(i, -1, root);
	long long ans = 0;
	for (node *i = node_mset; i &lt; cnode; ++i)
		ans += i-&gt;step - (i-&gt;pre ? i-&gt;pre-&gt;step : 0);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem3930</h2><pre>#include &lt;cstdio&gt;
const int mo = 1e9 + 7, N = 100051;
int f[N];
int pw(int a, int b) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = (long long)a * a % mo)
		if (b &amp; 1) r = (long long)r * a % mo;
	return r;
}
int main() {
	int n, k, a, b, l, r, L, R, i, j;
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;k, &amp;a, &amp;b);
	l = a / k, r = b / k;
	if (a % k) ++l;
	if (l &lt;= r) for (i = b - a; i; --i) {
		L = l / i, R = r / i;
		if (l % i) ++L;
		f[i] = pw(R - L + 1, n) - (R - L + 1) + mo;
		while (f[i] &gt;= mo) f[i] -= mo;
		for (j = i &lt;&lt; 1; j &lt;= b - a; j += i)
			for(f[i] += mo - f[j]; f[i] &gt;= mo; f[i] -= mo);
	}
	if (l == 1) ++f[1] &gt;= mo ? f[1] -= mo : 1;
	printf(&quot;%d\n&quot;, f[1]);
	return 0;
}
<pre><h2>Problem3932</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
const int N=1e5+5,MS=N*40;
pair&lt; int, pair&lt; int,int&gt; &gt;p[N&lt;&lt;1];
int ls[MS],rs[MS],cnt[MS],rt[N],cnd;
long long sum[MS];
int MP[N],mcnt;
inline int g(const int&amp;x){return lower_bound(MP+1,MP+mcnt+1,x)-MP;}
void insert(int&amp;x,int y,int l,int r,const int&amp;v,const int&amp;delta) {
	x=++cnd;ls[x]=ls[y],rs[x]=rs[y],sum[x]=sum[y]+MP[v]*delta,cnt[x]=cnt[y]+delta;
	if(l==r)return; int m=l+r&gt;&gt;1;
	if(v&lt;=m)insert(ls[x],ls[y],l,m,v,delta);
	else insert(rs[x],rs[y],m+1,r,v,delta);
}
inline long long query(int x,int k) {
	static long long r;
	for(r=0;;) {
		if(k&gt;=cnt[x]) return r+sum[x];
		if(!ls[x]&amp;&amp;!rs[x]) return r+sum[x]/cnt[x]*k;
		if(k==cnt[ls[x]])return r+sum[ls[x]];
		if(k&lt;cnt[ls[x]])x=ls[x];
		else k-=cnt[ls[x]],r+=sum[ls[x]],x=rs[x];
	}
}
int main() {
	int n,m,a,b,c,i,j,k,t,x;
	long long las=1;
	m=gi(),n=gi();
	for(k=i=0;i&lt;m;++i) {
		a=gi(),b=gi(),c=gi();
		p[k++]=make_pair(a,make_pair(c,1));
		if(b&lt;n)p[k++]=make_pair(b+1,make_pair(c,-1));
		MP[++mcnt]=c;
	}
	sort(p,p+k);
	sort(MP+1,MP+mcnt+1);
	mcnt=unique(MP+1,MP+mcnt+1)-MP-1;
	for(i=1,j=0;i&lt;=n;++i) {
		rt[i]=rt[i-1];
		while(j&lt;k&amp;&amp;p[j].first==i) {
			t=(j&amp;&amp;p[j-1].first==i)?rt[i]:rt[i-1];
			insert(rt[i],t,1,mcnt,g(p[j].second.first),p[j].second.second);
			++j;
		}
	}
	for(i=0;i&lt;n;++i) {
		x=gi(),a=gi(),b=gi(),c=gi();
		k=1+(las*a+b)%c;
		printf(&quot;%lld\n&quot;,las=query(rt[x],k));
	}
	return 0;
}<pre><h2>Problem3944</h2><pre>    #include&lt;iostream&gt;  
    #include&lt;cstdio&gt;  
    #include&lt;cstring&gt;  
    #define ll long long  
    using namespace std;  
      
    int cas,n,m,cnt,c[1000005]; ll phi[2000005],mu[2000005],p[100005],q[100005]; bool vis[100005];  
    ll get_p(int x){  
        return (x&lt;=m)?phi[x]:p[n/x];  
    }  
    ll get_q(int x){  
        return (x&lt;=m)?mu[x]:q[n/x];  
    }  
    void solve(int x){  
        if (x&lt;=m) return; int i,j=1,t=n/x;  
        if (vis[t]) return; vis[t]=1;  
        p[t]=((ll)x+1)*x&gt;&gt;1; q[t]=1;  
        while (j&lt;x){  
            i=j+1; j=x/(x/i); solve(x/i);  
            p[t]-=get_p(x/i)*(j-i+1); q[t]-=get_q(x/i)*(j-i+1);  
        }  
    }  
    int main(){  
        scanf(&quot;%d&quot;,&amp;cas); m=2000000;  
        int i,j; phi[1]=mu[1]=1;  
        for (i=2; i&lt;=m; i++){  
            if (!phi[i]){  
                phi[i]=i-1; mu[i]=-1; c[++cnt]=i;  
            }  
            for (j=1; j&lt;=cnt &amp;&amp; i*c[j]&lt;=m; j++)  
                if (i%c[j]){  
                    phi[i*c[j]]=phi[i]*(c[j]-1); mu[i*c[j]]=-mu[i];  
                } else{  
                    phi[i*c[j]]=phi[i]*c[j]; mu[i*c[j]]=0; break;  
                }  
        }  
        for (i=2; i&lt;=m; i++){ phi[i]+=phi[i-1]; mu[i]+=mu[i-1]; }  
        while (cas--){  
            scanf(&quot;%d&quot;,&amp;n); memset(vis,0,sizeof(vis));  
            if (n&lt;=m) printf(&quot;%lld %lld\n&quot;,phi[n],mu[n]); else{  
                solve((ll)n); printf(&quot;%lld %lld\n&quot;,p[1],q[1]);  
            }  
        }  
    }  <pre><h2>Problem3944</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxn(2000005), maxp(100005);

bool vis[maxn];
long long a1[maxp], phi[maxn];
int p[maxn / 10], a2[maxp], mu[maxn], n;

inline void silver() {
	int tot = 0;
	phi[1] = mu[1] = 1;
	for (register int i = 2; i &lt; maxn; ++i) {
		if (!phi[i]) {
			mu[i] = -1;
			phi[i] = i - 1;
			p[tot++] = i;
		}
		for (register int j = 0, t; (t = i * p[j]) &lt; maxn; ++j)
			if (i % p[j]) {
				mu[t] = -mu[i];
				phi[t] = phi[i] * (p[j] - 1);
			} else {
				mu[t] = 0;
				phi[t] = phi[i] * p[j];
				break;
			}
	}
	for (register int i = 1; i &lt; maxn; ++i)
		mu[i] += mu[i - 1], phi[i] += phi[i - 1];
}

inline int calc_mu(int x) {
	return (x &lt; maxn) ? mu[x] : a2[n / x];
}

inline long long calc_phi(int x) {
	return (x &lt; maxn) ? phi[x] : a1[n / x];
}

void solve(int x) {
	if (x &lt; maxn) return;
	int i, j = 1, t = n / x;
	if (vis[t]) return;
	vis[t] = true;
	a1[t] = (x + 1ll) * x &gt;&gt; 1;
	a2[t] = 1;
	while (j &lt; x) {
		i = j + 1;
		j = x / (x / i);
		solve(x / i);
		a1[t] -= calc_phi(x / i) * (j - i + 1);
		a2[t] -= calc_mu(x / i) * (j - i + 1);
	}
}

int main() {
	int o_o;
	silver();
	scanf(&quot;%d&quot;, &amp;o_o);

	while (o_o--) {
		scanf(&quot;%d&quot;, &amp;n);
		if (n &lt; maxn)
			printf(&quot;%lld %d\n&quot;, phi[n], mu[n]);
		else {
			memset(vis, 0, sizeof vis);
			solve(n);
			printf(&quot;%lld %d\n&quot;, a1[1], a2[1]);
		}
	}

	return 0;
}<pre><h2>Problem3991</h2><pre>#include &lt;set&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxn(1e5 + 7);
typedef int arr[maxn];

struct edge {
	int to, cost;
	edge *nxt;
} edge_mset[maxn &lt;&lt; 1], *g[maxn], *cedge = edge_mset;

inline void add_edge(int u, int v, int w) {
	*cedge = (edge) {v, w, g[u]};
	g[u] = cedge++;
}

int dfn;
long long dis[maxn];
arr son, fa, top, dq, size, dep, in;

void d1(int u) {
	int v;
	size[u] = 1;
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if ((v = it-&gt;to) ^ fa[u]) {
			fa[v] = u;
			dep[v] = dep[u] + 1;
			dis[v] = dis[u] + it-&gt;cost;
			d1(v);
			if (size[v] &gt; size[son[u]])
				son[u] = v;
			size[u] += size[v];
		}
}

void d2(int u, int anc) {
	top[u] = anc;
	dq[in[u] = ++dfn] = u;
	if (son[u])  d2(son[u], anc);
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if (!top[it-&gt;to]) d2(it-&gt;to, it-&gt;to);
}

inline int lca(int u, int v) {
	while (top[u] ^ top[v]) dep[top[u]] &lt; dep[top[v]] ? v = fa[top[v]] : u = fa[top[u]];
	return dep[u] &lt; dep[v] ? u : v;
}

inline long long disc(int u, int v) {
	return dis[u] + dis[v] - (dis[lca(u, v)] &lt;&lt; 1);
}

int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;3991.in&quot;, &quot;r&quot;, stdin);
#endif
	int n, m, u, v, w;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (register int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		add_edge(u, v, w);
		add_edge(v, u, w);
	}
	d1(1);
	d2(1, 1);
	while (m--) {
		static long long ans = 0;
		static bool status[maxn];
		static std::set&lt;int&gt; s;
		static std::set&lt;int&gt;::iterator it, pre, nxt;
		scanf(&quot;%d&quot;, &amp;u);
		if (status[u]) {
			status[u] = false;
			u = in[u];
			it = s.find(u);
			if (s.size() &gt; 1) {
				pre = nxt = it;
				if (pre == s.begin()) pre = s.end();
				--pre;
				if (++nxt == s.end()) nxt = s.begin();
				ans = ans - disc(dq[u], dq[*pre]) - disc(dq[u], dq[*nxt]) + disc(dq[*pre], dq[*nxt]);
			}
			s.erase(it);
		} else {
			status[u] = true;
			u = in[u];
			it = (s.insert(u)).first;
			if (s.size() &gt; 1) {
				pre = nxt = it;
				if (pre == s.begin()) pre = s.end();
				--pre;
				if (++nxt == s.end()) nxt = s.begin();
				ans = ans + disc(dq[u], dq[*pre]) + disc(dq[u], dq[*nxt]) - disc(dq[*pre], dq[*nxt]);
			}
		}
		printf(&quot;%lld\n&quot;, ans);
	}
	return 0;
}
<pre><h2>Problem3994</h2><pre>#include &lt;cstdio&gt;
const int MaxN = 50005;
int mu[MaxN], pri[MaxN];
bool vis[MaxN];
long long f[MaxN];
inline void silver() {
	int *end = pri;
	mu[1] = 1;
	for (int i = 2, *j, t; i &lt; MaxN; ++i) {
		if (!vis[i])
		  mu[*end++ = i] = -1;
		for (j = pri; (t = i * *j) &lt;  MaxN; ++j) {
			vis[t] = true;
			if (i % *j)
				mu[t] = -mu[i];
			else {
				mu[t] = 0;
				break;
			}
		}
	}
	for (int x = 1, t, i, last; x &lt;= MaxN; mu[x] += mu[x - 1], ++x)
		for (i = 1; i &lt;= x; i = last + 1) {
			t = x / i;
			last = x / t;
			f[x] += (long long)(last - i + 1) * t;
		}
}
inline int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}
inline void solve() {
	int n, m, _n, _m;
	long long ans = 0LL;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if (n &lt; m)
		n ^= m ^= n ^= m;
	for (int i = 1, last; i &lt;= m; i = last + 1) {
		_n = n / i;
		_m = m / i;
		last = min(n / _n, m / _m);
		ans += (mu[last] - mu[i - 1]) * f[_n] * f[_m];
	}
	printf(&quot;%lld\n&quot;, ans);
}
int main() {
	silver();
	int _;
	scanf(&quot;%d&quot;, &amp;_);
	while (_--)
		solve();
	return 0;
}
<pre><h2>Problem4004</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int maxn(505);

int n, m, r[maxn], w[maxn];
long double a[maxn][maxn], b[maxn][maxn];

inline bool check(const int &amp;x) {
	static bool v[maxn];
	for (register int i = 0; i &lt; m; ++i)
		if (fabs(a[x][i]) &gt; 1e-6) {
			if (v[i]) {
				long double k = a[x][i] / b[i][i];
				for (register int j = 0; j &lt; m; ++j)
					a[x][j] -= k * b[i][j];
			} else {
				v[i] = true;
				for (register int j = 0; j &lt; m; ++j)
					b[i][j] = a[x][j];
				return true;
			}
		}
		return false;
}

inline bool cmp(const int &amp;i, const int &amp;j) {
	return w[i] &lt; w[j];
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (register int i = 0; i &lt; n; ++i) {
		r[i] = i;
		for (register int j = 0; j &lt; m; ++j)
			scanf(&quot;%Lf&quot;, a[i] + j);
	}

	for (register int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, w + i);

	std::sort(r, r + n, cmp);

	int a1 = 0, a2 = 0;

	for (register int i = 0; i &lt; n; ++i)
		if (check(r[i])) ++a1, a2 += w[r[i]];
	printf(&quot;%d %d\n&quot;, a1, a2);
	return 0;
}
<pre><h2>Problem4006</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int maxn(1005), maxm(3005), maxp(11), maxstatus(1025), inf(0x3f3f3f3f);

std::queue&lt;int&gt; q;

struct edge {
	int to, cost;
	edge *nxt;
} edge_mset[maxm * 2 + 10], *g[maxn], *cedge = edge_mset;

inline void add_edge(int u, int v, int w) {
	*cedge = (edge) {v, w, g[u]};
	g[u] = cedge++;
}

bool inq[maxn]; 
int contian[maxp], val[maxn], n, m, p;
int dis[maxstatus][maxn], dp[maxstatus];

inline void spfa(int status) {
	int *d = dis[status];
	while (!q.empty()) {
		static int p, v;
		static edge *it;
		p = q.front();
		q.pop();
		inq[p] = false;
		for (it = g[p]; it; it = it-&gt;nxt) {
			v = it-&gt;to;
			if (d[v] &lt;= d[p] + it-&gt;cost)
				continue;
			d[v] = d[p] + it-&gt;cost;
			if (!inq[v]) 
				inq[v] = true, q.push(v);
		}
	}
}

inline bool check(int status) {
	for (register int i = 1; i &lt;= p; ++i)
		if ((status &amp; contian[i]) &amp;&amp; (status &amp; contian[i]) != contian[i])
			return false;
		return true;
}

int main() {
	int u, v, w, c, d;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p);
	memset(dis, 63, sizeof dis);
	while (m--) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
		add_edge(u, v, w);
		add_edge(v, u, w);
	}
	for (register int i = 1; i &lt;= p; ++i) {
		scanf(&quot;%d%d&quot;, &amp;c, &amp;d);
		contian[c] ^= 1 &lt;&lt; (i - 1);
		val[d] = 1 &lt;&lt; (i - 1);
		dis[val[d]][d] = 0;
	}
	int all = (1 &lt;&lt; p);
	for (register int status = 1; status ^ all; ++status) {
		for (register int i = 1; i &lt;= n; ++i) {
			for (register int s = (status - 1) &amp; status; s; s = (s - 1) &amp; status)
				if (dis[status][i] &gt; dis[s][i] + dis[status ^ s][i])
					dis[status][i] = dis[s][i] + dis[status ^ s][i];
				if (dis[status][i] ^ inf) {
					inq[i] = true;
					q.push(i);
				}
		}
		spfa(status);
	}
	memset(dp, 63, sizeof dp);
	for (register int i = 1; i ^ all; ++i)
		for (register int j = 1; j &lt;= n; ++j)
			if (dp[i] &gt; dis[i][j]) dp[i] = dis[i][j];

	//for (register int i = 1; i ^ all; ++i)
	//	printf(&quot;%d %d\n&quot;, i, dp[i]);

	for (register int i = 1; i ^ all; ++i) if (check(i))
		for (register int j = (i - 1) &amp; i; j; j = (j - 1) &amp; i)
			if (check(j) &amp;&amp; (dp[i] &gt; dp[j] + dp[i ^ j])) dp[i] = dp[j] + dp[i ^ j];
	printf(&quot;%d\n&quot;, dp[all - 1]);
	return 0;
}<pre><h2>Problem4012</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 150003
#define MS 6000005

struct edge {int t, w; edge *n;} me[N&lt;&lt;1|1], *g[N], *ce = me;
#define adde(a, b, c) (*ce = (edge){b, c, g[a]}, g[a] = ce++)

typedef int arr[N];
arr fa, tp, son, sz, in, dis, fd, ud, c1, a;
int dfn;
long long c2[N];

void d1(int u) {
	sz[u] = 1;
	++c1[a[u]];
	c2[a[u]] += dis[u];
	for (edge *it = g[u]; it; it = it-&gt;n)
		if (it-&gt;t ^ fa[u]) {
			fa[it-&gt;t] = u;
			//dep[it-&gt;t] = dep[u] + 1;
			dis[it-&gt;t] = dis[u] + it-&gt;w;
			d1(it-&gt;t);
			if (sz[it-&gt;t] &gt; sz[son[u]])
				son[u] = it-&gt;t;
			sz[u] += sz[it-&gt;t];
		}
}

void d2(int u, int anc) {
	tp[u] = anc;
	in[u] = ++dfn;
	ud[dfn] = dis[u];
	fd[dfn] = dis[fa[u]];
	if (son[u]) d2(son[u], anc);
	for (edge *it = g[u]; it; it = it-&gt;n)
		if (!in[it-&gt;t])
			d2(it-&gt;t, it-&gt;t);
}

struct SegNode {
	int add;
	long long sum;
	SegNode *ls, *rs;
} SegMst[MS], *SegIt = SegMst, *rt[N];

void Insert(SegNode *x, SegNode * &amp;y, int l, int r, const int &amp;qx, const int &amp;qy) {
	*(y = ++SegIt) = *x;
	if (qx &lt;= l &amp;&amp; r &lt;= qy) {
		y-&gt;sum += ud[r] - fd[l];
		++y-&gt;add;
		return;
	}
	int m = l + r &gt;&gt; 1;
	if (qx &lt;= m) Insert(x-&gt;ls, y-&gt;ls, l, m, qx, qy);
	if (qy &gt; m) Insert(x-&gt;rs, y-&gt;rs, m + 1, r, qx, qy);
	y-&gt;sum = y-&gt;ls-&gt;sum + y-&gt;rs-&gt;sum + (long long)y-&gt;add * (ud[r] - fd[l]);
}

void Query(SegNode *x, SegNode *y, int l, int r, const int &amp;qx, const int &amp;qy, long long &amp;v) {
	static int _x = 0, _y = 0;
	if (qx &lt;= l &amp;&amp; r &lt;= qy) {
		v += y-&gt;sum - x-&gt;sum + (long long)(_y - _x) * (ud[r] - fd[l]);
		return;
	}
	int m = l + r &gt;&gt; 1;
	_x += x-&gt;add, _y += y-&gt;add;
	if (qx &lt;= m) Query(x-&gt;ls, y-&gt;ls, l, m, qx, qy, v);
	if (qy &gt; m) Query(x-&gt;rs, y-&gt;rs, m + 1, r, qx, qy, v);
	_x -= x-&gt;add, _y -= y-&gt;add;
}

void modify(int u, int age) {
	while (u) {
		Insert(rt[age], rt[age], 1, dfn, in[tp[u]], in[u]);
		u = fa[tp[u]];
	}
}

int ha[N], hcnt;
pair &lt;int, int&gt; pr[N];


int main() {
	//freopen(&quot;shop_hnoi2015.in&quot;, &quot;r&quot;, stdin);
	//freopen(&quot;shop_hnoi2015.out&quot;, &quot;w&quot;, stdout);
	int n, q, A, i, l, r, u, v, aa, bb;
	long long ans, t;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;q, &amp;A);
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, a + i);
		ha[i] = a[i];
	}
	ha[hcnt = n + 1] = A + 1;
	sort(ha + 1, ha + hcnt + 1);
	hcnt = unique(ha + 1, ha + hcnt + 1) - ha - 1;
	for (i = 1; i &lt;= n; ++i) {
		a[i] = lower_bound(ha + 1, ha + hcnt + 1, a[i]) - ha;
		pr[i] = make_pair(a[i], i);
	}
	for (i = 1; i &lt; n; ++i) {
		scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;aa);
		adde(u, v, aa);
		adde(v, u, aa);
	}
	d1(1);
	d2(1, 1);
	for (i = 1; i &lt;= hcnt; ++i) {
		c1[i] += c1[i - 1];
		c2[i] += c2[i - 1];
	}
	*rt = SegIt;
	**rt = (SegNode) {0, 0LL, *rt, *rt};
	sort(pr + 1, pr + n + 1);
	for (i = 1; i &lt;= n; ++i) {
		if (pr[i].first ^ pr[i - 1].first)
			rt[pr[i].first] = rt[pr[i - 1].first];
		modify(pr[i].second, pr[i].first);
	}
	rt[hcnt] = rt[hcnt - 1];

	//for (i = 1; i &lt;= hcnt; ++i)
	//	printf(&quot;%lld &quot;, rt[i]-&gt;sum);
	//puts(&quot;&quot;);
	
	ans = 0;
	while (q--) {
		scanf(&quot;%d%d%d&quot;, &amp;u, &amp;aa, &amp;bb);
		l = (aa + ans) % A;
		r = (bb + ans) % A;
		if (r &lt; l) l ^= r ^= l ^= r;
		l = lower_bound(ha + 1, ha + hcnt + 1, l) - ha - 1;
		r = upper_bound(ha + 1, ha + hcnt + 1, r) - ha - 1;
		ans = c2[r] - c2[l] + (c1[r] - c1[l]) * (long long)dis[u];
		for (t = 0; u; u = fa[tp[u]])
			Query(rt[l], rt[r], 1, n, in[tp[u]], in[u], t);
		ans -= t &lt;&lt; 1;
		printf(&quot;%lld\n&quot;, ans);
	}
	return 0;
}<pre><h2>Problem4016</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 30010;
typedef pair&lt;int, int&gt;pii;
vector&lt; pii &gt; G[N];
int n, m, mv, cnt, rt, siz, K, frt, s[N], f[2][N], g[2][N], d[N];
bool vis[N];
struct edge{int to, w; edge *nt;} *hd[N], ME[N &lt;&lt; 1], *ce = ME;
void adde(int a, int b, int c) {
	ce-&gt;to = b;
	ce-&gt;nt = hd[a];
	ce-&gt;w = c;
	hd[a] = ce++;
}
priority_queue&lt; pii, vector &lt; pii &gt;, greater &lt; pii &gt; &gt;heap;
void dijstra() {
	memset(d, 127, sizeof d);
	heap.push(make_pair(d[1] = 0, 1));
	int u, dis, w, v, i;
	while (!heap.empty()) {
		u = heap.top().second;
		dis = heap.top().first;
		heap.pop();
		if (dis ^ d[u]) continue;
		sort(G[u].begin(), G[u].end());
		for (i = 0; i &lt; G[u].size(); ++i) {
			v = G[u][i].first;
			w = G[u][i].second;
			if (d[v] &gt; dis + w)
				heap.push(make_pair(d[v] = dis + w, v));
		}
	}
}
void build(int u) {
	int v, i;
	vis[u] = true;
	for (i = 0; i &lt; G[u].size(); ++i)
		if (!vis[v = G[u][i].first] &amp;&amp; d[v] == d[u] + G[u][i].second) {
			adde(v, u, G[u][i].second);
			adde(u, v, G[u][i].second);
			build(v);
		}
}
void grt(int u,int fa) {
	int mx = 0, v;
	s[u] = 1;
	for (edge*it = hd[u]; it; it = it-&gt;nt) {
		v = it-&gt;to;
		if (vis[v] || v == fa) continue;
		grt(v, u);
		s[u] += s[v];
		if (s[v] &gt; mx) mx = s[v];
	}
	if (siz - mx &gt; mx) mx = siz - mx;
	if (mx &lt; frt) rt = u, frt = mx;
}
void dfs(int u,int fa, int dep) {
	if (dep &gt; K) return;
	if (d[u] &gt; g[0][dep]) g[0][dep] = d[u], g[1][dep] = 0;
	if (d[u] &gt;= g[0][dep]) ++g[1][dep];
	int v;
	for (edge*it = hd[u]; it; it = it-&gt;nt) {
		v = it-&gt;to;
		if (vis[v] || v == fa) continue;
		d[v] = d[u] + it-&gt;w;
		dfs(v, u, dep + 1);
	}
}
void solve(int u) {
	int v, i, j;
	vis[u] = true;
	f[0][0] = 0;
	f[1][0] = 1;
	for (edge*it = hd[u]; it; it = it-&gt;nt)
		if (!vis[it-&gt;to]) {
			v = it-&gt;to;
			d[v] = it-&gt;w;
			dfs(v, u, 1);
			for (j = 1; j &lt;= K; ++j) {
				if (g[0][j] + f[0][K-j] &gt; mv) mv = g[0][j] + f[0][K - j], cnt = 0;
				if (g[0][j] + f[0][K-j] &gt;= mv)  cnt += g[1][j] * f[1][K-j];
			}
			for (j = 1; j &lt;= K; ++j) {
				if (g[0][j] &gt; f[0][j]) f[0][j] = g[0][j], f[1][j] = 0;
				if (g[0][j] &gt;= f[0][j]) f[1][j] += g[1][j];
				g[0][j] = g[1][j] = 0;
			}
		}
	for (i = 0; i &lt;= K; ++i) f[0][i] = f[1][i] = 0;
	for (edge*it = hd[u]; it; it = it-&gt;nt)
		if (!vis[it-&gt;to]){
			v = it-&gt;to;
			frt = siz = s[v];
			rt = 0;
			grt(v, u);
			if (s[v] &gt; K) solve(rt);
		}
}
int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;K);
	--K;
	for (int a, b, c; m; --m) {
		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
		G[a].push_back(make_pair(b, c));
		G[b].push_back(make_pair(a, c));
	}
	dijstra();
	build(1);
	memset(vis, 0, sizeof vis);
	frt = siz = n;
	rt = 0;
	grt(1, 0);
	solve(rt);
	printf(&quot;%d %d\n&quot;, mv, cnt);
	return 0;
}
<pre><h2>Problem4020</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
int mem[10000007], *mp = mem;
char buf[10007], *ptr = buf;
char stk[10007];
int stp = 0;
map&lt;string, int&gt; ops, kws, vars;
int vid = 0;
int rk[28] = {100, 100, 101, 101, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 9, 10, 11, 12, 12, 13, 14};
int rka[28];
struct token
{
	int tp; //operator:0 integer:1 var_name:2 keyword:3
	int v;
	void init2()
	{
		tp = 2;
		string a(stk);
		if (kws.find(a) != kws.end())
		{
			tp = 3;
			v = kws[a];
		}
		else if (vars.find(a) != vars.end())
		{
			v = vars[a];
		}
		else
		{
			v = vars[a] = ++vid;
		}
	}
	void init1(int x)
	{
		tp = 1;
		v = x;
	}
	void init0()
	{
		tp = 0;
		v = ops[string(stk)];
		if ((v == 7 || v == 8) &amp;&amp; (this[-1].tp == 1 || this[-1].tp == 2 || this[-1].eq(0, 1) || this[-1].eq(0, 3)))
			v += 5;
	}
	bool eq(int a, int b)
	{
		return tp == a &amp;&amp; v == b;
	}
} ts[7007];
int tp = 0, tptr = 0;
bool isname(char x)
{
	return isalpha(x) || isdigit(x) || x == '_' || x == '$';
}
int _n, __in[10007], _inp = 0;
int _ri()
{
	int x = 0, f = 1;
	while (!isdigit(*ptr))
		*ptr++ == '-' ? f = -1 : 0;
	while (isdigit(*ptr))
		x = x * 10 + *ptr++ - 48;
	return x * f;
}
void pre()
{
	_n = _ri();
	for (int i = 0; i &lt; _n; ++i)
		__in[i] = _ri();
	for (; *ptr != ';'; ++ptr)
		;
	++ptr;
	while (1)
	{
		for (; *ptr != -1 &amp;&amp; *ptr &lt; 33; ++ptr)
			;
		if (*ptr == -1)
			break;
		stp = 0;
		if (isalpha(*ptr))
		{
			for (; isname(*ptr); stk[stp++] = *ptr++)
				;
			stk[stp] = 0;
			ts[tp++].init2();
		}
		else if (isdigit(*ptr))
		{
			ts[tp++].init1(_ri());
		}
		else
		{
			stk[stp++] = *ptr++;
			stk[1] = *ptr;
			stk[2] = 0;
			if (ops.find(string(stk)) != ops.end())
				++ptr;
			else
				stk[1] = 0;
			ts[tp].init0();
			++tp;
		}
	}
}
#define ptr __
struct var
{
	int id, *dat, sz;
	vector&lt;int&gt; dsz;
	var() { sz = 1, id = 0; }
	void newdim(int x)
	{
		dsz.push_back(x);
		sz *= x;
	}
};
vector&lt;var&gt; var_now[7007];
struct varlist
{
	std::vector&lt;var&gt; vs;
	void def(bool init = 1)
	{
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var &amp;w = vs[i];
			if (init)
				memset(mp, 0, sizeof(int) * w.sz);
			w.dat = mp, mp += w.sz;
			var_now[w.id].push_back(w);
		}
	}
	void defs()
	{
		int mx = *--mp;
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var &amp;w = vs[i];
			memset(mp, 0, sizeof(int) * w.sz);
			w.dat = mp, mp += w.sz;
			var_now[w.id].push_back(w);
		}
		*mp++ = mx + vs.size();
	}
	void undef()
	{
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var_now[vs[i].id].pop_back();
			mp -= vs[i].sz;
		}
	}
	void undefs()
	{
		int mx = *--mp;
		for (int i = 0; i &lt; mx; ++i)
		{
			var_now[vs[i].id].pop_back();
			mp -= vs[i].sz;
		}
	}
	void ins(int id)
	{
		var w;
		w.id = id;
		vs.push_back(w);
	}
	void R()
	{
		var w;
		w.id = ts[tptr++].v;
		for (; ts[tptr].eq(0, 2); tptr += 3)
			w.newdim(ts[tptr + 1].v);
		vs.push_back(w);
	}
	void Rs()
	{
		for (++tptr;;)
		{
			R();
			if (ts[tptr++].v == 27)
				break;
		}
	}
} glob_var;
struct node
{
	int tp, v;
	varlist vs;
	vector&lt;node&gt; rs;
	node &amp;rspb()
	{
		rs.push_back(node());
		return rs.back();
	}
	void Rvar() { tp = 7, v = ts[tptr++].v; }
	void Rint() { tp = 8, v = ts[tptr++].v; }
	void setop(int w) { tp = 10, v = w; }
	void Rcall()
	{
		tp = 9;
		v = ts[tptr].v;
		tptr += 2;
		while (!ts[tptr - 1].eq(0, 1))
			rspb().Rexpr();
	}
	void setvdim(int L, int R, varlist &amp;w)
	{
		tp = 13;
		for (int i = L; i &lt; R; ++i)
			vs.vs.push_back(w.vs[i]);
	}
	void Rexpr()
	{
		tp = 2;
		vector&lt;int&gt; ops;
		ops.push_back(0);
		while (1)
		{
			if (ts[tptr].tp == 0)
			{ //oper
				if (ts[tptr].v &gt;= 26)
				{
					while (ops.back())
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					break;
				}
				int v = ts[tptr].v;
				if (v == 0 || v == 2)
					ops.push_back(v);
				else if (v == 1)
				{
					while (ops.back())
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					ops.pop_back();
					if (ops.empty())
						break;
				}
				else if (v == 3)
				{
					int c;
					do
					{
						c = ops.back();
						rspb().setop(c);
						ops.pop_back();
					} while (c != 2);
				}
				else
				{
					while (ops.back()[rk] + v[rka] &lt;= v[rk])
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					ops.push_back(v);
				}
				++tptr;
			}
			else if (ts[tptr].tp == 1)
				rspb().Rint(); //int
			else if (ts[tptr + 1].eq(0, 0))
				rspb().Rcall(); //call func
			else
				rspb().Rvar(); //var
		}
		++tptr;
	}
	void Rkw()
	{
		if (ts[tptr].v == 0)
		{ //if
			tp = 3;
			tptr += 2;
			rspb().Rexpr();
			rspb().Rblock();
			if (ts[tptr].eq(3, 1))
			{ //else
				++tptr;
				rspb().Rblock();
			}
		}
		else if (ts[tptr].v == 2)
		{ //while
			tp = 4;
			tptr += 2;
			rspb().Rexpr();
			rspb().Rblock();
		}
		else if (ts[tptr].v == 3)
		{ //for
			tp = 5;
			tptr += 2;
			rspb();
			if (ts[tptr].eq(3, 4))
				vs.Rs(), rs.back().tp = 12;
			else
				rs.back().Rexpr();
			rspb().Rexpr();
			rspb().Rexpr();
			rspb().Rblock();
		}
		else
		{ //return
			tp = 6;
			++tptr;
			rspb().Rexpr();
		}
	}
	void Rblock()
	{
		if (!ts[tptr].eq(0, 4))
		{
			if (ts[tptr].tp == 3)
				Rkw();
			else
				Rexpr();
			return;
		}
		tp = 1;
		++tptr;
		while (!ts[tptr].eq(0, 5))
		{
			if (ts[tptr].tp == 3)
			{
				if (ts[tptr].v == 4)
				{
					int L = vs.vs.size();
					vs.Rs();
					int R = vs.vs.size();
					rspb().setvdim(L, R, vs);
				}
				else
					rspb().Rkw();
			}
			else
				rspb().Rblock();
		}
		++tptr;
	}
	void Rfunc()
	{
		tp = 0;
		tptr += 3;
		if (ts[tptr].eq(0, 1))
			++tptr;
		else
			do
			{
				++tptr;
				vs.R();
			} while (!ts[tptr++].eq(0, 1));
		rspb().Rblock();
	}
} funcs[7007];
#define run(x) _runs[x.tp](x)
int (*_runs[30])(node &amp;);
void (*_ops[30])();
bool ret_flag = 0;
int _func(node &amp;w)
{
	w.vs.def(0);
	int r = run(w.rs[0]);
	w.vs.undef();
	ret_flag = 0;
	void push(int);
	push(r);
	return r;
}
int _block(node &amp;w)
{
	*mp++ = 0;
	int r = 0;
	for (int i = 0; i &lt; w.rs.size() &amp;&amp; !ret_flag; ++i)
		r = run(w.rs[i]);
	w.vs.undefs();
	return r;
}
int _expr(node &amp;w)
{
	if (w.rs.empty())
		return 1;
	for (int i = 0; i &lt; w.rs.size(); ++i)
		run(w.rs[i]);
	int &amp;pop();
	return pop();
}
int _if(node &amp;w)
{
	int r = 0;
	if (run(w.rs[0]))
		r = run(w.rs[1]);
	else if (w.rs.size() == 3)
		r = run(w.rs[2]);
	return r;
}
int _while(node &amp;w)
{
	int r = 0;
	while (!ret_flag &amp;&amp; run(w.rs[0]))
		r = run(w.rs[1]);
	return r;
}
int _for(node &amp;w)
{
	int r = 0;
	w.vs.def();
	for (run(w.rs[0]); !ret_flag &amp;&amp; run(w.rs[1]); run(w.rs[2]))
		r = run(w.rs[3]);
	w.vs.undef();
	return r;
}
int _ret(node &amp;w)
{
	int r = run(w.rs[0]);
	ret_flag = 1;
	return r;
}
int _var(node &amp;w)
{
	mp[0] = w.v;
	mp[1] = 0;
	mp[2] = 0;
	mp += 3;
}
void push(int x)
{
	mp[0] = -1;
	mp[1] = x;
	mp[2] = 0;
	mp += 3;
}
int _int(node &amp;w)
{
	push(w.v);
}
int _nod(node &amp;w) {}
int _call(node &amp;w)
{
	for (int i = 0; i &lt; w.rs.size(); ++i)
	{
		int r = run(w.rs[i]);
		*mp++ = r;
	}
	mp -= w.rs.size();
	return run(funcs[w.v]);
}
int &amp;pop()
{
	mp -= 3;
	return *mp &lt; 0 ? mp[1] : var_now[*mp].back().dat[mp[2]];
}
void _arr()
{
	int x = pop();
	mp[-1] *= var_now[mp[-3]].back().dsz[mp[-2]++];
	mp[-1] += x;
}
void _not() { push(!pop()); }
void _pos() { push(pop()); }
void _neg() { push(-pop()); }

void _or()
{
	int b = pop(), a = pop();
	push(a || b);
}
void _and()
{
	int b = pop(), a = pop();
	push(a &amp;&amp; b);
}
void _xor()
{
	int b = pop(), a = pop();
	push(!a + !b == 1);
}
void _neq()
{
	int b = pop(), a = pop();
	push(a != b);
}
void _eq()
{
	int b = pop(), a = pop();
	push(a == b);
}
void _lss()
{
	int b = pop(), a = pop();
	push(a &lt; b);
}
void _mre()
{
	int b = pop(), a = pop();
	push(a &gt; b);
}
void _meq()
{
	int b = pop(), a = pop();
	push(a &gt;= b);
}
void _leq()
{
	int b = pop(), a = pop();
	push(a &lt;= b);
}
void _mul()
{
	push(pop() * pop());
}
void _div()
{
	int b = pop(), a = pop();
	push(a / b);
}
void _mod()
{
	int b = pop(), a = pop();
	push(a % b);
}
void _sub()
{
	int b = pop(), a = pop();
	push(a - b);
}
void _add()
{
	int b = pop(), a = pop();
	push(a + b);
}

void _set()
{
	int b = pop();
	pop() = b;
	push(b);
}
void _in()
{
	pop() = __in[_inp++];
}
void _out()
{
	int x = pop();
	if (mp[0] == 3)
		puts(&quot;&quot;);
	else
		printf(&quot;%d&quot;, x);
}
int _op(node &amp;w)
{
	_ops[w.v]();
}
int _vdim(node &amp;w)
{
	w.vs.defs();
}
int _pc(node &amp;w)
{
	int c = *mp;
	putchar(c);
	push(c);
	return c;
}
void pre2()
{
	while (tptr &lt; tp)
	{
		if (ts[tptr + 2].tp == 0 &amp;&amp; ts[tptr + 2].v == 0)
			funcs[ts[tptr + 1].v].Rfunc();
		else
			glob_var.Rs();
	}
}
int main()
{
	_runs[0] = _func;
	_runs[1] = _block;
	_runs[2] = _expr;
	_runs[3] = _if;
	_runs[4] = _while;
	_runs[5] = _for;
	_runs[6] = _ret;
	_runs[7] = _var;
	_runs[8] = _int;
	_runs[9] = _call;
	_runs[10] = _op;
	_runs[11] = _pc;
	_runs[12] = _nod;
	_runs[13] = _vdim;
	_ops[2] = _arr;
	_ops[6] = _not;
	_ops[7] = _pos;
	_ops[8] = _neg;
	_ops[9] = _mul;
	_ops[10] = _div;
	_ops[11] = _mod;
	_ops[12] = _add;
	_ops[13] = _sub;
	_ops[14] = _leq;
	_ops[15] = _meq;
	_ops[16] = _lss;
	_ops[17] = _mre;
	_ops[18] = _eq;
	_ops[19] = _neq;
	_ops[20] = _xor;
	_ops[21] = _and;
	_ops[22] = _or;
	_ops[23] = _set;
	_ops[24] = _out;
	_ops[25] = _in;
	rka[6] = rka[7] = rka[8] = rka[23] = 1;
	ops[&quot;(&quot;] = 0;
	ops[&quot;)&quot;] = 1;
	ops[&quot;[&quot;] = 2;
	ops[&quot;]&quot;] = 3;
	ops[&quot;{&quot;] = 4;
	ops[&quot;}&quot;] = 5;
	ops[&quot;!&quot;] = 6;
	ops[&quot;+&quot;] = 7;
	ops[&quot;-&quot;] = 8;
	ops[&quot;*&quot;] = 9;
	ops[&quot;/&quot;] = 10;
	ops[&quot;%&quot;] = 11;
	ops[&quot;&lt;=&quot;] = 14;
	ops[&quot;&gt;=&quot;] = 15;
	ops[&quot;&lt;&quot;] = 16;
	ops[&quot;&gt;&quot;] = 17;
	ops[&quot;==&quot;] = 18;
	ops[&quot;!=&quot;] = 19;
	ops[&quot;^&quot;] = 20;
	ops[&quot;&amp;&amp;&quot;] = 21;
	ops[&quot;||&quot;] = 22;
	ops[&quot;=&quot;] = 23;
	ops[&quot;&lt;&lt;&quot;] = 24;
	ops[&quot;&gt;&gt;&quot;] = 25;
	ops[&quot;,&quot;] = 26;
	ops[&quot;;&quot;] = 27;
	kws[&quot;if&quot;] = 0;
	kws[&quot;else&quot;] = 1;
	kws[&quot;while&quot;] = 2;
	kws[&quot;for&quot;] = 3;
	kws[&quot;int&quot;] = 4;
	kws[&quot;return&quot;] = 5;
	vars[&quot;cin&quot;] = ++vid;
	vars[&quot;cout&quot;] = ++vid;
	vars[&quot;endl&quot;] = ++vid;
	funcs[vars[&quot;putchar&quot;] = ++vid].tp = 11;
	fread(buf, 1, sizeof(buf), stdin)[buf] = -1;
	pre();
	pre2();
	glob_var.ins(1);
	glob_var.ins(2);
	glob_var.ins(3);
	glob_var.def();
	run(funcs[vars[&quot;main&quot;]]);
	return 0;
}<pre><h2>Problem4020</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
int mem[10000001], *mp = mem;
char buf[10001], *ptr = buf;
char stk[10001];
int stp = 0;
map&lt;string, int&gt; ops, kws, vars;
int vid = 0;
int rk[28] = {100, 100, 101, 101, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 9, 10, 11, 12, 12, 13, 14};
int rka[28];
struct token
{
	int tp; //operator:0 integer:1 var_name:2 keyword:3
	int v;
	void init2()
	{
		tp = 2;
		string a(stk);
		if (kws.find(a) != kws.end())
		{
			tp = 3;
			v = kws[a];
		}
		else if (vars.find(a) != vars.end())
		{
			v = vars[a];
		}
		else
		{
			v = vars[a] = ++vid;
		}
	}
	void init1(int x)
	{
		tp = 1;
		v = x;
	}
	void init0()
	{
		tp = 0;
		v = ops[string(stk)];
		if ((v == 7 || v == 8) &amp;&amp; (this[-1].tp == 1 || this[-1].tp == 2 || this[-1].eq(0, 1) || this[-1].eq(0, 3)))
			v += 5;
	}
	bool eq(int a, int b)
	{
		return tp == a &amp;&amp; v == b;
	}
} ts[7007];
int tp = 0, tptr = 0;
bool isname(char x)
{
	return isalpha(x) || isdigit(x) || x == '_' || x == '$';
}
int _n, __in[10007], _inp = 0;
int _ri()
{
	int x = 0, f = 1;
	while (!isdigit(*ptr))
		*ptr++ == '-' ? f = -1 : 0;
	while (isdigit(*ptr))
		x = x * 10 + *ptr++ - 48;
	return x * f;
}
void pre()
{
	_n = _ri();
	for (int i = 0; i &lt; _n; ++i)
		__in[i] = _ri();
	for (; *ptr != ';'; ++ptr)
		;
	++ptr;
	while (1)
	{
		for (; *ptr != -1 &amp;&amp; *ptr &lt; 33; ++ptr)
			;
		if (*ptr == -1)
			break;
		stp = 0;
		if (isalpha(*ptr))
		{
			for (; isname(*ptr); stk[stp++] = *ptr++)
				;
			stk[stp] = 0;
			ts[tp++].init2();
		}
		else if (isdigit(*ptr))
		{
			ts[tp++].init1(_ri());
		}
		else
		{
			stk[stp++] = *ptr++;
			stk[1] = *ptr;
			stk[2] = 0;
			if (ops.find(string(stk)) != ops.end())
				++ptr;
			else
				stk[1] = 0;
			ts[tp].init0();
			++tp;
		}
	}
}
#define ptr __
struct var
{
	int id, *dat, sz;
	vector&lt;int&gt; dsz;
	var() { sz = 1, id = 0; }
	void newdim(int x)
	{
		dsz.push_back(x);
		sz *= x;
	}
};
vector&lt;var&gt; var_now[7007];
struct varlist
{
	std::vector&lt;var&gt; vs;
	void def(bool init = 1)
	{
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var &amp;w = vs[i];
			if (init)
				memset(mp, 0, sizeof(int) * w.sz);
			w.dat = mp, mp += w.sz;
			var_now[w.id].push_back(w);
		}
	}
	void defs()
	{
		int mx = *--mp;
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var &amp;w = vs[i];
			memset(mp, 0, sizeof(int) * w.sz);
			w.dat = mp, mp += w.sz;
			var_now[w.id].push_back(w);
		}
		*mp++ = mx + vs.size();
	}
	void undef()
	{
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var_now[vs[i].id].pop_back();
			mp -= vs[i].sz;
		}
	}
	void undefs()
	{
		int mx = *--mp;
		for (int i = 0; i &lt; mx; ++i)
		{
			var_now[vs[i].id].pop_back();
			mp -= vs[i].sz;
		}
	}
	void ins(int id)
	{
		var w;
		w.id = id;
		vs.push_back(w);
	}
	void R()
	{
		var w;
		w.id = ts[tptr++].v;
		for (; ts[tptr].eq(0, 2); tptr += 3)
			w.newdim(ts[tptr + 1].v);
		vs.push_back(w);
	}
	void Rs()
	{
		for (++tptr;;)
		{
			R();
			if (ts[tptr++].v == 27)
				break;
		}
	}
} glob_var;
struct node
{
	int tp, v;
	varlist vs;
	vector&lt;node&gt; rs;
	node &amp;rspb()
	{
		rs.push_back(node());
		return rs.back();
	}
	void Rvar() { tp = 7, v = ts[tptr++].v; }
	void Rint() { tp = 8, v = ts[tptr++].v; }
	void setop(int w) { tp = 10, v = w; }
	void Rcall()
	{
		tp = 9;
		v = ts[tptr].v;
		tptr += 2;
		while (!ts[tptr - 1].eq(0, 1))
			rspb().Rexpr();
	}
	void setvdim(int L, int R, varlist &amp;w)
	{
		tp = 13;
		for (int i = L; i &lt; R; ++i)
			vs.vs.push_back(w.vs[i]);
	}
	void Rexpr()
	{
		tp = 2;
		vector&lt;int&gt; ops;
		ops.push_back(0);
		while (1)
		{
			if (ts[tptr].tp == 0)
			{ //oper
				if (ts[tptr].v &gt;= 26)
				{
					while (ops.back())
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					break;
				}
				int v = ts[tptr].v;
				if (v == 0 || v == 2)
					ops.push_back(v);
				else if (v == 1)
				{
					while (ops.back())
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					ops.pop_back();
					if (ops.empty())
						break;
				}
				else if (v == 3)
				{
					int c;
					do
					{
						c = ops.back();
						rspb().setop(c);
						ops.pop_back();
					} while (c != 2);
				}
				else
				{
					while (ops.back()[rk] + v[rka] &lt;= v[rk])
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					ops.push_back(v);
				}
				++tptr;
			}
			else if (ts[tptr].tp == 1)
				rspb().Rint(); //int
			else if (ts[tptr + 1].eq(0, 0))
				rspb().Rcall(); //call func
			else
				rspb().Rvar(); //var
		}
		++tptr;
	}
	void Rkw()
	{
		if (ts[tptr].v == 0)
		{ //if
			tp = 3;
			tptr += 2;
			rspb().Rexpr();
			rspb().Rblock();
			if (ts[tptr].eq(3, 1))
			{ //else
				++tptr;
				rspb().Rblock();
			}
		}
		else if (ts[tptr].v == 2)
		{ //while
			tp = 4;
			tptr += 2;
			rspb().Rexpr();
			rspb().Rblock();
		}
		else if (ts[tptr].v == 3)
		{ //for
			tp = 5;
			tptr += 2;
			rspb();
			if (ts[tptr].eq(3, 4))
				vs.Rs(), rs.back().tp = 12;
			else
				rs.back().Rexpr();
			rspb().Rexpr();
			rspb().Rexpr();
			rspb().Rblock();
		}
		else
		{ //return
			tp = 6;
			++tptr;
			rspb().Rexpr();
		}
	}
	void Rblock()
	{
		if (!ts[tptr].eq(0, 4))
		{
			if (ts[tptr].tp == 3)
				Rkw();
			else
				Rexpr();
			return;
		}
		tp = 1;
		++tptr;
		while (!ts[tptr].eq(0, 5))
		{
			if (ts[tptr].tp == 3)
			{
				if (ts[tptr].v == 4)
				{
					int L = vs.vs.size();
					vs.Rs();
					int R = vs.vs.size();
					rspb().setvdim(L, R, vs);
				}
				else
					rspb().Rkw();
			}
			else
				rspb().Rblock();
		}
		++tptr;
	}
	void Rfunc()
	{
		tp = 0;
		tptr += 3;
		if (ts[tptr].eq(0, 1))
			++tptr;
		else
			do
			{
				++tptr;
				vs.R();
			} while (!ts[tptr++].eq(0, 1));
		rspb().Rblock();
	}
} funcs[7007];
#define run(x) _runs[x.tp](x)
int (*_runs[30])(node &amp;);
void (*_ops[30])();
bool ret_flag = 0;
int _func(node &amp;w)
{
	w.vs.def(0);
	int r = run(w.rs[0]);
	w.vs.undef();
	ret_flag = 0;
	void push(int);
	push(r);
	return r;
}
int _block(node &amp;w)
{
	*mp++ = 0;
	int r = 0;
	for (int i = 0; i &lt; w.rs.size() &amp;&amp; !ret_flag; ++i)
		r = run(w.rs[i]);
	w.vs.undefs();
	return r;
}
int _expr(node &amp;w)
{
	if (w.rs.empty())
		return 1;
	for (int i = 0; i &lt; w.rs.size(); ++i)
		run(w.rs[i]);
	int &amp;pop();
	return pop();
}
int _if(node &amp;w)
{
	int r = 0;
	if (run(w.rs[0]))
		r = run(w.rs[1]);
	else if (w.rs.size() == 3)
		r = run(w.rs[2]);
	return r;
}
int _while(node &amp;w)
{
	int r = 0;
	while (!ret_flag &amp;&amp; run(w.rs[0]))
		r = run(w.rs[1]);
	return r;
}
int _for(node &amp;w)
{
	int r = 0;
	w.vs.def();
	for (run(w.rs[0]); !ret_flag &amp;&amp; run(w.rs[1]); run(w.rs[2]))
		r = run(w.rs[3]);
	w.vs.undef();
	return r;
}
int _ret(node &amp;w)
{
	int r = run(w.rs[0]);
	ret_flag = 1;
	return r;
}
int _var(node &amp;w)
{
	mp[0] = w.v;
	mp[1] = 0;
	mp[2] = 0;
	mp += 3;
}
void push(int x)
{
	mp[0] = -1;
	mp[1] = x;
	mp[2] = 0;
	mp += 3;
}
int _int(node &amp;w)
{
	push(w.v);
}
int _nod(node &amp;w) {}
int _call(node &amp;w)
{
	for (int i = 0; i &lt; w.rs.size(); ++i)
	{
		int r = run(w.rs[i]);
		*mp++ = r;
	}
	mp -= w.rs.size();
	return run(funcs[w.v]);
}
int &amp;pop()
{
	mp -= 3;
	return *mp &lt; 0 ? mp[1] : var_now[*mp].back().dat[mp[2]];
}
void _arr()
{
	int x = pop();
	mp[-1] *= var_now[mp[-3]].back().dsz[mp[-2]++];
	mp[-1] += x;
}
void _not() { push(!pop()); }
void _pos() { push(pop()); }
void _neg() { push(-pop()); }

void _or()
{
	int b = pop(), a = pop();
	push(a || b);
}
void _and()
{
	int b = pop(), a = pop();
	push(a &amp;&amp; b);
}
void _xor()
{
	int b = pop(), a = pop();
	push(!a + !b == 1);
}
void _neq()
{
	int b = pop(), a = pop();
	push(a != b);
}
void _eq()
{
	int b = pop(), a = pop();
	push(a == b);
}
void _lss()
{
	int b = pop(), a = pop();
	push(a &lt; b);
}
void _mre()
{
	int b = pop(), a = pop();
	push(a &gt; b);
}
void _meq()
{
	int b = pop(), a = pop();
	push(a &gt;= b);
}
void _leq()
{
	int b = pop(), a = pop();
	push(a &lt;= b);
}
void _mul()
{
	push(pop() * pop());
}
void _div()
{
	int b = pop(), a = pop();
	push(a / b);
}
void _mod()
{
	int b = pop(), a = pop();
	push(a % b);
}
void _sub()
{
	int b = pop(), a = pop();
	push(a - b);
}
void _add()
{
	int b = pop(), a = pop();
	push(a + b);
}

void _set()
{
	int b = pop();
	pop() = b;
	push(b);
}
void _in()
{
	pop() = __in[_inp++];
}
void _out()
{
	int x = pop();
	if (mp[0] == 3)
		puts(&quot;&quot;);
	else
		printf(&quot;%d&quot;, x);
}
int _op(node &amp;w)
{
	_ops[w.v]();
}
int _vdim(node &amp;w)
{
	w.vs.defs();
}
int _pc(node &amp;w)
{
	int c = *mp;
	putchar(c);
	push(c);
	return c;
}
void pre2()
{
	while (tptr &lt; tp)
	{
		if (ts[tptr + 2].tp == 0 &amp;&amp; ts[tptr + 2].v == 0)
			funcs[ts[tptr + 1].v].Rfunc();
		else
			glob_var.Rs();
	}
}
int main()
{
	_runs[0] = _func;
	_runs[1] = _block;
	_runs[2] = _expr;
	_runs[3] = _if;
	_runs[4] = _while;
	_runs[5] = _for;
	_runs[6] = _ret;
	_runs[7] = _var;
	_runs[8] = _int;
	_runs[9] = _call;
	_runs[10] = _op;
	_runs[11] = _pc;
	_runs[12] = _nod;
	_runs[13] = _vdim;
	_ops[2] = _arr;
	_ops[6] = _not;
	_ops[7] = _pos;
	_ops[8] = _neg;
	_ops[9] = _mul;
	_ops[10] = _div;
	_ops[11] = _mod;
	_ops[12] = _add;
	_ops[13] = _sub;
	_ops[14] = _leq;
	_ops[15] = _meq;
	_ops[16] = _lss;
	_ops[17] = _mre;
	_ops[18] = _eq;
	_ops[19] = _neq;
	_ops[20] = _xor;
	_ops[21] = _and;
	_ops[22] = _or;
	_ops[23] = _set;
	_ops[24] = _out;
	_ops[25] = _in;
	rka[6] = rka[7] = rka[8] = rka[23] = 1;
	ops[&quot;(&quot;] = 0;
	ops[&quot;)&quot;] = 1;
	ops[&quot;[&quot;] = 2;
	ops[&quot;]&quot;] = 3;
	ops[&quot;{&quot;] = 4;
	ops[&quot;}&quot;] = 5;
	ops[&quot;!&quot;] = 6;
	ops[&quot;+&quot;] = 7;
	ops[&quot;-&quot;] = 8;
	ops[&quot;*&quot;] = 9;
	ops[&quot;/&quot;] = 10;
	ops[&quot;%&quot;] = 11;
	ops[&quot;&lt;=&quot;] = 14;
	ops[&quot;&gt;=&quot;] = 15;
	ops[&quot;&lt;&quot;] = 16;
	ops[&quot;&gt;&quot;] = 17;
	ops[&quot;==&quot;] = 18;
	ops[&quot;!=&quot;] = 19;
	ops[&quot;^&quot;] = 20;
	ops[&quot;&amp;&amp;&quot;] = 21;
	ops[&quot;||&quot;] = 22;
	ops[&quot;=&quot;] = 23;
	ops[&quot;&lt;&lt;&quot;] = 24;
	ops[&quot;&gt;&gt;&quot;] = 25;
	ops[&quot;,&quot;] = 26;
	ops[&quot;;&quot;] = 27;
	kws[&quot;if&quot;] = 0;
	kws[&quot;else&quot;] = 1;
	kws[&quot;while&quot;] = 2;
	kws[&quot;for&quot;] = 3;
	kws[&quot;int&quot;] = 4;
	kws[&quot;return&quot;] = 5;
	vars[&quot;cin&quot;] = ++vid;
	vars[&quot;cout&quot;] = ++vid;
	vars[&quot;endl&quot;] = ++vid;
	funcs[vars[&quot;putchar&quot;] = ++vid].tp = 11;
	fread(buf, 1, sizeof(buf), stdin)[buf] = -1;
	pre();
	pre2();
	glob_var.ins(1);
	glob_var.ins(2);
	glob_var.ins(3);
	glob_var.def();
	run(funcs[vars[&quot;main&quot;]]);
	return 0;
}<pre><h2>Problem4020</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
int mem[10000005], *mp = mem;
char buf[10005], *ptr = buf;
char stk[10005];
int stp = 0;
map&lt;string, int&gt; ops, kws, vars;
int vid = 0;
int rk[28] = {100, 100, 101, 101, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 9, 10, 11, 12, 12, 13, 14};
int rka[28];
struct token
{
	int tp; //operator:0 integer:1 var_name:2 keyword:3
	int v;
	void init2()
	{
		tp = 2;
		string a(stk);
		if (kws.find(a) != kws.end())
		{
			tp = 3;
			v = kws[a];
		}
		else if (vars.find(a) != vars.end())
		{
			v = vars[a];
		}
		else
		{
			v = vars[a] = ++vid;
		}
	}
	void init1(int x)
	{
		tp = 1;
		v = x;
	}
	void init0()
	{
		tp = 0;
		v = ops[string(stk)];
		if ((v == 7 || v == 8) &amp;&amp; (this[-1].tp == 1 || this[-1].tp == 2 || this[-1].eq(0, 1) || this[-1].eq(0, 3)))
			v += 5;
	}
	bool eq(int a, int b)
	{
		return tp == a &amp;&amp; v == b;
	}
} ts[7007];
int tp = 0, tptr = 0;
bool isname(char x)
{
	return isalpha(x) || isdigit(x) || x == '_' || x == '$';
}
int _n, __in[10007], _inp = 0;
int _ri()
{
	int x = 0, f = 1;
	while (!isdigit(*ptr))
		*ptr++ == '-' ? f = -1 : 0;
	while (isdigit(*ptr))
		x = x * 10 + *ptr++ - 48;
	return x * f;
}
void pre()
{
	_n = _ri();
	for (int i = 0; i &lt; _n; ++i)
		__in[i] = _ri();
	for (; *ptr != ';'; ++ptr)
		;
	++ptr;
	while (1)
	{
		for (; *ptr != -1 &amp;&amp; *ptr &lt; 33; ++ptr)
			;
		if (*ptr == -1)
			break;
		stp = 0;
		if (isalpha(*ptr))
		{
			for (; isname(*ptr); stk[stp++] = *ptr++)
				;
			stk[stp] = 0;
			ts[tp++].init2();
		}
		else if (isdigit(*ptr))
		{
			ts[tp++].init1(_ri());
		}
		else
		{
			stk[stp++] = *ptr++;
			stk[1] = *ptr;
			stk[2] = 0;
			if (ops.find(string(stk)) != ops.end())
				++ptr;
			else
				stk[1] = 0;
			ts[tp].init0();
			++tp;
		}
	}
}
#define ptr __
struct var
{
	int id, *dat, sz;
	vector&lt;int&gt; dsz;
	var() { sz = 1, id = 0; }
	void newdim(int x)
	{
		dsz.push_back(x);
		sz *= x;
	}
};
vector&lt;var&gt; var_now[7007];
struct varlist
{
	std::vector&lt;var&gt; vs;
	void def(bool init = 1)
	{
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var &amp;w = vs[i];
			if (init)
				memset(mp, 0, sizeof(int) * w.sz);
			w.dat = mp, mp += w.sz;
			var_now[w.id].push_back(w);
		}
	}
	void defs()
	{
		int mx = *--mp;
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var &amp;w = vs[i];
			memset(mp, 0, sizeof(int) * w.sz);
			w.dat = mp, mp += w.sz;
			var_now[w.id].push_back(w);
		}
		*mp++ = mx + vs.size();
	}
	void undef()
	{
		for (int i = 0; i &lt; vs.size(); ++i)
		{
			var_now[vs[i].id].pop_back();
			mp -= vs[i].sz;
		}
	}
	void undefs()
	{
		int mx = *--mp;
		for (int i = 0; i &lt; mx; ++i)
		{
			var_now[vs[i].id].pop_back();
			mp -= vs[i].sz;
		}
	}
	void ins(int id)
	{
		var w;
		w.id = id;
		vs.push_back(w);
	}
	void R()
	{
		var w;
		w.id = ts[tptr++].v;
		for (; ts[tptr].eq(0, 2); tptr += 3)
			w.newdim(ts[tptr + 1].v);
		vs.push_back(w);
	}
	void Rs()
	{
		for (++tptr;;)
		{
			R();
			if (ts[tptr++].v == 27)
				break;
		}
	}
} glob_var;
struct node
{
	int tp, v;
	varlist vs;
	vector&lt;node&gt; rs;
	node &amp;rspb()
	{
		rs.push_back(node());
		return rs.back();
	}
	void Rvar() { tp = 7, v = ts[tptr++].v; }
	void Rint() { tp = 8, v = ts[tptr++].v; }
	void setop(int w) { tp = 10, v = w; }
	void Rcall()
	{
		tp = 9;
		v = ts[tptr].v;
		tptr += 2;
		while (!ts[tptr - 1].eq(0, 1))
			rspb().Rexpr();
	}
	void setvdim(int L, int R, varlist &amp;w)
	{
		tp = 13;
		for (int i = L; i &lt; R; ++i)
			vs.vs.push_back(w.vs[i]);
	}
	void Rexpr()
	{
		tp = 2;
		vector&lt;int&gt; ops;
		ops.push_back(0);
		while (1)
		{
			if (ts[tptr].tp == 0)
			{ //oper
				if (ts[tptr].v &gt;= 26)
				{
					while (ops.back())
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					break;
				}
				int v = ts[tptr].v;
				if (v == 0 || v == 2)
					ops.push_back(v);
				else if (v == 1)
				{
					while (ops.back())
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					ops.pop_back();
					if (ops.empty())
						break;
				}
				else if (v == 3)
				{
					int c;
					do
					{
						c = ops.back();
						rspb().setop(c);
						ops.pop_back();
					} while (c != 2);
				}
				else
				{
					while (ops.back()[rk] + v[rka] &lt;= v[rk])
					{
						rspb().setop(ops.back());
						ops.pop_back();
					}
					ops.push_back(v);
				}
				++tptr;
			}
			else if (ts[tptr].tp == 1)
				rspb().Rint(); //int
			else if (ts[tptr + 1].eq(0, 0))
				rspb().Rcall(); //call func
			else
				rspb().Rvar(); //var
		}
		++tptr;
	}
	void Rkw()
	{
		if (ts[tptr].v == 0)
		{ //if
			tp = 3;
			tptr += 2;
			rspb().Rexpr();
			rspb().Rblock();
			if (ts[tptr].eq(3, 1))
			{ //else
				++tptr;
				rspb().Rblock();
			}
		}
		else if (ts[tptr].v == 2)
		{ //while
			tp = 4;
			tptr += 2;
			rspb().Rexpr();
			rspb().Rblock();
		}
		else if (ts[tptr].v == 3)
		{ //for
			tp = 5;
			tptr += 2;
			rspb();
			if (ts[tptr].eq(3, 4))
				vs.Rs(), rs.back().tp = 12;
			else
				rs.back().Rexpr();
			rspb().Rexpr();
			rspb().Rexpr();
			rspb().Rblock();
		}
		else
		{ //return
			tp = 6;
			++tptr;
			rspb().Rexpr();
		}
	}
	void Rblock()
	{
		if (!ts[tptr].eq(0, 4))
		{
			if (ts[tptr].tp == 3)
				Rkw();
			else
				Rexpr();
			return;
		}
		tp = 1;
		++tptr;
		while (!ts[tptr].eq(0, 5))
		{
			if (ts[tptr].tp == 3)
			{
				if (ts[tptr].v == 4)
				{
					int L = vs.vs.size();
					vs.Rs();
					int R = vs.vs.size();
					rspb().setvdim(L, R, vs);
				}
				else
					rspb().Rkw();
			}
			else
				rspb().Rblock();
		}
		++tptr;
	}
	void Rfunc()
	{
		tp = 0;
		tptr += 3;
		if (ts[tptr].eq(0, 1))
			++tptr;
		else
			do
			{
				++tptr;
				vs.R();
			} while (!ts[tptr++].eq(0, 1));
		rspb().Rblock();
	}
} funcs[7007];
#define run(x) _runs[x.tp](x)
int (*_runs[30])(node &amp;);
void (*_ops[30])();
bool ret_flag = 0;
int _func(node &amp;w)
{
	w.vs.def(0);
	int r = run(w.rs[0]);
	w.vs.undef();
	ret_flag = 0;
	void push(int);
	push(r);
	return r;
}
int _block(node &amp;w)
{
	*mp++ = 0;
	int r = 0;
	for (int i = 0; i &lt; w.rs.size() &amp;&amp; !ret_flag; ++i)
		r = run(w.rs[i]);
	w.vs.undefs();
	return r;
}
int _expr(node &amp;w)
{
	if (w.rs.empty())
		return 1;
	for (int i = 0; i &lt; w.rs.size(); ++i)
		run(w.rs[i]);
	int &amp;pop();
	return pop();
}
int _if(node &amp;w)
{
	int r = 0;
	if (run(w.rs[0]))
		r = run(w.rs[1]);
	else if (w.rs.size() == 3)
		r = run(w.rs[2]);
	return r;
}
int _while(node &amp;w)
{
	int r = 0;
	while (!ret_flag &amp;&amp; run(w.rs[0]))
		r = run(w.rs[1]);
	return r;
}
int _for(node &amp;w)
{
	int r = 0;
	w.vs.def();
	for (run(w.rs[0]); !ret_flag &amp;&amp; run(w.rs[1]); run(w.rs[2]))
		r = run(w.rs[3]);
	w.vs.undef();
	return r;
}
int _ret(node &amp;w)
{
	int r = run(w.rs[0]);
	ret_flag = 1;
	return r;
}
int _var(node &amp;w)
{
	mp[0] = w.v;
	mp[1] = 0;
	mp[2] = 0;
	mp += 3;
}
void push(int x)
{
	mp[0] = -1;
	mp[1] = x;
	mp[2] = 0;
	mp += 3;
}
int _int(node &amp;w)
{
	push(w.v);
}
int _nod(node &amp;w) {}
int _call(node &amp;w)
{
	for (int i = 0; i &lt; w.rs.size(); ++i)
	{
		int r = run(w.rs[i]);
		*mp++ = r;
	}
	mp -= w.rs.size();
	return run(funcs[w.v]);
}
int &amp;pop()
{
	mp -= 3;
	return *mp &lt; 0 ? mp[1] : var_now[*mp].back().dat[mp[2]];
}
void _arr()
{
	int x = pop();
	mp[-1] *= var_now[mp[-3]].back().dsz[mp[-2]++];
	mp[-1] += x;
}
void _not() { push(!pop()); }
void _pos() { push(pop()); }
void _neg() { push(-pop()); }

void _or()
{
	int b = pop(), a = pop();
	push(a || b);
}
void _and()
{
	int b = pop(), a = pop();
	push(a &amp;&amp; b);
}
void _xor()
{
	int b = pop(), a = pop();
	push(!a + !b == 1);
}
void _neq()
{
	int b = pop(), a = pop();
	push(a != b);
}
void _eq()
{
	int b = pop(), a = pop();
	push(a == b);
}
void _lss()
{
	int b = pop(), a = pop();
	push(a &lt; b);
}
void _mre()
{
	int b = pop(), a = pop();
	push(a &gt; b);
}
void _meq()
{
	int b = pop(), a = pop();
	push(a &gt;= b);
}
void _leq()
{
	int b = pop(), a = pop();
	push(a &lt;= b);
}
void _mul()
{
	push(pop() * pop());
}
void _div()
{
	int b = pop(), a = pop();
	push(a / b);
}
void _mod()
{
	int b = pop(), a = pop();
	push(a % b);
}
void _sub()
{
	int b = pop(), a = pop();
	push(a - b);
}
void _add()
{
	int b = pop(), a = pop();
	push(a + b);
}

void _set()
{
	int b = pop();
	pop() = b;
	push(b);
}
void _in()
{
	pop() = __in[_inp++];
}
void _out()
{
	int x = pop();
	if (mp[0] == 3)
		puts(&quot;&quot;);
	else
		printf(&quot;%d&quot;, x);
}
int _op(node &amp;w)
{
	_ops[w.v]();
}
int _vdim(node &amp;w)
{
	w.vs.defs();
}
int _pc(node &amp;w)
{
	int c = *mp;
	putchar(c);
	push(c);
	return c;
}
void pre2()
{
	while (tptr &lt; tp)
	{
		if (ts[tptr + 2].tp == 0 &amp;&amp; ts[tptr + 2].v == 0)
			funcs[ts[tptr + 1].v].Rfunc();
		else
			glob_var.Rs();
	}
}
int main()
{
	_runs[0] = _func;
	_runs[1] = _block;
	_runs[2] = _expr;
	_runs[3] = _if;
	_runs[4] = _while;
	_runs[5] = _for;
	_runs[6] = _ret;
	_runs[7] = _var;
	_runs[8] = _int;
	_runs[9] = _call;
	_runs[10] = _op;
	_runs[11] = _pc;
	_runs[12] = _nod;
	_runs[13] = _vdim;
	_ops[2] = _arr;
	_ops[6] = _not;
	_ops[7] = _pos;
	_ops[8] = _neg;
	_ops[9] = _mul;
	_ops[10] = _div;
	_ops[11] = _mod;
	_ops[12] = _add;
	_ops[13] = _sub;
	_ops[14] = _leq;
	_ops[15] = _meq;
	_ops[16] = _lss;
	_ops[17] = _mre;
	_ops[18] = _eq;
	_ops[19] = _neq;
	_ops[20] = _xor;
	_ops[21] = _and;
	_ops[22] = _or;
	_ops[23] = _set;
	_ops[24] = _out;
	_ops[25] = _in;
	rka[6] = rka[7] = rka[8] = rka[23] = 1;
	ops[&quot;(&quot;] = 0;
	ops[&quot;)&quot;] = 1;
	ops[&quot;[&quot;] = 2;
	ops[&quot;]&quot;] = 3;
	ops[&quot;{&quot;] = 4;
	ops[&quot;}&quot;] = 5;
	ops[&quot;!&quot;] = 6;
	ops[&quot;+&quot;] = 7;
	ops[&quot;-&quot;] = 8;
	ops[&quot;*&quot;] = 9;
	ops[&quot;/&quot;] = 10;
	ops[&quot;%&quot;] = 11;
	ops[&quot;&lt;=&quot;] = 14;
	ops[&quot;&gt;=&quot;] = 15;
	ops[&quot;&lt;&quot;] = 16;
	ops[&quot;&gt;&quot;] = 17;
	ops[&quot;==&quot;] = 18;
	ops[&quot;!=&quot;] = 19;
	ops[&quot;^&quot;] = 20;
	ops[&quot;&amp;&amp;&quot;] = 21;
	ops[&quot;||&quot;] = 22;
	ops[&quot;=&quot;] = 23;
	ops[&quot;&lt;&lt;&quot;] = 24;
	ops[&quot;&gt;&gt;&quot;] = 25;
	ops[&quot;,&quot;] = 26;
	ops[&quot;;&quot;] = 27;
	kws[&quot;if&quot;] = 0;
	kws[&quot;else&quot;] = 1;
	kws[&quot;while&quot;] = 2;
	kws[&quot;for&quot;] = 3;
	kws[&quot;int&quot;] = 4;
	kws[&quot;return&quot;] = 5;
	vars[&quot;cin&quot;] = ++vid;
	vars[&quot;cout&quot;] = ++vid;
	vars[&quot;endl&quot;] = ++vid;
	funcs[vars[&quot;putchar&quot;] = ++vid].tp = 11;
	fread(buf, 1, sizeof(buf), stdin)[buf] = -1;
	pre();
	pre2();
	glob_var.ins(1);
	glob_var.ins(2);
	glob_var.ins(3);
	glob_var.def();
	run(funcs[vars[&quot;main&quot;]]);
	return 0;
}<pre><h2>Problem4020</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

#define STACK_SIZE 10003
#define TOKENS_NUMBER 7003
#define VARIABLE_NUMBER 7003
#define FUNCTION_NUMBER 7003
#define MEMORY_SIZE (1 &lt;&lt; 22 | 1)
#define INPUF_BUFFER_SIZE 10003

char buffer[INPUF_BUFFER_SIZE], *cur_char = buffer;

char i_stack[STACK_SIZE];
int i_stack_p = 0;

map&lt;string, int&gt; operations, keywards, variables;
int var_id = 0;
const int rk[] = {115, 115, 116, 116, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,
                  6,  6,  6,  6,  7, 7, 8, 9, 10, 11, 12, 12, 13, 14};
int rk_count[28];

struct Token {
  int type;
  int value;

  void init(int _type, int _value = 0) {
    type = _type;
    if (_type == 0) {
      value = operations[string(i_stack)];
      if ((value == 7 || value == 8) &amp;&amp;
          (this[-1].type == 1 || this[-1].type == 2 || this[-1].equal(0, 1) ||
           this[-1].equal(0, 3)))
        value += 5;
    } else if (_type == 1) {
      value = _value;
    } else {
      string s(i_stack);
      static map&lt;string, int&gt;::iterator it;
      it = keywards.find(s);
      if (it != keywards.end()) {
        type = 3;
        value = it-&gt;second;
        return;
      }
      it = variables.find(s);
      if (it != variables.end()) {
        value = it-&gt;second;
      } else {
        value = variables[s] = ++var_id;
      }
    }
  }
  bool equal(int a, int b) { return type == a &amp;&amp; value == b; }
} tokens[TOKENS_NUMBER];
int tokens_p = 0, tokens_ptr = 0;

bool isName(char ch) {
  return isalpha(ch) || isdigit(ch) || ch == '_' || ch == '$';
}
int i_n, i_in[STACK_SIZE], i_in_p = 0;
int i_ReadInt() {
  int x = 0, sign = 1;
  while (!isdigit(*cur_char)) *cur_char++ == '-' ? sign = -1 : 0;
  while (isdigit(*cur_char)) x = x * 10 + *cur_char++ - '0';
  return x * sign;
}

struct Variable {
  int id, *data, size;
  vector&lt;int&gt; a;
  Variable() : id(0), data(NULL), size(1) {}
  void insert(int x) {
    a.push_back(x);
    size *= x;
  }
};
vector&lt;Variable&gt; var_now[VARIABLE_NUMBER];
int memory_pool[MEMORY_SIZE], *memory_it = memory_pool;
struct VariableList {
  vector&lt;Variable&gt; var_list;
  void def(bool init = true) {
    for (int i = 0; i &lt; (int)var_list.size(); i++) {
      Variable &amp;v = var_list[i];
      if (init) {
        memset(memory_it, 0, sizeof(int) * v.size);
      }
      v.data = memory_it;
      memory_it += v.size;
      var_now[v.id].push_back(v);
    }
  }
  void defs() {
    int mx = *--memory_it;
    for (int i = 0; i &lt; (int)var_list.size(); i++) {
      Variable &amp;v = var_list[i];
      memset(memory_it, 0, sizeof(int) * v.size);
      v.data = memory_it;
      memory_it += v.size;
      var_now[v.id].push_back(v);
    }
    *memory_it++ = mx + var_list.size();
  }
  void undef() {
    for (int i = 0; i &lt; (int)var_list.size(); i++) {
      Variable &amp;v = var_list[i];
      var_now[v.id].pop_back();
      memory_it -= v.size;
    }
  }
  void undefs() {
    int mx = *--memory_it;
    for (int i = 0; i &lt; mx; i++) {
      var_now[var_list[i].id].pop_back();
      memory_it -= var_list[i].size;
    }
  }
  void ins(int id) {
    Variable w;
    w.id = id;
    var_list.push_back(w);
  }
  void R() {
    Variable v;
    v.id = tokens[tokens_ptr++].value;
    while (tokens[tokens_ptr].equal(0, 2)) {
      v.insert(tokens[tokens_ptr + 1].value);
      tokens_ptr += 3;
    }
    var_list.push_back(v);
  }
  void Rs() {
    tokens_ptr++;
    while (true) {
      R();
      if (tokens[tokens_ptr++].value == 27) break;
    }
  }
} glob_var;

struct Node {
  int type, value;
  VariableList var_list;
  vector&lt;Node&gt; nodes;
  Node&amp; NodePB() {
    nodes.push_back(Node());
    return nodes.back();
  }
  void Rvar() {
    type = 7;
    value = tokens[tokens_ptr++].value;
  }
  void Rint() {
    type = 8;
    value = tokens[tokens_ptr++].value;
  }
  void Rcall() {
    type = 9;
    value = tokens[tokens_ptr].value;
    tokens_ptr += 2;
    while (!tokens[tokens_ptr - 1].equal(0, 1)) NodePB().Rexpr();
  }
  void Sv(int v) {
    type = 10;
    value = v;
  }
  void Sd(int left, int right, VariableList &amp;vs) {
    type = 13;
    for (int i = left; i &lt; right; i++) {
      var_list.var_list.push_back(vs.var_list[i]);
    }
  }
  void Rexpr() {
    type = 2;
    vector&lt;int&gt; operations;
    operations.push_back(0);
    while (true) {
      if (tokens[tokens_ptr].type == 0) {
        if (tokens[tokens_ptr].value &gt;= 26) {
          while (operations.back()) {
            NodePB().Sv(operations.back());
            operations.pop_back();
          }
          break;
        }
        int value = tokens[tokens_ptr].value;
        if (value == 0 || value == 2) {
          operations.push_back(value);
        } else if (value == 1) {
          while (operations.back()) {
            NodePB().Sv(operations.back());
            operations.pop_back();
          }
          operations.pop_back();
          if (operations.empty()) break;
        } else if (value == 3) {
          int c;
          do {
            c = operations.back();
            NodePB().Sv(c);
            operations.pop_back();
          } while (c != 2);
        } else {
          while (rk[operations.back()] + rk_count[value] &lt;= rk[value]) {
            NodePB().Sv(operations.back());
            operations.pop_back();
          }
          operations.push_back(value);
        }
        tokens_ptr++;
      } else if (tokens[tokens_ptr].type == 1) {
        NodePB().Rint();
      } else if (tokens[tokens_ptr + 1].equal(0, 0)) {
        NodePB().Rcall();
      } else {
        NodePB().Rvar();
      }
    }
    tokens_ptr++;
  }
  void Rkeyword() {
    if (tokens[tokens_ptr].value == 0) { // if
      type = 3;
      tokens_ptr += 2;
      NodePB().Rexpr();
      NodePB().Rblock();
      if (tokens[tokens_ptr].equal(3, 1)) { // else
        tokens_ptr++;
        NodePB().Rblock();
      }
    } else if (tokens[tokens_ptr].value == 2) { // while
      type = 4;
      tokens_ptr += 2;
      NodePB().Rexpr();
      NodePB().Rblock();
    } else if (tokens[tokens_ptr].value == 3) { // for
      type = 5;
      tokens_ptr += 2;
      NodePB();
      if (tokens[tokens_ptr].equal(3, 4)) {
        var_list.Rs();
        nodes.back().type = 12;
      } else {
        nodes.back().Rexpr();
      }
      NodePB().Rexpr();
      NodePB().Rexpr();
      NodePB().Rblock();
    } else { // return
      type = 6;
      tokens_ptr++;
      NodePB().Rexpr();
    }
  }
  void Rblock() {
    if (!tokens[tokens_ptr].equal(0, 4)) {
      if (tokens[tokens_ptr].type == 3) {
        Rkeyword();
      } else {
        Rexpr();
      }
      return;
    }
    type = 1;
    tokens_ptr++;
    while (!tokens[tokens_ptr].equal(0, 5)) {
      if (tokens[tokens_ptr].type == 3) {
        if (tokens[tokens_ptr].value == 4) {
          int left = var_list.var_list.size();
          var_list.Rs();
          int right = var_list.var_list.size();
          NodePB().Sd(left, right, var_list);
        } else {
          NodePB().Rkeyword();
        }
      } else {
        NodePB().Rblock();
      }
    }
    tokens_ptr++;
  }
  void Rfunc() {
    type = 0;
    tokens_ptr += 3;
    if (tokens[tokens_ptr].equal(0, 1)) {
      tokens_ptr++;
    } else {
      do {
        tokens_ptr++;
        var_list.R();
      } while (!tokens[tokens_ptr++].equal(0, 1));
    }
    NodePB().Rblock();
  }
} funcs[FUNCTION_NUMBER];

#define run(x) _runs[(x).type](x)
int (*_runs[30])(Node&amp;);
void (*_ops[30])();
bool returned(false);

// Define Keywords begin

void push(int x) {
  *memory_it++ = -1;
  *memory_it++ = x;
  *memory_it++ = 0;
}
int &amp;pop() {
  memory_it -= 3;
  return *memory_it &lt; 0 ? memory_it[1] : var_now[*memory_it].back().data[memory_it[2]];
}
int _func(Node &amp;w) {
  w.var_list.def(0);
  int res = run(w.nodes[0]);
  w.var_list.undef();
  returned = false;
  push(res);
  return res;
}
int _block(Node &amp;w) {
  *memory_it++ = 0;
  int r = 0;
  for (int i = 0; i &lt; (int)w.nodes.size() &amp;&amp; !returned; i++) {
    r = run(w.nodes[i]);
  }
  w.var_list.undefs();
  return r;
}
int _expr(Node &amp;w) {
  if (w.nodes.empty()) return 1;
  for (int i = 0; i &lt; (int)w.nodes.size(); i++) {
    run(w.nodes[i]);
  }
  return pop();
}
int _if(Node &amp;w) {
  int res = 0;
  if (run(w.nodes[0])) {
    res = run(w.nodes[1]);
  } else if (w.nodes.size() == 3) {
    res = run(w.nodes[2]);
  }
  return res;
}
int _while(Node &amp;w) {
  int res = 0;
  while (!returned &amp;&amp; run(w.nodes[0])) {
    res = run(w.nodes[1]);
  }
  return res;
}
int _for(Node &amp;w) {
  int res = 0;
  w.var_list.def();
  run(w.nodes[0]);
  while (!returned &amp;&amp; run(w.nodes[1])) {
    res = run(w.nodes[3]);
    run(w.nodes[2]);
  }
  w.var_list.undef();
  return res;
}
int _return(Node &amp;w) {
  int res = run(w.nodes[0]);
  returned = true;
  return res;
}
int _var(Node &amp;w) {
  *memory_it++ = w.value;
  *memory_it++ = 0;
  *memory_it++ = 0;
  return 0;
}
int _int(Node &amp;w) {
  push(w.value);
  return 0;
}
int _nod(Node &amp;w) {
  return 0;
}
int _call(Node &amp;w) {
  for (int i = 0; i &lt; (int)w.nodes.size(); i++) {
    *memory_it++ = run(w.nodes[i]);
  }
  memory_it -= w.nodes.size();
  return run(funcs[w.value]);
}
void _arr() {
  int x = pop();
  memory_it[-1] *= var_now[memory_it[-3]].back().a[memory_it[-2]++];
  memory_it[-1] += x;
}
void _not() {
  push(!pop());
}
void _pos() {
  push(pop());
}
void _neg() {
  push(-pop());
}
void _mul() {
  int b = pop(), a = pop();
  push(a * b);
}
void _div() {
  int b = pop(), a = pop();
  push(a / b);
}
void _mod() {
  int b = pop(), a = pop();
  push(a % b);
}
void _add() {
  int b = pop(), a = pop();
  push(a + b);
}
void _sub() {
  int b = pop(), a = pop();
  push(a - b);
}
void _leq() {
  int b = pop(), a = pop();
  push(a &lt;= b);
}
void _meq() {
  int b = pop(), a = pop();
  push(a &gt;= b);
}
void _lss() {
  int b = pop(), a = pop();
  push(a &lt; b);
}
void _mre() {
  int b = pop(), a = pop();
  push(a &gt; b);
}
void _eq() {
  int b = pop(), a = pop();
  push(a == b);
}
void _neq() {
  int b = pop(), a = pop();
  push(a != b);
}
void _xor() {
  int b = pop(), a = pop();
  push(!a + !b == 1);
}
void _and() {
  int b = pop(), a = pop();
  push(a &amp;&amp; b);
}
void _or() {
  int b = pop(), a = pop();
  push(a || b);
}
void _set() {
  int b = pop();
  pop() = b;
  push(b);
}
void _in() {
  pop() = i_in[i_in_p++];
}
void _out() {
  int x = pop();
  if (memory_it[0] == 3) {
    puts(&quot;&quot;);
  } else {
    printf(&quot;%d&quot;, x);
  }
}
int _op(Node &amp;w) {
  _ops[w.value]();
  return 0;
}
int _vdi(Node &amp;w) {
  w.var_list.defs();
  return 0;
}
int _putchar(Node &amp;w) {
  int c = *memory_it;
  putchar(c);
  push(c);
  return c;
}
// Define end

void LoadKeywords() {
  _runs[0] = _func;
  _runs[1] = _block;
  _runs[2] = _expr;
  _runs[3] = _if;
  _runs[4] = _while;
  _runs[5] = _for;
  _runs[6] = _return;
  _runs[7] = _var;
  _runs[8] = _int;
  _runs[9] = _call;
  _runs[10] = _op;
  _runs[11] = _putchar;
  _runs[12] = _nod;
  _runs[13] = _vdi;
  _ops[2] = _arr;
  _ops[6] = _not;
  _ops[7] = _pos;
  _ops[8] = _neg;
  _ops[9] = _mul;
  _ops[10] = _div;
  _ops[11] = _mod;
  _ops[12] = _add;
  _ops[13] = _sub;
  _ops[14] = _leq;
  _ops[15] = _meq;
  _ops[16] = _lss;
  _ops[17] = _mre;
  _ops[18] = _eq;
  _ops[19] = _neq;
  _ops[20] = _xor;
  _ops[21] = _and;
  _ops[22] = _or;
  _ops[23] = _set;
  _ops[24] = _out;
  _ops[25] = _in;
  rk_count[6] = rk_count[7] = rk_count[8] = rk_count[23] = 1;
  operations[&quot;(&quot;] = 0;
  operations[&quot;)&quot;] = 1;
  operations[&quot;[&quot;] = 2;
  operations[&quot;]&quot;] = 3;
  operations[&quot;{&quot;] = 4;
  operations[&quot;}&quot;] = 5;
  operations[&quot;!&quot;] = 6;
  operations[&quot;+&quot;] = 7;
  operations[&quot;-&quot;] = 8;
  operations[&quot;*&quot;] = 9;
  operations[&quot;/&quot;] = 10;
  operations[&quot;%&quot;] = 11;
  operations[&quot;&lt;=&quot;] = 14;
  operations[&quot;&gt;=&quot;] = 15;
  operations[&quot;&lt;&quot;] = 16;
  operations[&quot;&gt;&quot;] = 17;
  operations[&quot;==&quot;] = 18;
  operations[&quot;!=&quot;] = 19;
  operations[&quot;^&quot;] = 20;
  operations[&quot;&amp;&amp;&quot;] = 21;
  operations[&quot;||&quot;] = 22;
  operations[&quot;=&quot;] = 23;
  operations[&quot;&lt;&lt;&quot;] = 24;
  operations[&quot;&gt;&gt;&quot;] = 25;
  operations[&quot;,&quot;] = 26;
  operations[&quot;;&quot;] = 27;
  keywards[&quot;if&quot;] = 0;
  keywards[&quot;else&quot;] = 1;
  keywards[&quot;while&quot;] = 2;
  keywards[&quot;for&quot;] = 3;
  keywards[&quot;int&quot;] = 4;
  keywards[&quot;return&quot;] = 5;
  variables[&quot;cin&quot;] = ++var_id;
  variables[&quot;cout&quot;] = ++var_id;
  variables[&quot;endl&quot;] = ++var_id;
  funcs[variables[&quot;putchar&quot;] = ++var_id].type = 11;
}

void PreWork() {
  i_n = i_ReadInt();
  for (int i = 0; i &lt; i_n; i++) {
    i_in[i] = i_ReadInt();
  }
  while (*cur_char != ';') {
    cur_char++;
  }
  cur_char++;
  while (true) {
    while (*cur_char != EOF &amp;&amp; *cur_char &lt; 33) {
      cur_char++;
    }
    if (*cur_char == EOF) break;
    i_stack_p = 0;
    if (isalpha(*cur_char)) {
      while (isName(*cur_char)) {
        i_stack[i_stack_p++] = *cur_char++;
      }
      i_stack[i_stack_p] = 0;
      tokens[tokens_p++].init(2);
    } else if (isdigit(*cur_char)) {
      tokens[tokens_p++].init(1, i_ReadInt());
    } else {
      i_stack[i_stack_p++] = *cur_char++;
      i_stack[1] = *cur_char;
      i_stack[2] = 0;
      if (operations.find(string(i_stack)) != operations.end())
        ++cur_char;
      else
        i_stack[1] = 0;
      tokens[tokens_p].init(0);
      tokens_p++;
    }
  }
}

void BuildTree() {
  while (tokens_ptr &lt; tokens_p) {
    if (tokens[tokens_ptr + 2].equal(0, 0)) {
      funcs[tokens[tokens_ptr + 1].value].Rfunc();
    } else {
      glob_var.Rs();
    }
  }
}

int main() {
  LoadKeywords();
  buffer[fread(buffer, 1, sizeof(buffer), stdin)] = EOF;
  PreWork();
  BuildTree();
  glob_var.ins(1);
  glob_var.ins(2);
  glob_var.ins(3);
  glob_var.def();
  run(funcs[variables[&quot;main&quot;]]);
  return 0;
}
<pre><h2>Problem4066</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
const int N=200005;
const double bal=0.7125;
int n,cnd,cmp_d,Q[4],rt,tp,stk[N],ans,p;
struct node{int d[2],mx[2],mi[2],size,sum,ls,rs,val;}C[N];
inline void cmin(int&amp;a,const int&amp;b){if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b){if(a&lt;b)a=b;}
bool cmp(const int&amp;a,const int&amp;b) {return C[a].d[cmp_d]&lt;C[b].d[cmp_d];}
inline void update(int x) {
	static int i,l,r;
	node&amp;u=C[x];
	l=u.ls,r=u.rs;
	u.sum=C[l].sum+C[r].sum+u.val;
	u.size=C[l].size+C[r].size+1;
	for(i=0;i^2;++i) {
		if(l)cmin(u.mi[i],C[l].mi[i]),cmax(u.mx[i],C[l].mx[i]);
		if(r)cmin(u.mi[i],C[r].mi[i]),cmax(u.mx[i],C[r].mx[i]);
	}
}
void build(int&amp;u,int l,int r,int _d) {
	int md=l+r&gt;&gt;1;  cmp_d=_d;
	nth_element(stk+l,stk+md,stk+r+1,cmp);
	u=stk[md]; C[u].sum=C[u].val;
	C[u].mx[0]=C[u].mi[0]=C[u].d[0];
	C[u].mx[1]=C[u].mi[1]=C[u].d[1];
	if(l&lt;md)build(C[u].ls,l,md-1,_d^1);
	if(md&lt;r)build(C[u].rs,md+1,r,_d^1);
	update(u);
}
void del(int&amp;u) {
	if(!u) return;
	stk[++tp]=u; del(C[u].ls),del(C[u].rs); u=0;
}
inline void rebuild(int&amp;u,int _d) {
	stk[tp=1]=++cnd; C[cnd].size=1;
	C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
	C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
	C[cnd].sum=C[cnd].val=Q[2];
	del(u); build(u,1,tp,_d);
}
void insert(int&amp;u,int _d) {
	if(!u) {
		u=++cnd; C[u].size=1;
		C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
		C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
		C[cnd].sum=C[cnd].val=Q[2];
		return;
	}
	if(Q[_d]&lt;C[u].d[_d]) {
		if(C[C[u].ls].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].ls,_d^1);
	} else {
		if(C[C[u].rs].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].rs,_d^1);
	}update(u);
}
inline bool inside(const int&amp;u) {
	if(!u)return 0;
	return Q[0]&lt;=C[u].mx[0]&amp;&amp;Q[2]&gt;=C[u].mi[0]&amp;&amp;Q[1]&lt;=C[u].mx[1]&amp;&amp;Q[3]&gt;=C[u].mi[1];
}
void query(int u) {
	if(Q[0]&lt;=C[u].mi[0]&amp;&amp;Q[2]&gt;=C[u].mx[0]&amp;&amp;Q[1]&lt;=C[u].mi[1]&amp;&amp;Q[3]&gt;=C[u].mx[1]){ans+=C[u].sum;return;}
	if(Q[0]&lt;=C[u].d[0]&amp;&amp;Q[2]&gt;=C[u].d[0]&amp;&amp;Q[1]&lt;=C[u].d[1]&amp;&amp;Q[3]&gt;=C[u].d[1])ans+=C[u].val;
	if(inside(C[u].ls))query(C[u].ls);
	if(inside(C[u].rs))query(C[u].rs);
}
int main() {
	for(n=gi(),p=gi();p^3;p=gi()) {
		if(p&lt;2)Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,insert(rt,0);
		else Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,Q[3]=gi()^ans,ans=0,query(rt),printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem4066</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
const int N=200005;
const double bal=0.7;
int n,cnd,cmp_d,Q[4],rt,tp,stk[N],ans,p;
struct node{int d[2],mx[2],mi[2],size,sum,ls,rs,val;}C[N];
inline void cmin(int&amp;a,const int&amp;b){if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b){if(a&lt;b)a=b;}
bool cmp(const int&amp;a,const int&amp;b) {return C[a].d[cmp_d]&lt;C[b].d[cmp_d];}
inline void update(int x) {
	static int i,l,r;
	node&amp;u=C[x];
	l=u.ls,r=u.rs;
	u.sum=C[l].sum+C[r].sum+u.val;
	u.size=C[l].size+C[r].size+1;
	for(i=0;i^2;++i) {
		if(l)cmin(u.mi[i],C[l].mi[i]),cmax(u.mx[i],C[l].mx[i]);
		if(r)cmin(u.mi[i],C[r].mi[i]),cmax(u.mx[i],C[r].mx[i]);
	}
}
void build(int&amp;u,int l,int r,int _d) {
	int md=l+r&gt;&gt;1;  cmp_d=_d;
	nth_element(stk+l,stk+md,stk+r+1,cmp);
	u=stk[md]; C[u].sum=C[u].val;
	C[u].mx[0]=C[u].mi[0]=C[u].d[0];
	C[u].mx[1]=C[u].mi[1]=C[u].d[1];
	if(l&lt;md)build(C[u].ls,l,md-1,_d^1);
	if(md&lt;r)build(C[u].rs,md+1,r,_d^1);
	update(u);
}
void del(int&amp;u) {
	if(!u) return;
	stk[++tp]=u; del(C[u].ls),del(C[u].rs); u=0;
}
inline void rebuild(int&amp;u,int _d) {
	stk[tp=1]=++cnd; C[cnd].size=1;
	C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
	C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
	C[cnd].sum=C[cnd].val=Q[2];
	del(u); build(u,1,tp,_d);
}
void insert(int&amp;u,int _d) {
	if(!u) {
		u=++cnd; C[u].size=1;
		C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
		C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
		C[cnd].sum=C[cnd].val=Q[2];
		return;
	}
	if(Q[_d]&lt;C[u].d[_d]) {
		if(C[C[u].ls].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].ls,_d^1);
	} else {
		if(C[C[u].rs].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].rs,_d^1);
	}update(u);
}
inline bool inside(const int&amp;u) {
	if(!u)return 0;
	return Q[0]&lt;=C[u].mx[0]&amp;&amp;Q[2]&gt;=C[u].mi[0]&amp;&amp;Q[1]&lt;=C[u].mx[1]&amp;&amp;Q[3]&gt;=C[u].mi[1];
}
void query(int u) {
	if(Q[0]&lt;=C[u].mi[0]&amp;&amp;Q[2]&gt;=C[u].mx[0]&amp;&amp;Q[1]&lt;=C[u].mi[1]&amp;&amp;Q[3]&gt;=C[u].mx[1]){ans+=C[u].sum;return;}
	if(Q[0]&lt;=C[u].d[0]&amp;&amp;Q[2]&gt;=C[u].d[0]&amp;&amp;Q[1]&lt;=C[u].d[1]&amp;&amp;Q[3]&gt;=C[u].d[1])ans+=C[u].val;
	if(inside(C[u].ls))query(C[u].ls);
	if(inside(C[u].rs))query(C[u].rs);
}
int main() {
	for(n=gi(),p=gi();p^3;p=gi()) {
		if(p&lt;2)Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,insert(rt,0);
		else Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,Q[3]=gi()^ans,ans=0,query(rt),printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem4066</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
const int N=200005;
const double bal=0.625;
int n,cnd,cmp_d,Q[4],rt,tp,stk[N],ans,p;
struct node{int d[2],mx[2],mi[2],size,sum,ls,rs,val;}C[N];
inline void cmin(int&amp;a,const int&amp;b){if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b){if(a&lt;b)a=b;}
bool cmp(const int&amp;a,const int&amp;b) {return C[a].d[cmp_d]&lt;C[b].d[cmp_d];}
inline void update(int x) {
	static int i,l,r;
	node&amp;u=C[x];
	l=u.ls,r=u.rs;
	u.sum=C[l].sum+C[r].sum+u.val;
	u.size=C[l].size+C[r].size+1;
	for(i=0;i^2;++i) {
		if(l)cmin(u.mi[i],C[l].mi[i]),cmax(u.mx[i],C[l].mx[i]);
		if(r)cmin(u.mi[i],C[r].mi[i]),cmax(u.mx[i],C[r].mx[i]);
	}
}
void build(int&amp;u,int l,int r,int _d) {
	int md=l+r&gt;&gt;1;  cmp_d=_d;
	nth_element(stk+l,stk+md,stk+r+1,cmp);
	u=stk[md]; C[u].sum=C[u].val;
	C[u].mx[0]=C[u].mi[0]=C[u].d[0];
	C[u].mx[1]=C[u].mi[1]=C[u].d[1];
	if(l&lt;md)build(C[u].ls,l,md-1,_d^1);
	if(md&lt;r)build(C[u].rs,md+1,r,_d^1);
	update(u);
}
void del(int&amp;u) {
	if(!u) return;
	stk[++tp]=u; del(C[u].ls),del(C[u].rs); u=0;
}
inline void rebuild(int&amp;u,int _d) {
	stk[tp=1]=++cnd; C[cnd].size=1;
	C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
	C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
	C[cnd].sum=C[cnd].val=Q[2];
	del(u); build(u,1,tp,_d);
}
void insert(int&amp;u,int _d) {
	if(!u) {
		u=++cnd; C[u].size=1;
		C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
		C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
		C[cnd].sum=C[cnd].val=Q[2];
		return;
	}
	if(Q[_d]&lt;C[u].d[_d]) {
		if(C[C[u].ls].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].ls,_d^1);
	} else {
		if(C[C[u].rs].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].rs,_d^1);
	}update(u);
}
inline bool inside(const int&amp;u) {
	if(!u)return 0;
	return Q[0]&lt;=C[u].mx[0]&amp;&amp;Q[2]&gt;=C[u].mi[0]&amp;&amp;Q[1]&lt;=C[u].mx[1]&amp;&amp;Q[3]&gt;=C[u].mi[1];
}
void query(int u) {
	if(Q[0]&lt;=C[u].mi[0]&amp;&amp;Q[2]&gt;=C[u].mx[0]&amp;&amp;Q[1]&lt;=C[u].mi[1]&amp;&amp;Q[3]&gt;=C[u].mx[1]){ans+=C[u].sum;return;}
	if(Q[0]&lt;=C[u].d[0]&amp;&amp;Q[2]&gt;=C[u].d[0]&amp;&amp;Q[1]&lt;=C[u].d[1]&amp;&amp;Q[3]&gt;=C[u].d[1])ans+=C[u].val;
	if(inside(C[u].ls))query(C[u].ls);
	if(inside(C[u].rs))query(C[u].rs);
}
int main() {
	for(n=gi(),p=gi();p^3;p=gi()) {
		if(p&lt;2)Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,insert(rt,0);
		else Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,Q[3]=gi()^ans,ans=0,query(rt),printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem4066</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
const int N=200005;
const double bal=0.6180339887498949;
int n,cnd,cmp_d,Q[4],rt,tp,stk[N],ans,p;
struct node{int d[2],mx[2],mi[2],size,sum,ls,rs,val;}C[N];
inline void cmin(int&amp;a,const int&amp;b){if(b&lt;a)a=b;}
inline void cmax(int&amp;a,const int&amp;b){if(a&lt;b)a=b;}
bool cmp(const int&amp;a,const int&amp;b) {return C[a].d[cmp_d]&lt;C[b].d[cmp_d];}
inline void update(int x) {
	static int i,l,r;
	node&amp;u=C[x];
	l=u.ls,r=u.rs;
	u.sum=C[l].sum+C[r].sum+u.val;
	u.size=C[l].size+C[r].size+1;
	for(i=0;i^2;++i) {
		if(l)cmin(u.mi[i],C[l].mi[i]),cmax(u.mx[i],C[l].mx[i]);
		if(r)cmin(u.mi[i],C[r].mi[i]),cmax(u.mx[i],C[r].mx[i]);
	}
}
void build(int&amp;u,int l,int r,int _d) {
	int md=l+r&gt;&gt;1;  cmp_d=_d;
	nth_element(stk+l,stk+md,stk+r+1,cmp);
	u=stk[md]; C[u].sum=C[u].val;
	C[u].mx[0]=C[u].mi[0]=C[u].d[0];
	C[u].mx[1]=C[u].mi[1]=C[u].d[1];
	if(l&lt;md)build(C[u].ls,l,md-1,_d^1);
	if(md&lt;r)build(C[u].rs,md+1,r,_d^1);
	update(u);
}
void del(int&amp;u) {
	if(!u) return;
	stk[++tp]=u; del(C[u].ls),del(C[u].rs); u=0;
}
inline void rebuild(int&amp;u,int _d) {
	stk[tp=1]=++cnd; C[cnd].size=1;
	C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
	C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
	C[cnd].sum=C[cnd].val=Q[2];
	del(u); build(u,1,tp,_d);
}
void insert(int&amp;u,int _d) {
	if(!u) {
		u=++cnd; C[u].size=1;
		C[cnd].mx[0]=C[cnd].mi[0]=C[cnd].d[0]=Q[0];
		C[cnd].mx[1]=C[cnd].mi[1]=C[cnd].d[1]=Q[1];
		C[cnd].sum=C[cnd].val=Q[2];
		return;
	}
	if(Q[_d]&lt;C[u].d[_d]) {
		if(C[C[u].ls].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].ls,_d^1);
	} else {
		if(C[C[u].rs].size&gt;C[u].size*bal)rebuild(u,_d);
		else insert(C[u].rs,_d^1);
	}update(u);
}
inline bool inside(const int&amp;u) {
	if(!u)return 0;
	return Q[0]&lt;=C[u].mx[0]&amp;&amp;Q[2]&gt;=C[u].mi[0]&amp;&amp;Q[1]&lt;=C[u].mx[1]&amp;&amp;Q[3]&gt;=C[u].mi[1];
}
void query(int u) {
	if(Q[0]&lt;=C[u].mi[0]&amp;&amp;Q[2]&gt;=C[u].mx[0]&amp;&amp;Q[1]&lt;=C[u].mi[1]&amp;&amp;Q[3]&gt;=C[u].mx[1]){ans+=C[u].sum;return;}
	if(Q[0]&lt;=C[u].d[0]&amp;&amp;Q[2]&gt;=C[u].d[0]&amp;&amp;Q[1]&lt;=C[u].d[1]&amp;&amp;Q[3]&gt;=C[u].d[1])ans+=C[u].val;
	if(inside(C[u].ls))query(C[u].ls);
	if(inside(C[u].rs))query(C[u].rs);
}
int main() {
	for(n=gi(),p=gi();p^3;p=gi()) {
		if(p&lt;2)Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,insert(rt,0);
		else Q[0]=gi()^ans,Q[1]=gi()^ans,Q[2]=gi()^ans,Q[3]=gi()^ans,ans=0,query(rt),printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
<pre><h2>Problem4129</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 50003
#define wlp while
#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
#define FOR(i, u) for (edge *i = g[u]; i; i = i-&gt;n)
struct edge {int t; edge *n;} me[N&lt;&lt;1|1], *g[N], *ce = me;
#define adde(a, b) (*ce = (edge) {b, g[a]}, g[a] = ce++)
struct quy{int l, r, t, id, lca;} Q[N];
struct chg{int x, y, pre;} P[N];
int bel[N&lt;&lt;1|1], que[N&lt;&lt;1|1], in[N], ou[N], fa[N], son[N], tp[N], dep[N], dfn;
int n, cnt[N], L[225], full[225], now[225], blo[N], a[N], _a[N];
bool sta[N];
bool operator &lt; (const quy &amp;a, const quy &amp;b) {
	if (bel[a.l] ^ bel[b.l]) return bel[a.l] &lt; bel[b.l];
	if (bel[a.r] ^ bel[b.r]) return bel[a.r] &lt; bel[b.r];
	return a.t &lt; b.t;
}

int d1(int u, int f) {
	int r = 1, mx = -1, t;
	dep[u] = dep[f] + 1;
	fa[u] = f;
	FOR(it, u) if (it-&gt;t ^ f) {
		t = d1(it-&gt;t, u);
		if (t &gt; mx) mx = t, son[u] = it-&gt;t;
		r += t;
	}
	return r;
}
void d2(int u, int anc) {
	que[in[u] = ++dfn] = u;
	tp[u] = anc;
	if (son[u]) d2(son[u], anc);
	FOR(it, u) if (!tp[it-&gt;t]) d2(it-&gt;t, it-&gt;t);
	que[ou[u] = ++dfn] = u;
}
inline int LCA(int u, int v) {
	wlp (tp[u] ^ tp[v]) dep[tp[u]] &lt; dep[tp[v]] ? v = fa[tp[v]] : u = fa[tp[u]];
	return dep[u] &lt; dep[v] ? u : v;
}

inline int mex() {
	static int i;
	for (i = 0;!(full[i] ^ now[i]); ++i);
	for (i = L[i]; cnt[i]; ++i);
	return i;
}
inline void rev(const int &amp;u) {
	if (a[u] &lt;= n) {
		if (sta[u]) (--cnt[a[u]]) ? 0 : --now[blo[a[u]]];
		else (cnt[a[u]]++) ? 0 : ++now[blo[a[u]]];
	}
	sta[u] ^= 1;
}
inline void upd(int x, int y) {
	if (sta[x]) rev(x), a[x] = y, rev(x);
	else a[x] = y;
}
inline void timetravel(int &amp;ct, const int &amp;goal) {
	while (ct &lt; goal)  ++ct, upd(P[ct].x, P[ct].y);
	while (goal &lt; ct) upd(P[ct].x, P[ct].pre), --ct;
}
int main() {

	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	
	int m, i, u, v, block, t, ct, _P = 0, _Q = 0, l, r, _l, _r;
	
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	rep(i, 1, n) scanf(&quot;%d&quot;, a + i), _a[i] = a[i];
	
	rep(i, 2, n) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		adde(u, v); adde(v, u);
	}
	
	d1(1, 0); d2(1, 1);
	
	rep(i, 1, m) {
		scanf(&quot;%d%d%d&quot;, &amp;block, &amp;u, &amp;v);
		if (block) {
			ct = LCA(u, v);
			if (in[v] &lt; in[u]) std::swap(u, v);
			if (ct ^ u) Q[_Q] = (quy) {ou[u], in[v], _P, _Q, ct};
			else Q[_Q] = (quy) {in[u], in[v], _P, _Q, 0};
			++_Q;
		} else P[++_P] = (chg){u, v, _a[u]}, _a[u] = v;
	}

	for (block = 1; block * block &lt; n; ++block);

	rep(i, 0, n) blo[i] = i / block;
	
	for (i = 0; i &lt;= n; i += block) L[blo[i]] = i, full[blo[i]] = block;
	
	for (block = 1; block * block * block &lt; dfn; ++block);
	block *= block;
	rep(i, 1, dfn) bel[i] = (i - 1) / block;
	
	std::sort(Q, Q + _Q);
	l = 1, r = 0, ct = 0;
	for (i = 0; i &lt; _Q; ++i) {
		_l = Q[i].l, _r = Q[i].r;
		timetravel(ct, Q[i].t);
		wlp (l &lt; _l) rev(que[l++]);
		wlp (l &gt; _l) rev(que[--l]);
		wlp (r &lt; _r) rev(que[++r]);
		wlp (r &gt; _r) rev(que[r--]);
		if (Q[i].lca) rev(Q[i].lca);
		_a[Q[i].id] = mex();
		if (Q[i].lca) rev(Q[i].lca);
	}
	for (i = 0; i &lt; _Q; ++i)
		printf(&quot;%d\n&quot;, _a[i]);
	return 0;
}
<pre><h2>Problem4152</h2><pre>#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef pair&lt;int, int&gt; pr;
priority_queue&lt;pr&gt;heap;
#define inf 0x7fffffff
#define N 200005
struct edge {int t, v; edge *n;} me[N * 8 + 1], *g[N * 3], *ce = me;
struct node {int x, y, id;} a[N];
#define adde(a, b, c) (ce-&gt;t = b, ce-&gt;v = c, ce-&gt;n = g[a], g[a] = ce++)
inline void link(int a, int b, int c) {
	adde(a, b, c);
	adde(b, a, c);
}
int d[N * 3], cnd;
bool cx(const node &amp;a, const node &amp;b) {
	return a.x &lt; b.x;
}
bool cy(const node &amp;a, const node &amp;b) {
	return a.y &lt; b.y;
}
inline bool cmin(int &amp;a, const int &amp;b) {
	if (b &lt; a) return a = b, true;
	return false;
}
inline void dijstra() {
	int u, v, dis;
	edge *it;
	heap.push(make_pair(0, 1));
	while (!heap.empty()) {
		u = heap.top().second;
		dis = -heap.top().first;
		heap.pop();
		if (dis ^ d[u]) continue;
		for (it = g[u]; it; it = it-&gt;n)
			if (cmin(d[v = it-&gt;t], dis + it-&gt;v))
				heap.push(make_pair(-d[v], v));
	}
}

int main() {
	int n, i, j, x, y;
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 0; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		a[i] = (node) {x, y, i + 1};
	}
	cnd = n;
	sort(a, a + n, cx);
	a[n] = (node) {inf, inf};
	for (y = i = 0; i &lt; n; i = j) {
		++cnd;
		for (j = i; a[j].x == a[i].x; ++j)
			link(cnd, a[j].id, 0);
		if (y) link(cnd, y, a[i].x - x);
		x = a[i].x, y = cnd;
	}
	sort(a, a + n, cy);
	for (y = i = 0; i &lt; n; i = j) {
		++cnd;
		for (j = i; a[j].y == a[i].y; ++j)
			link(cnd, a[j].id, 0);
		if (y) link(cnd, y, a[i].y - x);
		x = a[i].y, y = cnd;
	}
	for (i = 1; i &lt;= cnd; ++i) d[i] = inf;
	d[1] = 0;
	dijstra();
	printf(&quot;%d\n&quot;, d[n]);
	return 0;
}<pre><h2>Problem4161</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

typedef long long calc_t;
const int mod_v = 1000000007;
const int MaxN = 4010;
int n, base[MaxN], poly0[MaxN], poly1[MaxN], init_v[MaxN];

void subsititute(int *x, int pos)
{
	calc_t v = x[pos];
	if(!v) return;
	for(int i = 0; i != n; ++i)
		x[pos - i - 1] = (x[pos - i - 1] + base[i] * v) % mod_v;
}

void poly_mul(int *dest, int *x, int* y)
{
	static int tmp[MaxN];
	std::fill(tmp, tmp + 2 * n, 0);
	for(int i = 0; i != n; ++i)
		for(int j = 0; j != n; ++j)
			tmp[i + j] = (tmp[i + j] + (calc_t)x[i] * y[j]) % mod_v;
	for(int i = 2 * (n - 1); i &gt;= n; --i)
		subsititute(tmp, i);
	std::copy(tmp, tmp + n, dest);
}

void poly_shift(int *x, int z)
{
	for(int i = 2 * (n - 1); i &gt;= z; --i)
		x[i] = x[i - z];
	for(int i = 0; i != z; ++i) x[i] = 0;
	for(int i = 2 * (n - 1); i &gt;= n; --i)
		subsititute(x, i);
}

void poly_pow(int *v, int *x, int p)
{
	std::fill(v, v + n, 0);
	v[0] = 1;
	while(p)
	{
		if(p &amp; 1) poly_mul(v, x, v);
		if(p &gt;&gt; 1) poly_mul(x, x, x);
		p &gt;&gt;= 1;
	}
}

int main()
{
	int p;
	std::scanf(&quot;%d %d&quot;, &amp;p, &amp;n);
	for(int i = 0; i != n; ++i)
	{
		std::scanf(&quot;%d&quot;, base + i);
		base[i] = (base[i] % mod_v + mod_v) % mod_v;
	}

	for(int i = 0; i != n; ++i)
	{
		std::scanf(&quot;%d&quot;, init_v + i);
		init_v[i] = (init_v[i] % mod_v + mod_v) % mod_v;
	}

	if(p &lt;= n) 
	{
		std::printf(&quot;%d\n&quot;, init_v[p - 1]);
	} else {
		std::reverse_copy(base, base + n, poly1);
		poly_pow(poly0, poly1, p / n);
		poly_shift(poly0, p % n);
		int ans = 0;
		for(int i = 0; i != n; ++i)
			ans = (ans + (calc_t)init_v[i] * poly0[i]) % mod_v;

		std::printf(&quot;%d\n&quot;, ans);
	}

	return 0;
}<pre><h2>Problem4161</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 4005
#define Mod 1000000007
#define rep(i, l, r) for (register int i = l; i &lt; r; ++i)
#define rrp(i, l, r) for (register int i = l; i &gt;= r; --i)
typedef long long i64;
typedef int arr[N];
arr base, p0, p1, initv;
int n;
const size_t SINT = sizeof (int);

inline void mov(int &amp;x, long long b) {
	x = (x + b) % Mod;
}

inline void sub(int *x, int pos) {
	static i64 v;
	if (!(v = x[pos]))
	  return;
	rep(i, 0, n)
		mov(x[pos - i - 1], v * base[i]);
}

inline void mul(int *dest, int *x, int *y) {
	static arr t;
	memset(t, 0, n * 2 * SINT);
	rep(i, 0, n)
		rep(j, 0, n)
		mov(t[i + j], (long long)x[i] * y[j]);
	rrp(i, 2 * (n - 1), n)
		sub(t, i);
	memcpy(dest, t, n * SINT);
}
inline void shift(int *x, int z) {
	rrp(i, 2 * (n - 1), z)
		x[i] = x[i - z];
	memset(x, 0, z * SINT);
	rrp(i, 2 * (n - 1), n)
		sub(x, i);
}

inline void _pow(int *v, int *x, int p) {
	memset(v, 0, n * SINT);
	v[0] = 1;
	while (p) {
		if (p &amp; 1) mul(v, x, v);
		if (p &gt;&gt;= 1) mul(x, x, x);
	}
}

int main() {
	int p;
	scanf(&quot;%d%d&quot;, &amp;p, &amp;n);
	rep(i, 0, n) {
		scanf(&quot;%d&quot;, base + i);
		if (base[i] &lt; 0) base[i] += Mod;
	}
	rep(i, 0, n) {
		scanf(&quot;%d&quot;, initv + i);
		if (initv[i] &lt; 0) initv[i] += Mod;
	}
	if (p &lt;= n) 
	  return printf(&quot;%d\n&quot;, initv[p - 1]), 0;

	rep(i, 0, n)
		p1[i] = base[n - 1 - i];

	_pow(p0, p1, p / n);
	shift(p0, p % n);
	int ans = 0;
	rep(i, 0, n)
		mov(ans, (i64)initv[i] * p0[i]);
	
	printf(&quot;%d\n&quot;, ans);
	
	return 0;
}<pre><h2>Problem4197</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

int f[257][257], p[2][257][257], mod, n, ans;
static const int pr[] = {2, 3, 5, 7, 11, 13, 17, 19, 0};

struct num {
	int big, small;
} s[505];

inline bool operator &lt; (const num &amp;a, const num &amp;b) {
	return (a.big ^ b.big) ? a.big &lt; b.big : a.small &lt; b.small;
}

inline void mov(int &amp;a, const int &amp;b) {
	a += b;
	if (a &gt;= mod) a -= mod;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;mod);
	for (int i = 2; i &lt;= n; ++i) {
		int t = i, s = 0;
		for (int _ = 0; _ &lt; 8; ++_)
			if (t % pr[_] == 0) {
				s ^= 1 &lt;&lt; _;
				while (t % pr[_] == 0) t /= pr[_];
			}
		::s[i] = (num) {t, s};
	}
	std::sort(s + 2, s + n + 1);
	f[0][0] = 1;
	for (int i = 2; i &lt;= n; ++i) {
		if (s[i].big == 1 || s[i].big != s[i - 1].big) {
			memcpy(p[0], f, sizeof f);
			memcpy(p[1], f, sizeof f);
		}
		for (int j = 255; ~j; --j)
			for (int k = 255; ~k; --k) {
				if ((j &amp; s[i].small) == 0)
					mov(p[0][j][k | s[i].small], p[0][j][k]);
				if ((k &amp; s[i].small) == 0)
					mov(p[1][j | s[i].small][k], p[1][j][k]);
			}
		if (s[i].big == 1 || s[i].big != s[i + 1].big) {
			for (int j = 255; ~j; --j)
				for (int k = 255; ~k; --k) {
					f[j][k] = (p[0][j][k] + p[1][j][k] - f[j][k]) % mod + mod;
					while (f[j][k] &gt;= mod) f[j][k] -= mod;
				}
		}
	}
	for (int j = 255; ~j; --j)
		for (int k = 255; ~k; --k)
			if ((j &amp; k) == 0) mov(ans, f[j][k]);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4198</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;


inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

struct data {
	long long cnt;
	int len;
	data(long long cnt, int len) :
		cnt(cnt), len(len) {}
};

bool operator &lt; (const data &amp;a, const data &amp;b) {
	return (a.cnt ^ b.cnt) ? a.cnt &gt; b.cnt : a.len &gt; b.len;
}

int main() {
	static int n, k, cnt, len;
	static long long x, ans = 0, tmp;
	static std::priority_queue&lt;data&gt; heap;

	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);

	for (int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;x);
		heap.push(data(x, 1));
	}

	cnt = n;
	if ((n - 1) % (k - 1))
		cnt += k - 1 - (n - 1) % (k - 1);

	for (int i = n + 1; i &lt;= cnt; ++i)
		heap.push(data(0, 1));

	while (cnt &gt; 1) {
		tmp = len = 0;
		for (int _ = 0; _ &lt; k; ++_) {
			tmp += heap.top().cnt;
			cmax(len, heap.top().len);
			heap.pop();
		}
		ans += tmp;
		heap.push(data(tmp, len + 1));
		cnt = cnt - k + 1;
	}

	printf(&quot;%lld\n%d\n&quot;, ans, heap.top().len - 1);
	return 0;
}
<pre><h2>Problem4199</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const long long llf = 1LL &lt;&lt; 60;
const int MaxS = 600003, MaxN = 300003, inf = 0x3fffffff;
typedef int _[MaxN];
typedef long long __[MaxN];
struct node {
	int step, mx, mi, size;
	long long a1, a2;
	node *pre, *c[26];
} node_mset[MaxS], *cnode = node_mset, *root, *last, *order[MaxS];

inline node *newnode(const int &amp;step, int mx = -inf, int mi = inf, int size = 0) {
	cnode-&gt;mx = mx;
	cnode-&gt;mi = mi;
	cnode-&gt;size = size;
	cnode-&gt;step = step;
	cnode-&gt;a2 = -llf;
	return cnode++;
}

_ a, cnt;
__ ans1, ans2;

inline void Insert(const int &amp;c, const int &amp;val) {
	node *p = last, *np = newnode(p-&gt;step + 1, val, val, 1);
	for (last = np; p &amp;&amp; !p-&gt;c[c]; p = p-&gt;pre)
		p-&gt;c[c] = np;
	if (!p)
		np-&gt;pre = root;
	else {
		node *q = p-&gt;c[c];
		if (q-&gt;step == p-&gt;step + 1)
			np-&gt;pre = q;
		else {
			node *nq = newnode(p-&gt;step + 1);
			memcpy(nq-&gt;c, q-&gt;c, sizeof q-&gt;c);
			nq-&gt;pre = q-&gt;pre;
			q-&gt;pre = np-&gt;pre = nq;
			for (; p &amp;&amp; p-&gt;c[c] == q; p = p-&gt;pre)
				p-&gt;c[c] = nq;
		}
	}
}

char s[MaxN];
template&lt;class T&gt;
inline void cmin(T &amp;a, const T &amp;b) {
	if (b &lt; a) a = b;
}
template&lt;class T&gt;
inline void cmax(T &amp;a, const T &amp;b) {
	if (a &lt; b) a = b;
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, mxstep = 0;
	scanf(&quot;%d%s&quot;, &amp;n, s);
	last = root = newnode(0);
	for (int i = 0; i &lt; n; ++i) {
		scanf(&quot;%d&quot;, a + i);
		ans2[i] = -llf;
	}
	for (int i = n - 1; ~i; --i) Insert(s[i] - 'a', a[i]);
	for (node *i = node_mset; i &lt; cnode; ++i) {
		if (i-&gt;step &gt; mxstep)
			mxstep = i-&gt;step;
		++cnt[i-&gt;step];
	}
	++mxstep;
	for (int i = 1; i &lt; mxstep; ++i) cnt[i] += cnt[i - 1];
	for (node *i = node_mset; i &lt; cnode; ++i) order[--cnt[i-&gt;step]] = i;
	node *u, *f;
	for (int i = cnode - node_mset - 1; ~i; --i)
		if (f = (u = order[i])-&gt;pre) {
			f-&gt;a1 += (long long)f-&gt;size * u-&gt;size;
			f-&gt;size += u-&gt;size;
			if (f-&gt;mx ^ -inf) cmax(f-&gt;a2, (long long)f-&gt;mx * u-&gt;mx);
			if (f-&gt;mi ^  inf) cmax(f-&gt;a2, (long long)f-&gt;mi * u-&gt;mi);
			cmax(f-&gt;mx, u-&gt;mx);
			cmin(f-&gt;mi, u-&gt;mi);
		}
	for (node *i = node_mset; i &lt; cnode; ++i) {
		ans1[i-&gt;step] += i-&gt;a1;
		cmax(ans2[i-&gt;step], i-&gt;a2);
	}
	for (int i = n - 2; ~i; --i)
		if (ans1[i + 1]) {
			ans1[i] += ans1[i + 1];
			cmax(ans2[i], ans2[i + 1]);
		}
	for (int i = 0; i &lt; n; ++i)
		printf(&quot;%lld %lld\n&quot;, ans1[i], ans1[i] ? ans2[i] : 0LL);
	return 0;
}<pre><h2>Problem4237</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 200005
#define wlp while
std::pair&lt;int, int&gt; p[N], t[N], s1[N], s2[N];
long long ans;
int tp1, tp2;
inline bool cy(const std::pair&lt;int, int&gt; &amp;a, const std::pair&lt;int, int&gt; &amp;b) {
	return (a.second ^ b.second) ? a.second &lt; b.second : a.first &lt; b.first;
}
inline void conbi(const int &amp;x, int l, int r) {
	for (static int m; l &lt;= r; )
		if (s2[m = l + r &gt;&gt; 1].second &lt; x)
			l = m + 1;
		else
			r = m - 1;
	ans += tp2 - (l - 1);
}
void divide(int l, int r) {
	if (l &gt;= r) return;
	int m = l + r &gt;&gt; 1;
	divide(l, m); divide(m + 1, r);
	tp1 = tp2 = 0;
	for (register int i = m + 1, pos = l; i &lt;= r; ++i) {
		while (tp1 &amp;&amp; s1[tp1].first &gt; p[i].first) --tp1;
		s1[++tp1] = p[i];
		while (pos &lt;= m &amp;&amp; p[pos].second &lt; p[i].second) {
			while (tp2 &amp;&amp; s2[tp2].first &lt; p[pos].first) --tp2;
			s2[++tp2] = p[pos++];
		}
		conbi(s1[tp1 - 1].second, 1, tp2);
	}
	for (register int i = l, i1 = l, i2 = m + 1; i &lt;= r; ++i)
		if (i1 &gt; m || (i2 &lt;= r &amp;&amp; cy(p[i2], p[i1])))
			t[i] = p[i2++];
		else
			t[i] = p[i1++];
	for (register int i = l; i &lt;= r; ++i)
		p[i] = t[i];
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, i;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 0; i &lt; n; ++i)
		scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second);
	std::sort(p, p + n);
	divide(0, n - 1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4237</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 200005
#define wlp while
std::pair&lt;int, int&gt; p[N], t[N], s1[N], s2[N];
long long ans;
int tp1, tp2;
inline int gi() {
	static int a;
	static char c;
	wlp (c = getchar(), c &lt; '0'); a = c - '0';
	wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
inline void conbi(const int &amp;x, int l, int r) {
	for (static int m; l &lt;= r; )
		if (s2[m = l + r &gt;&gt; 1].second &lt; x)
			l = m + 1;
		else
			r = m - 1;
	ans += tp2 - (l - 1);
}
void divide(int l, int r) {
	if (l &gt;= r) return;
	int m = l + r &gt;&gt; 1;
	divide(l, m); divide(m + 1, r);
	tp1 = tp2 = 0;
	for (register int i = m + 1, pos = l; i &lt;= r; ++i) {
		wlp (tp1 &amp;&amp; s1[tp1].first &gt; p[i].first) --tp1;
		s1[++tp1] = p[i];
		wlp (pos &lt;= m &amp;&amp; p[pos].second &lt; p[i].second) {
			while (tp2 &amp;&amp; s2[tp2].first &lt; p[pos].first) --tp2;
			s2[++tp2] = p[pos++];
		}
		conbi(s1[tp1 - 1].second, 1, tp2);
	}
	for (register int i = l, i1 = l, i2 = m + 1; i &lt;= r; ++i)
		if (i1 &gt; m || (i2 &lt;= r &amp;&amp; p[i2].second &lt; p[i1].second))
			t[i] = p[i2++];
		else
			t[i] = p[i1++];
	for (register int i = l; i &lt;= r; ++i)
		p[i] = t[i];
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n = gi();
	//scanf(&quot;%d&quot;, &amp;n);
	for (register int i = 0; i &lt; n; ++i)
		//scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second);
		p[i] = std::make_pair(gi(), gi());
	std::sort(p, p + n);
	divide(0, n - 1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4237</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 200005
#define wlp while
struct P{int x, y;} p[N], t[N], s1[N], s2[N];
bool operator &lt; (const P &amp;a, const P &amp;b) {
	return a.x &lt; b.x;
}
long long ans;
int tp1, tp2;
inline int gi() {
	static int a;
	static char c;
	wlp (c = getchar(), c &lt; '0'); a = c - '0';
	wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return a;
}
inline void conbi(const int &amp;x, int l, int r) {
	for (static int m; l &lt;= r; )
		if (s2[m = l + r &gt;&gt; 1].y &lt; x)
			l = m + 1;
		else
			r = m - 1;
	ans += tp2 - (l - 1);
}
void divide(int l, int r) {
	if (l &gt;= r) return;
	int m = l + r &gt;&gt; 1;
	divide(l, m); divide(m + 1, r);
	tp1 = tp2 = 0;
	for (register int i = m + 1, pos = l; i &lt;= r; ++i) {
		wlp (tp1 &amp;&amp; s1[tp1].x &gt; p[i].x) --tp1;
		s1[++tp1] = p[i];
		wlp (pos &lt;= m &amp;&amp; p[pos].y &lt; p[i].y) {
			while (tp2 &amp;&amp; s2[tp2].x &lt; p[pos].x) --tp2;
			s2[++tp2] = p[pos++];
		}
		conbi(s1[tp1 - 1].y, 1, tp2);
	}
	for (register int i = l, i1 = l, i2 = m + 1; i &lt;= r; ++i)
		if (i1 &gt; m || (i2 &lt;= r &amp;&amp; p[i2].y &lt; p[i1].y))
			t[i] = p[i2++];
		else
			t[i] = p[i1++];
	for (register int i = l; i &lt;= r; ++i)
		p[i] = t[i];
}

int main() {
	int n = gi();
	for (register int i = 0; i &lt; n; ++i)
		p[i] = (P){gi(), gi()};
	std::sort(p, p + n);
	divide(0, n - 1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4240</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define MAXN 300005

typedef std::pair&lt;int, int&gt; pii;

pii a[MAXN];
int n, c[MAXN];

inline bool cmp(const pii &amp;a, const pii &amp;b) {
	return a.first &gt; b.first;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; ++i) {
		a[i].second = i;
		scanf(&quot;%d&quot;, &amp;a[i].first);
	}
	unsigned long long ans = 0;
	std::sort(a + 1, a + n + 1, cmp);
	for (int i(1), head(1); i &lt;= n; ++i) {
		if (a[i].first ^ a[i - 1].first)
		  while (head &lt; i)
			for (int x(a[head++].second); x &lt;= n; x += x &amp; -x)
			  ++c[x];
		int tmp = 0;
		for (int x(a[i].second); x; x ^= x &amp; -x)
		  tmp += c[x];
		ans += std::min(tmp, head - 1 - tmp);
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem4240</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define MAXN 300005
#define BUFFER_SIZE 3000050

typedef std::pair&lt;int, int&gt; pii;

inline bool cmp(const pii &amp;a, const pii &amp;b) {
	return a.first &gt; b.first;
}

inline void get_int(int &amp;a, char *(&amp;s)) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

int main() {
	static pii a[MAXN];
	static int n, c[MAXN];
	static char buf[BUFFER_SIZE], *s(buf);
	fread(buf, 1, BUFFER_SIZE, stdin);
	get_int(n, s);
	for (int i = 1; i &lt;= n; ++i) {
		a[i].second = i;
		get_int(a[i].first, s);
	}
	unsigned long long ans = 0;
	std::sort(a + 1, a + n + 1, cmp);
	for (int i(1), head(1); i &lt;= n; ++i) {
		if (a[i].first ^ a[i - 1].first)
		  while (head &lt; i)
			for (int x(a[head++].second); x &lt;= n; x += x &amp; -x)
			  ++c[x];
		int tmp = 0;
		for (int x(a[i].second); x; x ^= x &amp; -x)
		  tmp += c[x];
		ans += std::min(tmp, head - 1 - tmp);
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem4240</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define MAXN 300005
#define BUFFER_SIZE 3000050

#define u32 unsigned int
#define pii std::pair&lt;u32, u32&gt;

inline bool cmp(const pii &amp;a, const pii &amp;b) {
	return a.first &gt; b.first;
}

inline void get_u32(u32 &amp;a, char *(&amp;s)) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

int main() {
	static pii a[MAXN];
	static u32 n, c[MAXN];
	static char buf[BUFFER_SIZE], *s(buf);
	fread(buf, 1, BUFFER_SIZE, stdin);
	get_u32(n, s);
	for (u32 i = 1; i &lt;= n; ++i) {
		a[i].second = i;
		get_u32(a[i].first, s);
	}
	unsigned long long ans = 0;
	std::sort(a + 1, a + n + 1, cmp);
	for (u32 i(1), head(1); i &lt;= n; ++i) {
		if (a[i].first ^ a[i - 1].first)
		  while (head &lt; i)
			for (u32 x(a[head++].second); x &lt;= n; x += x &amp; -x)
			  ++c[x];
		u32 tmp = 0;
		for (u32 x(a[i].second); x; x ^= x &amp; -x)
		  tmp += c[x];
		ans += std::min(tmp, head - 1 - tmp);
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem4240</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define MAXN 300005
#define BUFFER_SIZE 3000050

typedef unsigned int u32;
typedef std::pair&lt;u32, u32&gt; pii;

inline bool cmp(const pii &amp;a, const pii &amp;b) {
	return a.first &gt; b.first;
}

inline u32 min(const u32 &amp;a, const u32 &amp;b) {
	return a &lt; b ? a : b;
}

inline void get_u32(u32 &amp;a, char *(&amp;s)) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

int main() {
	static pii a[MAXN];
	static u32 n, c[MAXN];
	static char buf[BUFFER_SIZE], *s(buf);
	fread(buf, 1, BUFFER_SIZE, stdin);
	get_u32(n, s);
	for (u32 i = 1; i &lt;= n; ++i) {
		a[i].second = i;
		get_u32(a[i].first, s);
	}
	unsigned long long ans = 0;
	std::stable_sort(a + 1, a + n + 1, cmp);
	for (register u32 i(1), head(1); i &lt;= n; ++i) {
		if (a[i].first ^ a[i - 1].first)
		  while (head &lt; i)
			for (register u32 x(a[head++].second); x &lt;= n; x += x &amp; -x)
			  ++c[x];
		u32 tmp = 0;
		for (register u32 x(a[i].second); x; x ^= x &amp; -x)
		  tmp += c[x];
		ans += min(tmp, head - 1 - tmp);
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem4240</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define MAXN 300005
#define BUFFER_SIZE 3000050

typedef unsigned int u32;
typedef std::pair&lt;u32, u32&gt; pii;

inline bool cmp(const pii &amp;a, const pii &amp;b) {
	return a.first &gt; b.first;
}

inline u32 min(const u32 &amp;a, const u32 &amp;b) {
	return a &lt; b ? a : b;
}

inline void get_u32(u32 &amp;a, char *(&amp;s)) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

int main() {
	static pii a[MAXN];
	static u32 n, c[MAXN];
	static char buf[BUFFER_SIZE], *s(buf);
	fread(buf, 1, BUFFER_SIZE, stdin);
	get_u32(n, s);
	for (u32 i = 1; i &lt;= n; ++i) {
		a[i].second = i;
		get_u32(a[i].first, s);
	}
	unsigned long long ans = 0;
	std::sort(a + 1, a + n + 1, cmp);
	for (register u32 i(1), head(1); i &lt;= n; ++i) {
		if (a[i].first ^ a[i - 1].first)
		  while (head &lt; i)
			for (register u32 x(a[head++].second); x &lt;= n; x += x &amp; -x)
			  ++c[x];
		u32 tmp = 0;
		for (register u32 x(a[i].second); x; x ^= x &amp; -x)
		  tmp += c[x];
		ans += min(tmp, head - 1 - tmp);
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem4241</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
int cnt[N], a[N], pre[319][N], bel[N], L[319], R[319], stk[713], f[319][319], hash[N];
bool vis[N];
char buf[6000001], *s, *e;
inline void gi(int &amp;a) {
	wlp (*s &lt; '0') ++s; a = *s++ - '0';
	wlp ('-' &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++) - '0';
}
int main() {

	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	e = buf + fread(s = buf, 1, 6000001, stdin);
	int n, q, blo, t, *hcnt, *tp, l, r;
	register int i, j, k;
	long long mx, _t;
	gi(n), gi(q);
	rep(i, 1, n) gi(a[i]), hash[i] = a[i];
	std::sort(hash + 1, hash + n + 1);
	hcnt = std::unique(hash + 1, hash + n + 1);
	rep(i, 1, n) a[i] = std::lower_bound(hash + 1, hcnt, a[i]) - hash;
	for (blo = 1; blo * blo &lt;= n; ++blo);
	rep(i, 1, n) R[bel[i] = (i - 1) / blo + 1] = i;
	for (i = 1; i &lt;= n; i += blo) L[bel[i]] = i;
	
	rep(i, 1, bel[n]) {
		rep(j, L[i], R[i]) ++cnt[a[j]];
		memcpy(pre[i], cnt, sizeof cnt);
	}
	
	rep(i, 1, bel[n]) {
		//memset(cnt, 0, sizeof cnt);
		mx = 0LL; k = L[i], t = a[L[i]];
		rep(j, i, bel[n]) {
			wlp (k &lt;= R[j]) {
				_t = (long long)(pre[j][a[k]] - pre[i - 1][a[k]]) * hash[a[k]];
				if (_t &gt; mx) mx = _t, t = a[k];
				++k;
			}
			f[i][j] = t;
		}
	}

	memset(cnt, 0, sizeof cnt);

	//printf(&quot;pretime : %lf\n&quot;, (double)clock() /CLOCKS_PER_SEC);
	
	wlp (q--) {
		gi(l), gi(r);
		tp = stk, mx = -1LL;
		if (bel[l] + 1 &lt;=  bel[r] - 1) {
			*++tp = f[bel[l] + 1][bel[r] - 1];
			vis[*tp] = true;
			j = R[bel[l]];
			rep(i, l, j) if (++cnt[a[i]], !vis[a[i]]) vis[*++tp = a[i]] = true;
			rep(i, L[bel[r]], r) if (++cnt[a[i]], !vis[a[i]]) vis[*++tp = a[i]] = true;
			rep (hcnt, stk + 1, tp) {
				j = *hcnt;
				_t = (long long)(cnt[j] + pre[bel[r] - 1][j] - pre[bel[l]][j]) * hash[j];
				if (_t &gt; mx) mx = _t;
			}
		} else {
			rep(i, l, r) if (++cnt[a[i]], !vis[a[i]]) vis[*++tp = a[i]] = true;
			rep(hcnt, stk + 1, tp) {
				_t = (long long) cnt[*hcnt] * hash[*hcnt];
				if (_t &gt; mx) mx = _t;
			}
		}
		printf(&quot;%lld\n&quot;, mx);
		wlp (stk &lt; tp) cnt[*tp] = 0, vis[*tp] = false, --tp;
	}

	//printf(&quot;pretime : %lf\n&quot;, (double)clock() /CLOCKS_PER_SEC);
	
	return 0;
}
<pre><h2>Problem4241</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
int cnt[N], a[N], pre[319][N], bel[N], L[319], R[319], stk[713], f[319][319], hash[N];
char buf[6000001], *s, *e;
inline void gi(int &amp;a) {
    wlp (*s &lt; '0') ++s; a = *s++ - '0';
    wlp ('-' &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++) - '0';
}
int main() {
    e = buf + fread(s = buf, 1, 6000001, stdin);
    int n, q, blo, t, *hcnt, *tp, l, r;
    register int i, j, k;
    long long mx, _t;
    gi(n), gi(q);
    rep(i, 1, n) gi(a[i]), hash[i] = a[i];
    std::sort(hash + 1, hash + n + 1);
    hcnt = std::unique(hash + 1, hash + n + 1);
    rep(i, 1, n) a[i] = std::lower_bound(hash + 1, hcnt, a[i]) - hash;
    for (blo = 1; blo * blo &lt;= n; ++blo);
    rep(i, 1, n) R[bel[i] = (i - 1) / blo + 1] = i;
    for (i = 1; i &lt;= n; i += blo) L[bel[i]] = i;
     
    rep(i, 1, bel[n]) {
        rep(j, L[i], R[i]) ++cnt[a[j]];
        memcpy(pre[i], cnt, sizeof cnt);
    }
     
    rep(i, 1, bel[n]) {
        mx = 0LL; k = L[i], t = a[L[i]];
        rep(j, i, bel[n]) {
            wlp (k &lt;= R[j]) {
                _t = (long long)(pre[j][a[k]] - pre[i - 1][a[k]]) * hash[a[k]];
                if (_t &gt; mx) mx = _t, t = a[k];
                ++k;
            }
            f[i][j] = t;
        }
    }
 
    memset(cnt, 0, sizeof cnt);
     
    wlp (q--) {
        gi(l), gi(r);
        tp = stk, mx = -1LL;
        if (bel[l] + 1 &lt;=  bel[r] - 1) {
            *++tp = f[bel[l] + 1][bel[r] - 1];
            j = R[bel[l]];
            rep(i, l, j) ++cnt[*++tp = a[i]];
            rep(i, L[bel[r]], r) ++cnt[*++tp = a[i]];
			int *sx = pre[bel[l]], *sy = pre[bel[r] - 1];
            rep (hcnt, stk + 1, tp) {
                j = *hcnt;
                _t = (long long)(cnt[j] + sy[j] - sx[j]) * hash[j];
                if (_t &gt; mx) mx = _t;
            }
        } else {
            rep(i, l, r) ++cnt[*++tp = a[i]];
            rep(hcnt, stk + 1, tp) {
                _t = (long long) cnt[*hcnt] * hash[*hcnt];
                if (_t &gt; mx) mx = _t;
            }
        }
        printf(&quot;%lld\n&quot;, mx);
        wlp (stk &lt; tp) cnt[*tp--] = 0;
    }
     
    return 0;
}<pre><h2>Problem4241</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
int cnt[N], a[N], pre[319][N], bel[N], L[319], R[319], stk[713], hash[N];
long long f[319][319];
char buf[6000001], *s, *e;
inline void gi(int &amp;a) {
    wlp (*s &lt; '0') ++s; a = *s++ - '0';
    wlp ('-' &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++) - '0';
}
int main() {
    e = buf + fread(s = buf, 1, 6000001, stdin);
    int n, q, blo, t, *hcnt, *tp, l, r;
    register int i, j, k;
    long long mx, _t;
    gi(n), gi(q);
    rep(i, 1, n) gi(a[i]), hash[i] = a[i];
    std::sort(hash + 1, hash + n + 1);
    hcnt = std::unique(hash + 1, hash + n + 1);
    rep(i, 1, n) a[i] = std::lower_bound(hash + 1, hcnt, a[i]) - hash;
    for (blo = 1; blo * blo &lt;= n; ++blo);
    rep(i, 1, n) R[bel[i] = (i - 1) / blo + 1] = i;
    for (i = 1; i &lt;= n; i += blo) L[bel[i]] = i;
      
    rep(i, 1, bel[n]) {
        rep(j, L[i], R[i]) ++cnt[a[j]];
        memcpy(pre[i], cnt, sizeof cnt);
    }
      
    rep(i, 1, bel[n]) {
        mx = 0LL; k = L[i], t = a[L[i]];
        rep(j, i, bel[n]) {
            wlp (k &lt;= R[j]) {
                _t = (long long)(pre[j][a[k]] - pre[i - 1][a[k]]) * hash[a[k]];
                if (_t &gt; mx) mx = _t;
                ++k;
            }
            f[i][j] = mx;
        }
    }
	
    memset(cnt, 0, sizeof cnt);
      
    wlp (q--) {
        gi(l), gi(r);
        tp = stk, mx = -1LL;
        if (bel[l] + 1 &lt;=  bel[r] - 1) {
			int *sx = pre[bel[l]], *sy = pre[bel[r] - 1];
			mx = f[bel[l] + 1][bel[r] - 1];
            j = R[bel[l]];
            rep(i, l, j) if (!cnt[a[i]]++) *++tp = a[i], cnt[*tp] += sy[*tp] - sx[*tp];
            rep(i, L[bel[r]], r) if (!cnt[a[i]]++) *++tp = a[i], cnt[*tp] += sy[*tp] - sx[*tp];
        } else rep(i, l, r) if (!cnt[a[i]]++) *++tp = a[i];

		rep(hcnt, stk + 1, tp) {
			_t = (long long) cnt[*hcnt] * hash[*hcnt];
			if (_t &gt; mx) mx = _t;
		}
        
        printf(&quot;%lld\n&quot;, mx);
        wlp (stk &lt; tp) cnt[*tp--] = 0;
    }
      
    return 0;
}<pre><h2>Problem4241</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
int cnt[N], a[N], pre[319][N], bel[N], L[319], R[319], stk[713], hash[N];
long long f[319][319];
char buf[6000001], *s, *e;
inline void gi(int &amp;a) {
    wlp (*s &lt; '0') ++s; a = *s++ - '0';
    wlp ('-' &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++) - '0';
}
int main() {
	
    e = buf + fread(s = buf, 1, 6000001, stdin);
    int n, q, blo, t, *hcnt, *tp, l, r, sz;
    register int i, j, k;
    long long mx, _t;
    gi(n), gi(q);
    rep(i, 1, n) gi(a[i]), hash[i] = a[i];
	
    std::sort(hash + 1, hash + n + 1);
    hcnt = std::unique(hash + 1, hash + n + 1);
	rep(i, 1, n) a[i] = std::lower_bound(hash + 1, hcnt, a[i]) - hash;

	//for (blo = 1; blo * blo &lt;= n; ++blo);
	blo = sqrt(n) + 0.5;
    rep(i, 1, n) bel[i] = (i - 1) / blo + 1;
    for (i = 1; i &lt;= n; i += blo) {
		L[bel[i]] = i;
		R[bel[i]] = i + blo - 1;
	}
	R[bel[n]] = n;

	sz = (int)(hcnt - hash) * sizeof(int);
	
    rep(i, 1, bel[n]) {
        rep(j, L[i], R[i]) ++cnt[a[j]];
        memcpy(pre[i], cnt, sz);
    }

	int *sx, *sy;
    rep(i, 1, bel[n]) {
        mx = 0LL;
		k = L[i], t = a[L[i]];
		sx = pre[i - 1];
        rep(j, i, bel[n]) {
			sy = pre[j];
            wlp (k &lt;= R[j]) {
                _t = (long long)(sy[a[k]] - sx[a[k]]) * hash[a[k]];
                if (mx &lt; _t) mx = _t;
                ++k;
            }
            f[i][j] = mx;
        }
    }
	
    memset(cnt, 0, sz);

    wlp (q--) {
        gi(l), gi(r);
        tp = stk, mx = -1LL;
        if (bel[l] + 1 &lt;=  bel[r] - 1) {
            sx = pre[bel[l]], sy = pre[bel[r] - 1];
            mx = f[bel[l] + 1][bel[r] - 1];
            j = R[bel[l]];
            rep(i, l, j) if (!cnt[a[i]]++) *++tp = a[i], cnt[*tp] += sy[*tp] - sx[*tp];
            rep(i, L[bel[r]], r) if (!cnt[a[i]]++) *++tp = a[i], cnt[*tp] += sy[*tp] - sx[*tp];
        } else rep(i, l, r) if (!cnt[a[i]]++) *++tp = a[i];
		
        rep(hcnt, stk + 1, tp) {
            _t = (long long)cnt[*hcnt] * hash[*hcnt];
            if (mx &lt; _t) mx = _t;
        }
		
        printf(&quot;%lld\n&quot;, mx);
        wlp (stk &lt; tp) cnt[*tp--] = 0;
    }
       
    return 0;
}<pre><h2>Problem4241</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
int cnt[N], a[N], pre[319][N], bel[N], L[319], R[319], stk[713], hash[N];
long long f[319][319];
char buf[6000001], *s, *e;
inline void gi(int &amp;a) {
    wlp (*s &lt; '0') ++s; a = *s++ - '0';
    wlp ('-' &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++) - '0';
}
int main() {
    e = buf + fread(s = buf, 1, 6000001, stdin);
    int n, q, blo, t, *hcnt, *tp = stk, l, r, sz, *sx, *sy;
    register int i, j, k;
    long long mx, _t;
    gi(n), gi(q);
    rep(i, 1, n) gi(a[i]);
	memcpy(hash, a, (n + 1) * sizeof(int));
    std::sort(hash + 1, hash + n + 1);
    hcnt = std::unique(hash + 1, hash + n + 1);
	rep(i, 1, n) a[i] = std::lower_bound(hash + 1, hcnt, a[i]) - hash;
	blo = sqrt(n) + 10.5;
    rep(i, 1, n) bel[i] = (i - 1) / blo + 1;
    for (i = 1, j = 1; i &lt;= n; i += blo, ++j) {
		L[j] = i;
		R[j] = i + blo - 1;
	}
	blo = bel[n];	
	R[blo] = n;
	sz = (int)(hcnt - hash) * sizeof(int);
    rep(i, 1, blo) {
		k = R[i];
        rep(j, L[i], k) ++cnt[a[j]];
        memcpy(pre[i], cnt, sz);
    }
    rep(i, 1, blo) {
        mx = -1LL;
		k = L[i];
		t = a[L[i]];
		sx = pre[i - 1];
        rep(j, i, blo) {
			sy = pre[j];
            wlp (k &lt;= R[j]) {
                _t = (long long)(sy[a[k]] - sx[a[k]]) * hash[a[k]];
                if (mx &lt; _t) mx = _t;
                ++k;
            }
            f[i][j] = mx;
        }
    }
    memset(cnt, 0, sz);
    wlp (q--) {
        gi(l), gi(r);
		mx = -1LL;
        if (bel[l] + 1 &lt; bel[r]) {
            sx = pre[bel[l]], sy = pre[bel[r] - 1];
            mx = f[bel[l] + 1][bel[r] - 1];
            j = R[bel[l]];
            rep(i, l, j) if (!cnt[a[i]]++) {
				*++tp = a[i];
				cnt[*tp] += sy[*tp] - sx[*tp];
			}
            rep(i, L[bel[r]], r) if (!cnt[a[i]]++) {
				*++tp = a[i];
				cnt[*tp] += sy[*tp] - sx[*tp];
			}
        } else rep(i, l, r) if (!cnt[a[i]]++) *++tp = a[i];	
        rep(hcnt, stk + 1, tp) {
            _t = (long long)cnt[*hcnt] * hash[*hcnt];
            if (mx &lt; _t) mx = _t;
        }
        printf(&quot;%lld\n&quot;, mx);
        wlp (stk &lt; tp) cnt[*tp--] = 0;
    }
    return 0;
}<pre><h2>Problem4244</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define rep(a, l, r) for (a = l; a &lt;= r; ++a)
long long f[3003][3003];
inline void cmin(long long &amp;a, const long long &amp;b) {
	if (b &lt; a) a = b;
}
inline long long min(const long long &amp;a, const long long &amp;b) {
	return a &lt; b ? a : b;
}
int main() {
	int n, t, i, j, u, v, d, e;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;t);
	memset(f, 63, sizeof f);
	f[0][0] = 0;
	rep(i, 1, n) {
		scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;d, &amp;e);
		rep(j, 0, n) {
			f[i - 1][j] += j * t &lt;&lt; 1;
			f[i][j] = 0x3f3f3f3f;
		}
		rep(j, 0, n) {
			if (j) f[i][j] = min(min(f[i - 1][j - 1], f[i][j - 1]) + v + d, f[i - 1][j] + d + e);
			if (j &lt; n) cmin(f[i][j], f[i - 1][j + 1] + u + e);
			cmin(f[i][j], f[i - 1][j] + u + v);
		}
		for (j = n - 1; ~j; --j) cmin(f[i][j], f[i][j + 1] + u + e);
	}
	printf(&quot;%lld\n&quot;, f[n][0] + (n + 1) * t);
	return 0;
}<pre><h2>Problem4245</h2><pre>#include &lt;cstdio&gt;
unsigned long long a[500001];
int main() {
	unsigned int n, m, i, ct;
	unsigned long long ans = 0LL, _t;
	scanf(&quot;%u%u&quot;, &amp;n, &amp;m);
	for (i = 0; i &lt; n; ++i) {
		scanf(&quot;%llu&quot;, &amp;_t);
		ans ^= _t;
		a[i] = ans;
	}
	ans = 0;
	for (_t = 1LL &lt;&lt; 60; _t; _t &gt;&gt;= 1) {
		for (i = ct = 0; i &lt; n; ++i)
			if ((~a[i]) &amp;&amp; (~a[i] &amp; _t)) ++ct;
		if (ct &gt;= m &amp;&amp; (~a[n - 1] &amp; _t))
			for (i = 0; i &lt; n; ++i) {
				if ((~a[i]) &amp;&amp; (a[i] &amp; _t)) a[i] = -1;
			}
		else
			ans ^= _t;
	}
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem4299</h2><pre>#include &lt;cstdio&gt;
#define N 100005
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)
struct node {
	int ls, rs, sum;
}C[N * 33];
int rt[N], cnd, a[N];

void ins(int x, int &amp;y, int l, int r, const int &amp;v) {
	C[y = ++cnd] = C[x];
	C[y].sum += v;
	if (!(l ^ r)) return;
	if (v &lt;= (l + r &gt;&gt; 1))
	  ins(C[x].ls, C[y].ls, l, (l + r &gt;&gt; 1), v);
	else
	  ins(C[x].rs, C[y].rs, (l + r &gt;&gt; 1) + 1, r, v);
}

int quy(int x, int y, int l, int r, const int &amp;v) {
	if (l &gt; v || !(C[x].sum ^ C[y].sum)) return 0;
	if (r &lt;= v) return C[y].sum - C[x].sum;
	int m = l + r &gt;&gt; 1, ret;
	ret = quy(C[x].ls, C[y].ls, l, m, v);
	if (v &gt;= m) ret += quy(C[x].rs, C[y].rs, m + 1, r, v);
	return ret;
}

int main() {
	int n, l, r, x, y, mx = -1;
	scanf(&quot;%d&quot;, &amp;n );
	rep(i, 1, n) if (scanf(&quot;%d&quot;, a + i), mx &lt; a[i]) mx = a[i];
	rep(i, 1, n) ins(rt[i - 1], rt[i], 1, mx, a[i]);
	scanf(&quot;%d&quot;, &amp;n);
	while (n--) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		for (x = 1;; x = y + 1)
		  if ((y = quy(rt[l - 1], rt[r], 1, mx, x)) &lt; x)
			break;
		printf(&quot;%d\n&quot;, x);
	}
}<pre><h2>Problem4300</h2><pre>#include &lt;cstdio&gt;
int mx[31];
int main() {
	int n, i, x, t;
	for (scanf(&quot;%d&quot;, &amp;n); n; --n) {
		scanf(&quot;%d&quot;, &amp;x);
		for (i = t = 0; i ^ 31; ++i)
			if ((x &gt;&gt; i &amp; 1) &amp;&amp; mx[i] &gt; t) t = mx[i];
		for (i = 0, ++t; i ^ 31; ++i)
			if ((x &gt;&gt; i &amp; 1) &amp;&amp; mx[i] &lt; t) mx[i] = t;
	}
	for (i = t = 0; i ^ 31; ++i)
		if (mx[i] &gt; t) t = mx[i];
	printf(&quot;%d\n&quot;, t);
	return 0;
}
<pre><h2>Problem4310</h2><pre>#include &lt;cstdio&gt;
typedef int arr[100005];
arr wa,wb,sa,ws,wv,rk,hi,st[18],lg;
int n,ls,rs,k; char a[100005];
inline bool cmp(int*r,int i,int j,int l) {
	return r[i]==r[j]&amp;&amp;r[i+l]==r[j+l];
}
inline void da(int n,int m) {
	int i,j,p,*x=wa,*y=wb,*t;
	for(i=0;i&lt;m;++i)ws[i]=0;
	for(i=0;i&lt;n;++i)++ws[x[i]=a[i]];
	for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
	for(i=n-1;~i;--i)sa[--ws[x[i]]]=i;
	for(j=p=1;p&lt;n;j&lt;&lt;=1,m=p) {
		for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;
		for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;
		for(i=0;i&lt;m;++i)ws[i]=0;
		for(i=0;i&lt;n;++i)++ws[wv[i]=x[y[i]]];
		for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
		for(i=n-1;~i;--i)sa[--ws[wv[i]]]=y[i];
		for(t=x,x=y,y=t,i=p=1,x[sa[0]]=0;i&lt;n;++i)
			x[sa[i]]=cmp(y,sa[i],sa[i-1],j)?p-1:p++;
	}
}
inline void gehi(int n) {
	int i,j,k;
	for(i=1;i&lt;=n;++i)rk[sa[i]]=i;
	for(i=k=0;i&lt;n;hi[rk[i++]]=k)
		for(k?--k:0,j=sa[rk[i]-1];a[i+k]==a[j+k];++k);
}
inline int min(const int&amp;a,const int&amp;b) {return a&lt;b?a:b;}
inline void initst() {
	int i,j;
	for(i=2;i&lt;=n;++i)lg[i]=lg[i&gt;&gt;1]+1;
	for(i=1;i&lt;=n;++i)st[0][i]=hi[i];
	for(i=1;i&lt;=lg[n];++i)
		for(j=1;j+(1&lt;&lt;i)-1&lt;=n;++j)
			st[i][j]=min(st[i-1][j],st[i-1][j+(1&lt;&lt;i-1)]);
}
inline int rmq(int i,int j) {
	int t=lg[j-i+1];
	return min(st[t][i],st[t][j-(1&lt;&lt;t)+1]);
}
inline int lcp(int a,int b) {
	if(a==b) return n-a;
	a=rk[a],b=rk[b];
	if(b&lt;a)a^=b^=a^=b;
	return rmq(a+1,b);
}
inline bool cmp_str(int l1,int r1,int l2,int r2) {
	int len1=r1-l1+1,len2=r2-l2+1,com=lcp(l1,l2);
	if(len1&lt;=len2&amp;&amp;com&gt;=len1) return true;
	if(len1&gt;len2&amp;&amp;com&gt;=len2) return false;
	if(com&gt;=len1&amp;&amp;com&gt;=len2) return len1&lt;=len2;
	return a[l1+com] &lt;= a[l2+com];
}
inline void gkth(long long k) {
	static long long temp;
	for(int i=1;i&lt;=n;++i) {
		temp=n-sa[i]-hi[i];
		if(temp&lt;k) k-=temp;
		else {ls=sa[i],rs=ls+hi[i]+k-1; break;}
	}
}
inline bool check() {
	static int cnt,las,i;
	cnt=1,las=n-1;
	for(i=n-1;~i;--i)
		if(a[i]&gt;a[ls]) return false;
		else if(!cmp_str(i,las,ls,rs)) {
			if(++cnt&gt;k) return false;
			las=i;
		}
	return true;
}
int main() {
	scanf(&quot;%d\n&quot;,&amp;k);
	for(char ch=getchar();(ch^'\n')&amp;&amp;(ch^'\r');ch=getchar())a[n++]=ch;
	da(n+1,128); gehi(n);
	initst();
	long long L=1,R=0,ANS,MD;
	for(int i=1;i&lt;=n;++i)R+=n-sa[i]-hi[i];
	while(L&lt;=R)
		if(gkth(MD=L+R&gt;&gt;1),check())R=(ANS=MD)-1;
		else L=MD+1;
	gkth(ANS);
	for(int i=ls;i&lt;=rs;++i)putchar(a[i]);
	return 0;
}
<pre><h2>Problem4320</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline char gp() {register char c;while(c=getchar(),c&lt;'A');return c;}
#define M 300005
#define N 100005
int f[M],val[N],d[550],ans[N];
char op[N],mark[M];
inline int gf(int u) {
	int r=u; while(f[r]^r)r=f[r];
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
inline void merge(int x,int y) {
	x=gf(x),y=gf(y);
	x&lt;y?f[x]=y:f[y]=x;
}
inline void cmin(int&amp;a,const int&amp;b){if(b&lt;a)a=b;}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;4320.in&quot;,&quot;r&quot;,stdin);
#endif
	register int n=gi(),i,j,t;
	memset(d,127,sizeof d);
	for(i=0;i&lt;n;++i) {
		op[i]=gp(); val[i]=gi();
		if(op[i]=='A') {for(j=1;j&lt;550;++j)cmin(d[j],val[i]%j);mark[val[i]]=1;}
		else if(val[i]&lt;550)ans[i]=d[val[i]];
	}
	f[300001]=300001;
	for(i=300000;~i;--i)f[i]=(mark[i]?i:f[i+1]);
	for(i=n-1;~i;--i) {
		if(op[i]=='A') merge(val[i],val[i]+1);
		else if(val[i]&gt;=550) {
			t=gf(1); ans[i]=(t^300001)?t%val[i]:(val[i]-1);
			for(j=val[i];j&lt;300001;j+=val[i])
				cmin(ans[i],((t=gf(j))^300001)?t%val[i]:(val[i]-1));
		}
	}
	for(i=0;i&lt;n;++i)if(op[i]=='B')printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem4349</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 53
#define inf 1e99
double a[N], In[N];
int pre[N], b[N], vis[N], id[N], pos[N];
struct edge {
	int u, v;
	double w;
}e[3333];
inline bool cmin(double &amp;a, const double &amp;b) {
	if (b &lt; a) return a = b, true;
	return false;
}
inline double MST(int rt, int n, int m) {
	int i, j, cnt, v;
	double ret = 0.0;
	while (true) {
		for (i = 0; i &lt; n; ++i) In[i] = inf;
		for (i = 0; i &lt; m; ++i) if (cmin(In[e[i].v], e[i].w)) pre[e[i].v] = e[i].u;
		for (i = 0; i &lt; n; ++i) id[i] = vis[i] = -1;
		cnt = 0;
		In[rt] = 0.0;
		for (i = 0; i &lt; n; ++i) {
			ret += In[v = i];
			while ((v ^ rt) &amp;&amp; (vis[v] ^ i) &amp;&amp; !(~id[v])) vis[v] = i, v = pre[v];
			if ((v ^ rt) &amp;&amp; !(~id[v])) {
				id[v] = cnt;
				for (j = pre[v]; j ^ v; j = pre[j]) id[j] = cnt;
				++cnt;
			}
		}
		if (!cnt) return ret;
		for (i = 0; i &lt; n; ++i) if (!(~id[i])) id[i] = cnt++;
		for (i = j = 0; i &lt; m; ++i)
			if (id[e[i].u] ^ id[e[i].v])
				e[j++] = (edge) { id[e[i].u], id[e[i].v], e[i].w - In[e[i].v] };
		n = cnt, m = j; rt = id[rt];
	}
}

int main() {
	int n, idx = 1, i, ce = 0, k, x, y;
	double v;
	scanf(&quot;%d&quot;, &amp;n);
	for (i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lf%d&quot;, &amp;v, &amp;k);
		if (k) {
			e[ce++] = (edge) {0, pos[i] = idx, v};
			a[idx] = v, b[idx] = k - 1;
			++idx;
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	while (k--) {
		scanf(&quot;%d%d%lf&quot;, &amp;x, &amp;y, &amp;v);
		if (!pos[x] || !pos[y] || !(x ^ y)) continue;
		e[ce++] = (edge) {pos[x], pos[y], v};
		if (v &lt; a[y = pos[y]]) a[y] = v;
	}
	v = 0.0;
	for (i = 1; i &lt; idx; ++i)
		v += a[i] * b[i];
	printf(&quot;%.2lf\n&quot;, MST(0, idx, ce) + v);
	return 0;
}
<pre><h2>Problem4355</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int maxn(3e5 + 7);
const long long inf(1LL &lt;&lt; 60);
typedef std::pair&lt;long long, long long&gt; pll;

struct node {
	int l, r, cnt, tot;
	long long mi, sec;
	pll tag;
	node *ls, *rs;
} node_mset[maxn * 2], *cnode = node_mset, *root;

inline pll operator + (const pll &amp;a, const pll &amp;b) {
	return pll(std::max(a.first + b.first, -inf), std::max(a.second + b.first, b.second));
}

inline void pushup(node *u) {
	u-&gt;cnt = u-&gt;ls-&gt;cnt + u-&gt;rs-&gt;cnt;
	if (u-&gt;ls-&gt;mi &lt; u-&gt;rs-&gt;mi) {
		u-&gt;mi = u-&gt;ls-&gt;mi;
		u-&gt;tot = u-&gt;ls-&gt;tot;
		u-&gt;sec = std::min(u-&gt;ls-&gt;sec, u-&gt;rs-&gt;mi);
	} else if (u-&gt;ls-&gt;mi &gt; u-&gt;rs-&gt;mi) {
		u-&gt;mi = u-&gt;rs-&gt;mi;
		u-&gt;tot = u-&gt;rs-&gt;tot;
		u-&gt;sec = std::min(u-&gt;rs-&gt;sec, u-&gt;ls-&gt;mi);
	} else {
		u-&gt;mi = u-&gt;ls-&gt;mi;
		u-&gt;tot = u-&gt;ls-&gt;tot + u-&gt;rs-&gt;tot;
		u-&gt;sec = std::min(u-&gt;ls-&gt;sec, u-&gt;rs-&gt;sec);
	}
}

void build(node * &amp;u, int l, int r) {
	u = cnode++;
	u-&gt;l = l, u-&gt;r = r;
	u-&gt;tag = pll(0, -inf);
	if (l ^ r) {
		int mid = (l + r) &gt;&gt; 1;
		build(u-&gt;ls, l, mid);
		build(u-&gt;rs, mid + 1, r);
		pushup(u);
	} else {
		scanf(&quot;%lld&quot;, &amp;u-&gt;mi);
		u-&gt;sec = inf;
		if (!u-&gt;mi) u-&gt;cnt = 1;
		u-&gt;tot = 1;
	}
}

void pushdown(node *u);
void cover(node *u, const pll &amp;tag);

void pushdown(node *u) {
	if (u-&gt;tag == pll(0, -inf))
		return;
	u-&gt;ls-&gt;tag = u-&gt;ls-&gt;tag + u-&gt;tag;
	u-&gt;rs-&gt;tag = u-&gt;rs-&gt;tag + u-&gt;tag;
	cover(u-&gt;ls, u-&gt;tag);
	cover(u-&gt;rs, u-&gt;tag);
	u-&gt;tag = pll(0, -inf);
}

void cover(node *u, const pll &amp;tag) {
	static long long a, b;
	a = std::max(std::max(u-&gt;mi + tag.first, tag.second), 0LL);
	b = std::max(std::max(u-&gt;sec + tag.first, tag.second), 0LL);
	if (u-&gt;sec == inf) b = inf;
	else if (inf &lt; b) b = inf;
	if (a &gt;= b) {
		pushdown(u);
		pushup(u);
	} else {
		u-&gt;mi = a;
		u-&gt;sec = b;
		u-&gt;cnt = a ? 0 : u-&gt;tot;
	}
}

void modify(node *u, const int &amp;x, const int &amp;y, const pll &amp;tag) {
	if (x &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= y) {
		u-&gt;tag = u-&gt;tag + tag;
		cover(u, tag);
		return;
	}
	int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1;
	pushdown(u);
	if (x &lt;= mid) modify(u-&gt;ls, x, y, tag);
	if (y  &gt; mid) modify(u-&gt;rs, x, y, tag);
	pushup(u);
}

int query(node *u, const int &amp;x, const int &amp;y) {
	if (x &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= y)
		return u-&gt;cnt;
	int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1, ret = 0;
	pushdown(u);
	if (x &lt;= mid) ret += query(u-&gt;ls, x, y);
	if (y  &gt; mid) ret += query(u-&gt;rs, x, y);
	return ret;
}

int main() {
	int n, m, opt, u, v, c;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	build(root, 1, n);
	while (m--) {
		scanf(&quot;%d%d%d&quot;, &amp;opt, &amp;u, &amp;v);
		if (opt ^ 3) scanf(&quot;%d&quot;, &amp;c);
		if (opt == 1)
			modify(root, u, v, pll(-inf, c));
		else if (opt == 2)
			modify(root, u, v, pll(c, 0));
		else
			printf(&quot;%d\n&quot;, query(root, u, v));
	}
	return 0;
}
<pre><h2>Problem4361</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c, f;
	for (f = 0; (c = getchar()) &lt; '0';) f |= c == '-';
	for (a = c - '0'; '-' &lt; (c = getchar());) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
	return f ? -a : a;
}
#define N 2003
#define mo 1000000007
int r[N], a[N], C[N][N], f[N], g[N], dt;
inline bool cmp(const int &amp;i, const int &amp;j) {
	return a[i] &lt; a[j];
}
inline void mov(int &amp;a, const int &amp;b) {
	(a += b) &gt;= mo ? a -= mo : 0;
}
inline void add(int *tr, int x, const int &amp;v) {
	for (; x &lt; dt; x += x &amp; -x)
		mov(tr[x], v);
}
inline int sum(int *tr, int x) {
	static int r;
	for (r = 0; x; x -= x &amp; -x)
		mov(r, tr[x]);
	return r;
}
int main() {
	int n = gi(), i, j, last, ans = 0, t;
	for (i = 1; i &lt;= n; ++i) *(a + (r[i] = i)) = gi();
	sort(r + 1, r + n + 1, cmp);
	last = a[r[1]];
	a[r[1]] = dt = 1;
	for (i = 2; i &lt;= n; ++i) {
		if (last ^ a[j = r[i]]) last = a[j], ++dt;
		a[j] = dt;
	}
	++dt;
	add(C[0], 1, 1);
	for (i = 1; i &lt;= n; ++i)
		for (j = i; j; --j) {
			t = sum(C[j - 1], a[i]);
			mov(f[j], t);
			add(C[j], a[i], t);
		}
	for (i = *g = 1; i &lt;= n; ++i) g[i] = (long long)g[i - 1] * i % mo;
	for (i = 1; i &lt;= n; ++i) {
		mov(ans, (int)((long long)f[i] * g[n - i] % mo));
		if (i ^ n) mov(ans, (int)(mo - (long long)f[i + 1] * (i + 1) % mo * g[n - i - 1] % mo));
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4402</h2><pre>#include &lt;cstdio&gt;

#define un unsigned

const un int mod = 1000000007;
un int fac[2000003], inv[2000003];
#define rep(i, l, r) for (i = l; i &lt;= r; ++i)
inline un int mmo(int a) {
	while (a &gt;= mod) a -= mod;
	return a;
}
inline un int C(un int n, un int m) {
	if (n &lt; 0) return 0U;
	n = (n &gt;&gt; 1) + m;
	return (un long long)fac[n] * inv[m] % mod * inv[n - m] % mod;
}
int main() {
	un int n, m, i, ans = 0;
	scanf(&quot;%u%u&quot;, &amp;n, &amp;m);
	fac[1] = inv[1] = 1;
	fac[0] = inv[0] = 1;
	rep(i, 2, n) fac[i] = (un long long)fac[i - 1] * i % mod;
	rep(i, 2, n) inv[i] = (un long long)inv[mod % i] * (mod - mod / i) % mod;
	rep(i, 2, n) inv[i] = (un long long)inv[i - 1] * inv[i] % mod;
	if (n &amp;&amp; m) ans = 1;
	rep(i, 2, m) ans = mmo(ans + mmo(C(n - i, i - 1) + C(n - i - 1, i - 1)));
	printf(&quot;%u\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4403</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int mod(1e6 + 3);

int fac[mod], inv[mod], fac_inv[mod];

inline void init() {
	fac[0] = fac_inv[0] = 1;
	fac[1] = inv[1] = fac_inv[1] = 1;
	for (register int i = 2; i &lt; mod; ++i) {
		fac[i] = 1ll * fac[i - 1] * i % mod;
		inv[i] = (mod - mod / i) * 1ll * inv[mod % i] % mod;
		fac_inv[i] = 1ll * fac_inv[i - 1] * inv[i] % mod;
	}
}

inline int lucas(int n, int m) {
	int ret = 1, _n, _m;
	while (n &amp;&amp; m) {
		_n = n % mod, _m = m % mod;
		if (_n &lt; _m) return 0;
		ret = 1ll * ret * fac[_n] % mod * fac_inv[_m] % mod * fac_inv[_n - _m] % mod;
		n /= mod, m /= mod;
	}
	return ret;
}

int main() {
	init();

	int o_o, n, l, r, ans;
	scanf(&quot;%d&quot;, &amp;o_o);

	while (o_o--) {
		scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;r);
		ans = lucas(n + r - l + 1, n) - 1;
		if (ans &lt; 0) ans += mod;
		printf(&quot;%d\n&quot;, ans);

	}

	return 0;
}
<pre><h2>Problem4419</h2><pre>#include &lt;cstdio&gt;
#define N 200001
#define M 500001
unsigned int x[M], y[M], a[N];
int s[N];
char opt[M];
int main() {
	unsigned int n, m;
	register unsigned int i = 0;
	scanf(&quot;%u%u&quot;, &amp;n, &amp;m);
	for (register char c; i &lt; m; ++i) {
		do c = getchar(); while ((c ^ '!') &amp;&amp; (c ^ '+') &amp;&amp; (c ^ '-'));
		opt[i] = c;
		if (c ^ '!') scanf(&quot;%u%u&quot;, x + i, y + i);
		else scanf(&quot;%u&quot;, x + i);
	}
	for (i = m - 1; ~i; --i)
		if (opt[i] ^ '!') {
			if (opt[i] ^ '+') s[x[i]] -= a[y[i]], s[y[i]] -= a[x[i]];
			else s[x[i]] += a[y[i]], s[y[i]] += a[x[i]];
		} else ++a[x[i]];
	for (i = 1; i &lt; n; ++i) printf(&quot;%u &quot;, s[i]);
	return printf(&quot;%u&quot;, s[n]),0;
}<pre><h2>Problem4443</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
pair&lt; int, pair&lt;int,int&gt; &gt;a[62505];
int Link[255],vis[255],_vis,cnt,n,m,k;
struct edge{int to;edge*nt;}ME[62505],*ce,*he[255];
inline void adde(int a,int b) {ce-&gt;to=b,ce-&gt;nt=he[a],he[a]=ce++;}
bool dfs(int u) {
	for(edge*it=he[u];it;it=it-&gt;nt)
		if(vis[it-&gt;to]^_vis) {
			vis[it-&gt;to]=_vis;
			if(!Link[it-&gt;to]||dfs(Link[it-&gt;to]))
				return Link[it-&gt;to]=u;
		}
	return false;
}
inline bool check(int md) {
	ce=ME;
	memset(he,0,sizeof he);
	memset(Link,0,sizeof Link);
	int i,count=0,val=a[md].first;
	for(i=0;i&lt;cnt;++i)
		if(a[i].first&lt;=val)adde(a[i].second.first,a[i].second.second);
		else break;
	for(i=1;i&lt;=n;++i)
		if((++_vis,count+=dfs(i))&gt;n-k) return true;
	return false;
}
int main() {
	int i,j,l,r,md,ans;
	n=gi(),m=gi(),k=gi();
	for(i=1;i&lt;=n;++i)
		for(j=1;j&lt;=m;++j)
			a[cnt++]=make_pair(gi(),make_pair(i,j));
	sort(a,a+cnt);
	for(l=0,r=ans=cnt-1;l&lt;=r;)
		if(check(md=l+r&gt;&gt;1))r=(ans=md)-1;
		else l=md+1;
	printf(&quot;%d\n&quot;,a[ans].first);
	return 0;
}
<pre><h2>Problem4443</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
struct D{int v,i,j;}a[62505];
bool operator &lt; (const D&amp;a,const D&amp;b) {return a.v&lt;b.v;}
int Link[255],vis[255],_vis,cnt,n,m,k;
struct edge{int to;edge*nt;}ME[62505],*ce,*he[255];
inline void adde(int a,int b) {ce-&gt;to=b,ce-&gt;nt=he[a],he[a]=ce++;}
bool dfs(int u) {
	for(edge*it=he[u];it;it=it-&gt;nt)
		if(vis[it-&gt;to]^_vis) {
			vis[it-&gt;to]=_vis;
			if(!Link[it-&gt;to]||dfs(Link[it-&gt;to]))
				return Link[it-&gt;to]=u;
		}
	return false;
}
inline bool check(int md) {
	ce=ME;
	int i,count=0,val=a[md].v;
	for(i=1;i&lt;=n;++i)he[i]=NULL;
	for(i=1;i&lt;=m;++i)Link[i]=0;
	for(i=0;i&lt;cnt;++i)
		if(a[i].v&lt;=val)adde(a[i].i,a[i].j);
		else break;
	for(i=1;i&lt;=n;++i)
		if((++_vis,count+=dfs(i))&gt;n-k) return true;
	return false;
}
int main() {
	int i,j,l,r,md,ans;
	n=gi(),m=gi(),k=gi();
	for(i=1;i&lt;=n;++i)
		for(j=1;j&lt;=m;++j)
			a[cnt++]=(D){gi(),i,j};
	sort(a,a+cnt);
	for(l=0,r=ans=cnt-1;l&lt;=r;)
		if(check(md=l+r&gt;&gt;1))r=(ans=md)-1;
		else l=md+1;
	printf(&quot;%d\n&quot;,a[ans].v);
	return 0;
}
<pre><h2>Problem4443</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
char B[1&lt;&lt;16],*S,*E;
#define gc() (S==E?(E=(S=B)+fread(B,1,1&lt;&lt;16,stdin),*S++):*S++)
inline int gi() {
	static int a; static char c;
	while(c=gc(),c&lt;'0');a=c-'0';
	while(c=gc(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
struct D{int v,i,j;}a[62505];
bool operator &lt; (const D&amp;a,const D&amp;b) {return a.v&lt;b.v;}
int Link[255],vis[255],_vis,cnt,n,m,k;
struct edge{int to;edge*nt;}ME[62505],*ce,*he[255];
inline void adde(int a,int b) {ce-&gt;to=b,ce-&gt;nt=he[a],he[a]=ce++;}
bool dfs(int u) {
	for(edge*it=he[u];it;it=it-&gt;nt)
		if(vis[it-&gt;to]^_vis) {
			vis[it-&gt;to]=_vis;
			if(!Link[it-&gt;to]||dfs(Link[it-&gt;to]))
				return Link[it-&gt;to]=u;
		}
	return false;
}
inline bool check(int md) {
	ce=ME;
	int i,count=0,val=a[md].v;
	for(i=1;i&lt;=n;++i)he[i]=NULL;
	for(i=1;i&lt;=m;++i)Link[i]=0;
	for(i=0;i&lt;cnt;++i)
		if(a[i].v&lt;=val)adde(a[i].i,a[i].j);
		else break;
	for(i=1;i&lt;=n;++i)
		if((++_vis,count+=dfs(i))&gt;n-k) return true;
	return false;
}
int main() {
	int i,j,l,r,md,ans;
	n=gi(),m=gi(),k=gi();
	for(i=1;i&lt;=n;++i)
		for(j=1;j&lt;=m;++j)
			a[cnt++]=(D){gi(),i,j};
	sort(a,a+cnt);
	for(l=0,r=ans=cnt-1;l&lt;=r;)
		if(check(md=l+r&gt;&gt;1))r=(ans=md)-1;
		else l=md+1;
	printf(&quot;%d\n&quot;,a[ans].v);
	return 0;
}
<pre><h2>Problem4444</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int MaxN = 2e5 + 7;
int C[MaxN], D[MaxN], ha[MaxN &lt;&lt; 1], f[MaxN &lt;&lt; 3], ans[MaxN &lt;&lt; 3], _ans, m;

struct edge {
	int to;
	edge *nxt;
} edge_mset[MaxN &lt;&lt; 3], *g[MaxN &lt;&lt; 3];

inline void add_edge(int from, int to) {
	static edge *cedge = edge_mset;
	*cedge = (edge) {to, g[from]};
	g[from] = cedge++;
}

inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

inline void dfs(int u) {
	static int stk[MaxN &lt;&lt; 3], *top = stk;
	*++top = u;
	if (u &lt;= ::m)
		for (register int i = _ans; ; ++i)
			if (top[-i] &gt;= u + ::m) {
				ans[u] = i;
				break;
			}
	for (edge *it = ::g[u]; it; it = it-&gt;nxt)
		dfs(it-&gt;to);
	--top;
}

int main() {
	int n, m = 0;
	scanf(&quot;%d%*d&quot;, &amp;n);
	for (register int i = 0; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, C + i, D + i);
		ha[m++] = C[i];
		ha[m++] = D[i];
	}
	::m = m;
	std::sort(ha, ha + m);
	for (register int i = 0, s, t; i &lt; n; ++i) {
		C[i] = s = std::lower_bound(ha, ha + m, C[i]) - ha + 1;
		t = std::lower_bound(ha, ha + m, D[i]) - ha + 1;
		if (s &lt; t)
			cmax(f[s], t), cmax(f[s + m], t + m);
		else
			cmax(f[1], t), cmax(f[s], t + m), cmax(f[s + m], m &lt;&lt; 1);
	}
	for (register int i = 1; i &lt; (m &lt;&lt; 1); ++i) {
		cmax(f[i], f[i - 1]);
		add_edge(f[i], i);
	}
	_ans = -1;
	for (register int i = 1; i &lt;= m; i = f[i]) ++_ans;
	dfs(m &lt;&lt; 1);
	for (register int i = 0; i &lt; n; ++i)
		printf(&quot;%d &quot;, ans[C[i]]);
	return 0;
}<pre><h2>Problem4445</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int MaxN = 1e5 + 7;

struct point {
	double x, y;
	point() {}
	point(double x, double y) :
		x(x), y(y) {}
} s[MaxN], p[MaxN];

struct line {
	point p, v;
	double ang;
	line() {}
	line(point p, point v) :
		p(p), v(v), ang(atan2(v.y, v.x)) {}
} q[MaxN], t[MaxN];


inline point operator + (const point &amp;a, const point &amp;b) {
	return point(a.x + b.x, a.y + b.y);
}

inline point operator - (const point &amp;a, const point &amp;b) {
	return point(a.x - b.x, a.y - b.y);
}

inline point operator * (const double &amp;k, const point &amp;a) {
	return point(k * a.x, k * a.y);
}

inline double operator * (const point &amp;a, const point &amp;b) {
	return a.x * b.y - a.y * b.x;
}

inline bool operator &lt; (const line &amp;a, const line &amp;b) {
	return a.ang &lt; b.ang;
}

inline bool judge(const point &amp;a, const line &amp;b) {
	return (a - b.p) * b.v &gt; 0;
}

inline point getpoint(const line &amp;a, const line &amp;b) {
	return a.p + (b.v * (a.p - b.p)) / (a.v * b.v) * a.v;
}
#define nxt(a) ((a + 1) &lt; n ? (a + 1) : 0)

inline double area(const point *a, const int &amp;n) {
	double u_u = 0.0;
	for (register int o_o = 0; o_o &lt; n; ++o_o)
		u_u += a[o_o] * a[nxt(o_o)];
	return u_u;
}

int main() {
	int n, m = 0, bot = 1, top = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (register int i = 0; i &lt; n; ++i) {
		static int x, y;
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		p[i].x = x;
		p[i].y = y;
	}
	for (register int i = 1, j = nxt(i); i &lt; n; ++i, j = nxt(i)) {
		static double a, b, c;
		a = p[i].y - p[j].y - p[0].y + p[1].y;
		b = p[j].x - p[i].x - p[1].x + p[0].x;
		c = p[i] * p[j] - p[0] * p[1];
		q[m++] = line(a ? point(-c / a, 0) : point(0, -c / b), point(b, -a));
	}
	q[m++] = line(p[0], p[1] - p[0]);
	std::sort(q, q + m);
	for (register int i = 0; i &lt; m; ++i) {
		while (bot &lt; top &amp;&amp; judge(s[top - 1], q[i])) --top;
		while (bot &lt; top &amp;&amp; judge(s[bot], q[i])) ++bot;
		if (bot &gt; top || q[i].ang != t[top].ang)
			t[++top] = q[i], s[top - 1] = getpoint(t[top], t[top - 1]);
	}
	while (bot &lt; top &amp;&amp; judge(s[top - 1], t[bot])) --top;
	if (top &gt; bot + 1) s[top] = getpoint(t[top], t[bot]);
	printf(&quot;%.4lf\n&quot;, area(s + bot, top - bot + 1) / area(p, n));
	return 0;
}<pre><h2>Problem4445</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int MaxN = 1e5 + 7;
struct FI {
	char b[5&lt;&lt;19], *s, sign;
	FI() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 19, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		sign = a = 0;
		while (*s &lt; 48) if (*s++ == 45) sign = 1;
		while (32 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
		if (sign) a = -a;
	}
} io;
struct point {
	double x, y;
	point() {}
	point(double x, double y) :
		x(x), y(y) {}
} s[MaxN], p[MaxN];
struct line {
	point p, v;
	double ang;
	line() {}
	line(point p, point v) :
		p(p), v(v), ang(atan2(v.y, v.x)) {}
} q[MaxN], t[MaxN];
inline point operator + (const point &amp;a, const point &amp;b) {
	return point(a.x + b.x, a.y + b.y);
}
inline point operator - (const point &amp;a, const point &amp;b) {
	return point(a.x - b.x, a.y - b.y);
}
inline point operator * (const double &amp;k, const point &amp;a) {
	return point(k * a.x, k * a.y);
}
inline double operator * (const point &amp;a, const point &amp;b) {
	return a.x * b.y - a.y * b.x;
}
inline bool operator &lt; (const line &amp;a, const line &amp;b) {
	return a.ang &lt; b.ang;
}
inline bool judge(const point &amp;a, const line &amp;b) {
	return (a - b.p) * b.v &gt; 0;
}
inline point getpoint(const line &amp;a, const line &amp;b) {
	return a.p + (b.v * (a.p - b.p)) / (a.v * b.v) * a.v;
}
#define nxt(a) ((a + 1) &lt; n ? (a + 1) : 0)
inline double area(const point *a, const int &amp;n) {
	double u_u = 0.0;
	for (register int o_o = 0; o_o &lt; n; ++o_o)
		u_u += a[o_o] * a[nxt(o_o)];
	return u_u;
}
int main() {
	int n, m = 0, bot = 1, top = 0;
	io.gi(n);
	for (register int i = 0; i &lt; n; ++i) {
		static int x, y;
		io.gi(x), io.gi(y);
		p[i].x = x;
		p[i].y = y;
	}
	for (register int i = 1, j = nxt(i); i &lt; n; ++i, j = nxt(i)) {
		static double a, b, c;
		a = p[i].y - p[j].y - p[0].y + p[1].y;
		b = p[j].x - p[i].x - p[1].x + p[0].x;
		c = p[i] * p[j] - p[0] * p[1];
		q[m++] = line(a ? point(-c / a, 0) : point(0, -c / b), point(b, -a));
	}
	q[m++] = line(p[0], p[1] - p[0]);
	std::sort(q, q + m);
	for (register int i = 0; i &lt; m; ++i) {
		while (bot &lt; top &amp;&amp; judge(s[top - 1], q[i])) --top;
		while (bot &lt; top &amp;&amp; judge(s[bot], q[i])) ++bot;
		if (bot &gt; top || q[i].ang != t[top].ang)
			t[++top] = q[i], s[top - 1] = getpoint(t[top], t[top - 1]);
	}
	while (bot &lt; top &amp;&amp; judge(s[top - 1], t[bot])) --top;
	if (top &gt; bot + 1) s[top] = getpoint(t[top], t[bot]);
	printf(&quot;%.4lf\n&quot;, area(s + bot, top - bot + 1) / area(p, n));
	return 0;
}<pre><h2>Problem4446</h2><pre>#include &lt;cstdio&gt;
const int MaxN = 2e5 + 7;
long long f[MaxN][20], g[MaxN][20];
int a[MaxN], b[MaxN], d[MaxN], l[MaxN];
struct FI {
	char b[6&lt;&lt;19|2323], *s;
	FI() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 19, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		a = 0;
		while (*s &lt; 48) ++s;
		while (32 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
	}
} io;
inline long long min(const long long &amp;a, const long long &amp;b) {
	return a &lt; b ? a : b;
}
int main() {
	int n;
	io.gi(n);
	for (register int i = 1; i &lt;= n; ++i) io.gi(a[i]);
	l[1] = 1;
	for (register int i = 2; i &lt;= n; ++i) {
		io.gi(b[i]);
		l[i] = l[i &gt;&gt; 1] + 1;
		d[i] = d[i &gt;&gt; 1] + b[i];
	}
	for (register int x = n, y, lc, rc, i; x; --x)
		for (i = 0; i &lt; l[x]; ++i) {
			lc = x &lt;&lt; 1;
			rc = lc ^ 1;
			y = (x &gt;&gt; (l[x] - i - 1)) ^ 1;
			if (lc &gt; n)
				f[x][i] = (long long)a[y] * (d[x] + d[y] - (d[y &gt;&gt; 1] &lt;&lt; 1));
			else if (rc &gt; n)
				f[x][i] = (long long)a[lc] * b[lc] + f[lc][i];
			else
				f[x][i] = min((long long)a[lc] * b[lc] + f[lc][l[x]] + f[rc][i], (long long)a[rc] * b[rc] + f[rc][l[x]] + f[lc][i]);
		}
	for (register int x = n, y, lc, rc, i; x; --x)
		for (i = 0; i &lt;= l[x]; ++i) {
			lc = x &lt;&lt; 1;
			rc = lc ^ 1;
			y = x &gt;&gt; (l[x] - i);
			if (lc &gt; n)
				g[x][i] = (long long)a[y] * (d[x] - d[y]);
			else if (rc &gt; n)
				g[x][i] = (long long)a[lc] * b[lc] + g[lc][i];
			else
				g[x][i] = min((long long)a[lc] * b[lc] + f[lc][l[lc] - 1] + g[rc][i], (long long)a[rc] * b[rc] + f[rc][l[rc] - 1] + g[lc][i]);
		}
	long long ans = g[1][0];
	for (register int i = 2; i &lt;= n; ++i) {
		long long res = g[i][l[i] - 1];
		for (register int tmp = i, y, z; tmp ^ 1; tmp &gt;&gt;= 1) {
			y = tmp ^ 1;
			z = tmp &gt;&gt; 1;
			if (y &gt; n)
				res += (long long)a[z &gt;&gt; 1] * b[z];
			else
				res += (long long)a[y] * b[y] + g[y][l[z] - 1];
		}
		if (res &lt; ans) ans = res;
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4446</h2><pre>#include &lt;cstdio&gt;
const int MaxN = 2e5 + 7;
long long f[MaxN][20], g[MaxN][20];
int a[MaxN], b[MaxN], d[MaxN], l[MaxN];
struct FI {
	char b[5&lt;&lt;19], *s;
	FI() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 19, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		a = 0;
		while (*s &lt; 48) ++s;
		while (32 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
	}
} io;
inline long long min(const long long &amp;a, const long long &amp;b) {
	return a &lt; b ? a : b;
}
int main() {
	int n;
	io.gi(n);
	for (register int i = 1; i &lt;= n; ++i) io.gi(a[i]);
	l[1] = 1;
	for (register int i = 2; i &lt;= n; ++i) {
		io.gi(b[i]);
		l[i] = l[i &gt;&gt; 1] + 1;
		d[i] = d[i &gt;&gt; 1] + b[i];
	}
	for (register int x = n, y, lc, rc, i; x; --x)
		for (i = 0; i &lt; l[x]; ++i) {
			lc = x &lt;&lt; 1;
			rc = lc ^ 1;
			y = (x &gt;&gt; (l[x] - i - 1)) ^ 1;
			if (lc &gt; n)
				f[x][i] = (long long)a[y] * (d[x] + d[y] - (d[y &gt;&gt; 1] &lt;&lt; 1));
			else if (rc &gt; n)
				f[x][i] = (long long)a[lc] * b[lc] + f[lc][i];
			else
				f[x][i] = min((long long)a[lc] * b[lc] + f[lc][l[x]] + f[rc][i], (long long)a[rc] * b[rc] + f[rc][l[x]] + f[lc][i]);
		}
	for (register int x = n, y, lc, rc, i; x; --x)
		for (i = 0; i &lt;= l[x]; ++i) {
			lc = x &lt;&lt; 1;
			rc = lc ^ 1;
			y = x &gt;&gt; (l[x] - i);
			if (lc &gt; n)
				g[x][i] = (long long)a[y] * (d[x] - d[y]);
			else if (rc &gt; n)
				g[x][i] = (long long)a[lc] * b[lc] + g[lc][i];
			else
				g[x][i] = min((long long)a[lc] * b[lc] + f[lc][l[lc] - 1] + g[rc][i], (long long)a[rc] * b[rc] + f[rc][l[rc] - 1] + g[lc][i]);
		}
	long long ans = g[1][0];
	for (register int i = 2; i &lt;= n; ++i) {
		long long res = g[i][l[i] - 1];
		for (register int tmp = i, y, z; tmp ^ 1; tmp &gt;&gt;= 1) {
			y = tmp ^ 1;
			z = tmp &gt;&gt; 1;
			if (y &gt; n)
				res += (long long)a[z &gt;&gt; 1] * b[z];
			else
				res += (long long)a[y] * b[y] + g[y][l[z] - 1];
		}
		if (res &lt; ans) ans = res;
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4447</h2><pre>#include &lt;set&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int MaxN = 1e5 + 7, inf = -0x3f3f3f3f;

struct Range {
	int l, r;
	Range(int l = 0, int r = 0) :
		l(l), r(r) {}
};

inline bool operator &lt; (const Range &amp;a, const Range &amp;b) {
	return a.l &lt; b.l;
}

inline bool operator &lt; (const int &amp;x, const Range &amp;a) {
	return x &lt; a.l;
}

int A[MaxN], a[MaxN &lt;&lt; 1], n, m;
char C[MaxN];

std::set&lt;Range&gt; s;

inline void modify(const int &amp;pos, const int &amp;val) {
	if (val == 0 &amp;&amp; a[pos] != 0) {
		for (register int x = pos; x &lt; (n &lt;&lt; 1); x += n) {
			static std::set&lt;Range&gt;::iterator pre, nxt;
			pre = nxt = s.lower_bound(x);
			--pre;
			if (nxt-&gt;l == x + 1 &amp;&amp; pre-&gt;r == x - 1) {
				Range newRange(pre-&gt;l, nxt-&gt;r);
				s.erase(pre);
				s.erase(nxt);
				s.insert(newRange);
			} else if (nxt-&gt;l == x + 1) {
				Range newRange(x, nxt-&gt;r);
				s.erase(nxt);
				s.insert(newRange);
			} else if (pre-&gt;r == x - 1) {
				Range newRange(pre-&gt;l, x);
				s.erase(pre);
				s.insert(newRange);
			} else s.insert(Range(x, x));
		}
	} else if (val != 0 &amp;&amp; a[pos] == 0) {
		for (register int x = pos; x &lt; (n &lt;&lt; 1); x += n) {
			static std::set&lt;Range&gt;::iterator it;
			it = --s.upper_bound(x);
			if (x != it-&gt;l &amp;&amp; x != it-&gt;r) {
				Range newRange1(it-&gt;l, x - 1), newRange2(x + 1, it-&gt;r);
				s.erase(it);
				s.insert(newRange1);
				s.insert(newRange2);
			} else if (x != it-&gt;l) {
				Range newRange(it-&gt;l, x - 1);
				s.erase(it);
				s.insert(newRange);
			} else if (x != it-&gt;r) {
				Range newRange(x + 1, it-&gt;r);
				s.erase(it);
				s.insert(newRange);
			} else s.erase(it);
		}
	}
	a[pos] = a[pos + n] = val;
}

inline int calc(const int &amp;a, const int &amp;b, const char &amp;opt) {
	return (opt == '+') ? ((a + b) % 10) : (a * b % 10);
}

inline void modify(const int &amp;pos, const int &amp;num, const char &amp;opt) {
	A[pos] = num;
	C[pos] = opt;
	modify(pos, calc(A[pos], A[(pos - 1) &lt; 0 ? (pos - 1 + n) : (pos - 1)], C[pos]));
	modify((pos + 1) &lt; n ? (pos + 1) : (pos + 1 - n), calc(A[(pos + 1) &lt; n ? (pos + 1) : (pos + 1 - n)], A[pos], C[(pos + 1) &lt; n ? (pos + 1) : (pos + 1 - n)]));
}

inline int disc(int x, int y) {
	if (x &gt; y)
		std::swap(x, y);
	return std::min(y - x, n + x - y);
}

inline int dist(int pos, const Range &amp;range) {
	if (range.l == -inf || range.l == inf)
		return -1;
	int _pos = pos &lt; n ? pos : (pos - n);
	if (range.l &lt; n &amp;&amp; range.r &gt;= n) {
		if (_pos &gt;= range.l &amp;&amp; _pos &lt;= range.r)
			return 0;
		if (_pos + n &gt;= range.l &amp;&amp; _pos + n &lt;= range.r)
			return 0;
	}
	if (_pos &gt;= range.l % n &amp;&amp; _pos &lt;= range.r % n)
		return 0;
	return std::min(disc(_pos, range.l % n), disc(_pos, range.r % n));
}

inline int query(int pos) {
	static int ans, back;
	back = a[pos];
	modify(pos, A[pos]);
	if (s.size() == 2)
		ans = -1;
	else if (s.size() == 3)
		ans = dist(pos, *++s.begin());
	else {
		static bool flag;
		ans = -1;
		flag = (++s.begin())-&gt;l == ((--(--s.end()))-&gt;r + 1) % n;
		static int opp;
		opp = ((pos - (n &gt;&gt; 1)) + n) % n;
		static std::set&lt;Range&gt;::iterator oppit;
		oppit = --s.upper_bound(opp);
		if (oppit == s.begin())
			oppit = --s.upper_bound(opp + n);
		else if (flag &amp;&amp; (oppit == ++s.begin()))
			oppit = --s.upper_bound(opp + n);
		if (oppit != s.begin() &amp;&amp; !(flag &amp;&amp; (oppit == ++s.begin() || oppit == --(--s.end()))))
			ans = std::max(ans, dist(pos, *oppit));
		if (oppit != ++s.begin()) {
			static std::set&lt;Range&gt;::iterator pre;
			--(pre = oppit);
			if (!(flag &amp;&amp; pre == ++s.begin()))
				ans = std::max(ans, dist(pos, *pre));
		}
		if (oppit != --s.end()) {
			static std::set&lt;Range&gt;::iterator nxt;
			++(nxt = oppit);
			if (!(flag &amp;&amp; nxt == --(--s.begin())))
				ans = std::max(ans, dist(pos, *nxt));
		}
	}
	modify(pos, back);
	return ans;
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d%d&quot;, &amp;::n, &amp;::m);
	for (register int i = 0; i &lt; n; ++i) {
		scanf(&quot;%d&quot;, A + i);
		do C[i] = getchar_unlocked(); while (C[i] != '+' &amp;&amp; C[i] != '*');
	}
	for (register int i = 0; i &lt; n; ++i)
		a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);
	for (register int i = 0; i &lt; (n &lt;&lt; 1);)
		if (a[i]) ++i;
		else {
			register int j;
			j = i;
			while (j + 1 &lt; (n &lt;&lt; 1) &amp;&amp; !a[j + 1]) ++j;
			s.insert(Range(i, j));
			i = j + 1;
		}
	s.insert(Range(inf, inf));
	s.insert(Range(-inf, -inf));
	for (int type, pos, num; m; --m) {
		scanf(&quot;%d%d&quot;, &amp;type, &amp;pos);
		if (type == 1) {
			register char c;
			scanf(&quot;%d&quot;, &amp;num);
			do c = getchar_unlocked(); while (c != '+' &amp;&amp; c != '*');
			modify(pos, num, c);
		} else printf(&quot;%d\n&quot;, query(pos));
	}
	return 0;
}<pre><h2>Problem4448</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 200005
struct opt {int type,id,s,t,c;}p[N];
bool operator &lt; (const opt&amp;a,const opt&amp;b) {
	return (a.c^b.c)?a.c&lt;b.c:a.type&lt;b.type;
}
int C[N],dfn,st[N],ed[N],fa[N],son[N],tp[N],dep[N],ans[2][N];
inline void add(int x,int v) {for(;x&lt;=dfn;x+=x&amp;-x)C[x]+=v;}
inline int sum(int x) {static int r;for(r=0;x;x-=x&amp;-x)r+=C[x];return r;}
struct edge{int to;edge*nt;}ME[N],*ce=ME,*hd[N];
inline void adde(int a,int b) {ce-&gt;to=b,ce-&gt;nt=hd[a],hd[a]=ce++;}
int dfs1(int u) {
	int s=1,mx=-1,t;
	for(edge*it=hd[u];it;it=it-&gt;nt)
		if(dep[it-&gt;to]=dep[u]+1,s+=(t=dfs1(it-&gt;to)),mx&lt;t)
			son[u]=it-&gt;to,mx=t;
	return s;
}
void dfs2(int u,int top) {
	st[u]=++dfn; tp[u]=top;
	if(son[u])dfs2(son[u],top);
	for(edge*it=hd[u];it;it=it-&gt;nt)
		if(it-&gt;to^son[u])dfs2(it-&gt;to,it-&gt;to);
	ed[u]=dfn;
}
inline int lca(int a,int b) {
	for(; tp[a] ^ tp[b]; a=fa[tp[a]])
		if(dep[tp[a]]&lt;dep[tp[b]])a^=b^=a^=b;
	return dep[a]&lt;dep[b]?a:b;
}
int main() {
	int n=gi(),rt,q,i,j,cnt=0,s,t,f,ff;
	for(i=1;i&lt;=n;++i)
		if(fa[i]=gi())adde(fa[i],i);
		else rt=i;
	dep[rt]=1; dfs1(rt); dfs2(rt,rt);
	for(i=1,q=gi();i&lt;=q;++i)
		if((p[i].type=gi())&lt;2) p[i].s=gi(),p[i].t=gi(),p[i].c=i-gi(),p[i].id=++cnt;
		else p[i].s=gi(),p[i].c=i;
	std::sort(p+1,p+q+1);
	for(i=1;i&lt;=q;++i)
		if(p[i].type&lt;2) {
			f=lca(s=p[i].s,t=p[i].t),ff=fa[f];
			ans[0][p[i].id]=dep[s]+dep[t]-dep[f]-dep[ff];
			ans[1][p[i].id]=sum(st[s])+sum(st[t])-sum(st[f])-sum(st[ff]);
		} else add(st[s=p[i].s],1),add(ed[s]+1,-1);
	for(i=1;i&lt;=cnt;++i)printf(&quot;%d %d\n&quot;,ans[0][i],ans[1][i]);
	return 0;
}
<pre><h2>Problem4514</h2><pre>#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

const int MAXN = 200;
const int MAXA = 1e9;
const int MAXP = 1e6;

struct Node;
struct Edge;

struct Node {
    Edge *e, *in;
    int c, f;
    long long d;
    bool q;
} N[MAXN + 3];

struct Edge {
    Node *s, *t;
    int f, c;
    long long w;
    Edge *next, *r;

    Edge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {}
} *limE;

template &lt;typename T, size_t SIZE&gt;
struct MemoryPool {
    char buf[SIZE * sizeof(T)], *cur;

    MemoryPool() {
        reset();
    }

    void reset() { cur = buf; }

    T *alloc() {
        if (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));
        else {
            char *p = cur;
            cur += sizeof(T);
            return (T *)p;
        }
    }
};

MemoryPool&lt;Edge, MAXN * MAXN * 10&gt; pool;
inline Edge *addEdge(int u, int v, const int c, const long long w) {
    // printf(&quot;E(%d, %d, %d, %d)\n&quot;, u, v, c, w);
    N[u].e = &amp;(*(pool.alloc()) = Edge(&amp;N[u], &amp;N[v], c, w));
    N[v].e = &amp;(*(pool.alloc()) = Edge(&amp;N[v], &amp;N[u], 0, -w));
    N[u].e-&gt;r = N[v].e, N[v].e-&gt;r = N[u].e;

    return N[u].e;
}

inline void edmondskarp(const int s, const int t, const int n, int &amp;flow, long long &amp;cost) {
    flow = cost = 0;
    while (1) {
        for (int i = 0; i &lt; n; i++) {
            N[i].q = false;
            N[i].in = NULL;
            N[i].f = 0;
            N[i].d = LLONG_MAX;
        }

        std::queue&lt;Node *&gt; q;
        q.push(&amp;N[s]);
        N[s].d = 0, N[s].f = INT_MAX;

        while (!q.empty()) {
            Node *v = q.front();
            q.pop();
            v-&gt;q = false;
            for (Edge *e = v-&gt;e; e; e = e-&gt;next) {
                if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) {
                    e-&gt;t-&gt;d = v-&gt;d + e-&gt;w;
                    e-&gt;t-&gt;in = e;
                    e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f);
                    if (!e-&gt;t-&gt;q) {
                        e-&gt;t-&gt;q = true;
                        q.push(e-&gt;t);
                    }
                }
            }
        }

        if (N[t].d == LLONG_MAX) return;

        for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) {
            e-&gt;f += N[t].f;
            e-&gt;r-&gt;f -= N[t].f;
        }

        flow += N[t].f;
        cost += N[t].f * N[t].d;
        // printf(&quot;cost = %d\n&quot;, -cost);
    }    
}

int n, s, ss, t;

struct Number {
    int a, b, c, t;

    bool operator&lt;(const Number &amp;o) const { return a &lt; o.a; }
} a[MAXN + 1];

inline void color() {
    for (int i = 1; i &lt;= n; i++) {
        if (N[i].c != 0) continue;

        std::queue&lt;Node *&gt; q;
        q.push(&amp;N[i]);
        N[i].c = 1;

        while (!q.empty()) {
            Node *v = q.front();
            q.pop();

            for (Edge *e = v-&gt;e; e; e = e-&gt;next) {
                if (e-&gt;t-&gt;c == 0) {
                    e-&gt;t-&gt;c = (v-&gt;c == 1) ? -1 : 1;
                    q.push(e-&gt;t);
                } else {
                    // if (e-&gt;t-&gt;c == v-&gt;c) throw;
                }
            }
        }
    }    
}

inline bool check(const int limit) {
    for (int i = 0; i &lt; n + 3; i++) {
        for (Edge *e = N[i].e; e; e = e-&gt;next) {
            e-&gt;f = 0;
        }
    }

    limE-&gt;c = limit;

    int flow;
    long long cost;
    edmondskarp(ss, t, n + 3, flow, cost);
    // printf(&quot;cost = %d\n&quot;, cost);
    return cost &lt;= 0;
}

inline int solve() {
    limE-&gt;c = INT_MAX;
    int flow;
    long long cost;
    edmondskarp(ss, t, n + 3, flow, cost);

    int l = 0, r = flow;
    while (l &lt; r) {
        // printf(&quot;(%d, %d)\n&quot;, l, r);
        int mid = l + ((r - l) &gt;&gt; 1) + 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }

    return l;
}

bool isNotPrime[MAXP + 1];
int primes[MAXP], cnt;
inline void euler() {
    isNotPrime[0] = isNotPrime[1] = true;
    for (int i = 2; i &lt;= MAXP; i++) {
        if (!isNotPrime[i]) {
            primes[cnt++] = i;
        }

        for (int j = 0; j &lt; cnt; j++) {
            if (primes[j] * i &gt; MAXP) break;
            isNotPrime[primes[j] * i] = true;
            if (i % primes[j] == 0) break; 
        }
    }
}

inline bool isPrime(const int x) {
    if (x &lt;= MAXP &amp;&amp; isNotPrime[x]) return false;
    if (x == 1) return false;
    for (int i = 0; i &lt; cnt; i++) {
        int &amp;p = primes[i];
        if (p * p &gt; x) return true;
        if (x % p == 0) return false;
    }
    return true;
}

inline int fast_pow(int a, int b, int mod) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = 1ll * a * a % mod)
		if (b &amp; 1) r = 1ll * r * a % mod;
	return r;
}

inline bool is_prime(const int &amp;x) {
	static const int p[] = {2, 3, 5, 7, 11, 13, 998244353};

	for (int i = 0; i &lt; 7; ++i) {
		if (x == p[i])
			return true;
		if (x % p[i] == 0)
			return false;
		if (fast_pow(p[i], x, x - 1) ^ 1)
			return false;
	}

	return true;
}
int main() {
    //freopen(&quot;pair.in&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;pair.out&quot;, &quot;w&quot;, stdout);

    euler();

    scanf(&quot;%d&quot;, &amp;n);
    int sum = 0;
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i].a);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i].b), sum += a[i].b;
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i].c);
    std::sort(a + 1, a + n + 1);

    bool valid[MAXN + 1][MAXN + 1];
    for (int i = 1; i &lt;= n; i++) {
        Number &amp;xi = a[i];
        for (int j = 1; j &lt; i; j++) {
            Number &amp;xj = a[j];
            if (xi.a % xj.a == 0 &amp;&amp; isPrime(xi.a / xj.a)) {
                valid[i][j] = true;
                addEdge(i, j, 0, 0);
            }
        }
    }

    color();

    for (int i = 1; i &lt;= n; i++) {
        a[i].t = N[i].c;
        N[i].e = NULL;
    }

    pool.reset();

    s = 0, ss = n + 1, t = n + 2;
    for (int i = 1; i &lt;= n; i++) {
        Number &amp;xi = a[i];
        for (int j = 1; j &lt; i; j++) {
            Number &amp;xj = a[j];
            if (valid[i][j]) {
                // if (xi.t == xj.t) puts(&quot;failed!&quot;);
                if (xi.t == 1) {
                    addEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);
                } else {
                    addEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);
                }
            }
        }

        if (N[i].c == 1) {
            addEdge(s, i, xi.b, 0);
        } else {
            addEdge(i, t, xi.b, 0);
        }
    }

    limE = addEdge(ss, s, sum, 0);

    printf(&quot;%d\n&quot;, solve());

    fclose(stdin);
    fclose(stdout);

    return 0;
}
<pre><h2>Problem4514</h2><pre>#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

const int MAXN = 200;
const int MAXA = 1e9;
const int MAXP = 1e6;

struct Node;
struct Edge;

struct Node {
    Edge *e, *in;
    int c, f;
    long long d;
    bool q;
} N[MAXN + 3];

struct Edge {
    Node *s, *t;
    int f, c;
    long long w;
    Edge *next, *r;

    Edge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s-&gt;e) {}
} *limE;

template &lt;typename T, size_t SIZE&gt;
struct MemoryPool {
    char buf[SIZE * sizeof(T)], *cur;

    MemoryPool() {
        reset();
    }

    void reset() { cur = buf; }

    T *alloc() {
        if (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));
        else {
            char *p = cur;
            cur += sizeof(T);
            return (T *)p;
        }
    }
};

MemoryPool&lt;Edge, MAXN * MAXN * 10&gt; pool;
inline Edge *addEdge(int u, int v, const int c, const long long w) {
    // printf(&quot;E(%d, %d, %d, %d)\n&quot;, u, v, c, w);
    N[u].e = &amp;(*(pool.alloc()) = Edge(&amp;N[u], &amp;N[v], c, w));
    N[v].e = &amp;(*(pool.alloc()) = Edge(&amp;N[v], &amp;N[u], 0, -w));
    N[u].e-&gt;r = N[v].e, N[v].e-&gt;r = N[u].e;

    return N[u].e;
}

inline void edmondskarp(const int s, const int t, const int n, int &amp;flow, long long &amp;cost) {
    flow = cost = 0;
    while (1) {
        for (int i = 0; i &lt; n; i++) {
            N[i].q = false;
            N[i].in = NULL;
            N[i].f = 0;
            N[i].d = LLONG_MAX;
        }

        std::queue&lt;Node *&gt; q;
        q.push(&amp;N[s]);
        N[s].d = 0, N[s].f = INT_MAX;

        while (!q.empty()) {
            Node *v = q.front();
            q.pop();
            v-&gt;q = false;
            for (Edge *e = v-&gt;e; e; e = e-&gt;next) {
                if (e-&gt;f &lt; e-&gt;c &amp;&amp; e-&gt;t-&gt;d &gt; v-&gt;d + e-&gt;w) {
                    e-&gt;t-&gt;d = v-&gt;d + e-&gt;w;
                    e-&gt;t-&gt;in = e;
                    e-&gt;t-&gt;f = std::min(v-&gt;f, e-&gt;c - e-&gt;f);
                    if (!e-&gt;t-&gt;q) {
                        e-&gt;t-&gt;q = true;
                        q.push(e-&gt;t);
                    }
                }
            }
        }

        if (N[t].d == LLONG_MAX) return;

        for (Edge *e = N[t].in; e; e = e-&gt;s-&gt;in) {
            e-&gt;f += N[t].f;
            e-&gt;r-&gt;f -= N[t].f;
        }

        flow += N[t].f;
        cost += N[t].f * N[t].d;
        // printf(&quot;cost = %d\n&quot;, -cost);
    }
}

int n, s, ss, t;

struct Number {
    int a, b, c, t;

    bool operator&lt;(const Number &amp;o) const { return a &lt; o.a; }
} a[MAXN + 1];

inline void color() {
    for (int i = 1; i &lt;= n; i++) {
        if (N[i].c != 0) continue;

        std::queue&lt;Node *&gt; q;
        q.push(&amp;N[i]);
        N[i].c = 1;

        while (!q.empty()) {
            Node *v = q.front();
            q.pop();

            for (Edge *e = v-&gt;e; e; e = e-&gt;next) {
                if (e-&gt;t-&gt;c == 0) {
                    e-&gt;t-&gt;c = (v-&gt;c == 1) ? -1 : 1;
                    q.push(e-&gt;t);
                } else {
                    // if (e-&gt;t-&gt;c == v-&gt;c) throw;
                }
            }
        }
    }    
}

inline bool check(const int limit) {
    for (int i = 0; i &lt; n + 3; i++) {
        for (Edge *e = N[i].e; e; e = e-&gt;next) {
            e-&gt;f = 0;
        }
    }

    limE-&gt;c = limit;

    int flow;
    long long cost;
    edmondskarp(ss, t, n + 3, flow, cost);
    // printf(&quot;cost = %d\n&quot;, cost);
    return cost &lt;= 0;
}

inline int solve() {
    limE-&gt;c = INT_MAX;
    int flow;
    long long cost;
    edmondskarp(ss, t, n + 3, flow, cost);

    int l = 0, r = flow;
    while (l &lt; r) {
        // printf(&quot;(%d, %d)\n&quot;, l, r);
        int mid = l + ((r - l) &gt;&gt; 1) + 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }

    return l;
}

bool isNotPrime[MAXP + 1];
int primes[MAXP], cnt;
inline void euler() {
    isNotPrime[0] = isNotPrime[1] = true;
    for (int i = 2; i &lt;= MAXP; i++) {
        if (!isNotPrime[i]) {
            primes[cnt++] = i;
        }

        for (int j = 0; j &lt; cnt; j++) {
            if (primes[j] * i &gt; MAXP) break;
            isNotPrime[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

inline bool isPrime(const int x) {
    if (x &lt;= MAXP &amp;&amp; isNotPrime[x]) return false;
    if (x == 1) return false;
    for (int i = 0; i &lt; cnt; i++) {
        int &amp;p = primes[i];
        if (p * p &gt; x) return true;
        if (x % p == 0) return false;
    }
    return true;
}

inline int fast_pow(int a, int b, int mod) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = 1ll * a * a % mod)
		if (b &amp; 1) r = 1ll * r * a % mod;
	return r;
}

inline bool is_prime(const int &amp;x) {
	static const int p[] = {2, 3, 5, 7, 11, 13, 998244353, 19, 23, 41};

	for (int i = 0; i &lt; 10; ++i) {
		if (x == p[i])
			return true;
		if (x % p[i] == 0)
			return false;
		if (fast_pow(p[i], x - 1, x) ^ 1)
			return false;
	}

	return true;
}
int main() {
    //freopen(&quot;pair.in&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;pair.out&quot;, &quot;w&quot;, stdout);

    euler();

    scanf(&quot;%d&quot;, &amp;n);
    int sum = 0;
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i].a);
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i].b), sum += a[i].b;
    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i].c);
    std::sort(a + 1, a + n + 1);

    bool valid[MAXN + 1][MAXN + 1];
    for (int i = 1; i &lt;= n; i++) {
        Number &amp;xi = a[i];
        for (int j = 1; j &lt; i; j++) {
            Number &amp;xj = a[j];
            if (xi.a % xj.a == 0 &amp;&amp; is_prime(xi.a / xj.a)) {
                valid[i][j] = true;
                addEdge(i, j, 0, 0);
            }
        }
    }

    color();

    for (int i = 1; i &lt;= n; i++) {
        a[i].t = N[i].c;
        N[i].e = NULL;
    }

    pool.reset();

    s = 0, ss = n + 1, t = n + 2;
    for (int i = 1; i &lt;= n; i++) {
        Number &amp;xi = a[i];
        for (int j = 1; j &lt; i; j++) {
            Number &amp;xj = a[j];
            if (valid[i][j]) {
                // if (xi.t == xj.t) puts(&quot;failed!&quot;);
                if (xi.t == 1) {
                    addEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);
                } else {
                    addEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);
                }
            }
        }

        if (N[i].c == 1) {
            addEdge(s, i, xi.b, 0);
        } else {
            addEdge(i, t, xi.b, 0);
        }
    }

    limE = addEdge(ss, s, sum, 0);

    printf(&quot;%d\n&quot;, solve());

    fclose(stdin);
    fclose(stdout);

    return 0;
}
<pre><h2>Problem4514</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int maxn(215), inf(0x3f3f3f3f);

inline int fast_pow(int a, int b, int mod) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = 1ll * a * a % mod)
		if (b &amp; 1) r = 1ll * r * a % mod;
	return r;
}

inline bool is_prime(const int &amp;x) {
	static const int p[] = {2, 3, 5, 7, 11, 13, 998244353};

	for (int i = 0; i &lt; 7; ++i) {
		if (x == p[i])
			return true;
		if (x % p[i] == 0)
			return false;
		if (fast_pow(p[i], x - 1, x) ^ 1)
			return false;
	}

	return true;
}

struct node {
	int a, b, c;
} a[maxn];

inline bool operator &lt; (const node &amp;x, const node &amp;y) {
	return x.a &lt; y.a;
}

struct edge {
	int to, cap, flow, nxt;
	long long cost;
} e[maxn * maxn * 10];

int g[maxn], cnt;
bool inq[maxn], col[maxn];

inline void add_edge(int u, int v, int cap, long long cost) {
	e[cnt] = (edge) {v, cap, 0, g[u], cost};
	g[u] = cnt++;
	e[cnt] = (edge) {u,   0, 0, g[v], -cost};
	g[v] = cnt++;
}


inline void EK(int s, int t, const int &amp;n, int &amp;max_flow, long long &amp;min_cost) {

	min_cost = max_flow = 0;

	while (true) {
		static long long dis[maxn];
		static int from[maxn], flow[maxn];
		memset(from, -1, n * sizeof(int));
		memset(flow,  0, n * sizeof(int));
		memset(dis, 63, n * sizeof(long long));

		static std::queue&lt;int&gt; q;
		dis[s] = 0;
		flow[s] = inf;
		q.push(s);

		while (!q.empty()) {
			int u = q.front();
			q.pop();
			inq[u] = false;
			for (int i = g[u]; ~i; i = e[i].nxt)
				if (e[i].flow &lt; e[i].cap &amp;&amp; dis[e[i].to] &gt; dis[u] + e[i].cost){
					dis[e[i].to] = dis[u] + e[i].cost;
					from[e[i].to] = i;
					flow[e[i].to] = std::min(flow[u], e[i].cap - e[i].flow);
					if (!inq[e[i].to]) {
						inq[e[i].to] = true;
						q.push(e[i].to);
					}
				}
		}

		if (dis[t] &gt;= 0x3f3f3f3f3f3f3f3fll) break;

		for (int i = from[t]; ~i; i = from[e[i ^ 1].to]) {
			e[i].flow += flow[t];
			e[i ^ 1].flow -= flow[t];
		}

		max_flow += flow[t];
		min_cost += flow[t] * dis[t];

	}

}

inline bool check(const int &amp;mid, const int &amp;n) {

	for (int i = 0; i &lt; n; ++i) {
		for (int j = g[i]; ~j; j = e[j].nxt)
			e[j].flow = 0;
	}

	e[cnt - 2].cap = mid;
	static int flow;
	static long long min_cost;
	EK(n - 1, n - 2, n, flow, min_cost);
	return min_cost &lt;= 0;
}

inline int solve(const int &amp;n) {
	e[cnt - 2].cap = inf;
	int flow;
	long long min_cost;
	EK(n - 1, n - 2, n, flow, min_cost);

	int l = 0, r = flow, mid;

	while (l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if (check(mid, n))
			l = mid + 1;
		else
			r = mid - 1;
	}

	return l - 1;

}

int main() {

	//freopen(&quot;4514.in&quot;, &quot;r&quot;, stdin);

	int n;
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i].a);
	for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i].b);
	for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i].c);

	std::sort(a, a + n);

	static bool match[maxn][maxn];

	memset(g, -1, sizeof g);

	for (int i = 0; i &lt; n; ++i)
		for (int j = 0; j &lt; i; ++j)
			if (a[i].a % a[j].a == 0 &amp;&amp; is_prime(a[i].a / a[j].a)) {
				match[i][j] = true;
				add_edge(i, j, 0, 0);
			}

	for (int i = 0; i &lt; n; ++i)
		if (!inq[i]) {
			static std::queue&lt;int&gt; q;
			q.push(i);
			col[i] = true;
			while (!q.empty()) {
				int u = q.front();
				q.pop();
				for (int i = g[u]; ~i; i = e[i].nxt)
					if (!inq[e[i].to]) {
						q.push(e[i].to);
						inq[e[i].to] = true;
						col[e[i].to] = col[u] ^ true;
					}
			}
		}

	memset(g, -1, sizeof g);
	memset(inq, 0, sizeof inq);

	cnt = 0;
	int s = n, t = n + 1, ss = n + 2;
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; i; ++j)
			if (match[i][j]) {
				if (col[i])
					add_edge(i, j, inf, -1ll * a[i].c * a[j].c);
				else
					add_edge(j, i, inf, -1ll * a[i].c * a[j].c);
			}
		if (col[i])
			add_edge(s, i, a[i].b, 0);
		else
			add_edge(i, t, a[i].b, 0);
	}

	add_edge(ss, s, 0, 0);

	printf(&quot;%d\n&quot;, solve(n + 3));

	return 0;
}
<pre><h2>Problem4514</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#ifdef WIN32
#define LL &quot;%I64d&quot;
#else
#define LL &quot;%lld&quot;
#endif
using namespace std;
typedef long long i64;
const int N=4005;
const int M=5e5+5;
const i64 inf=10000000000000LL;//一定要够大 
struct edge{int v,next;i64 cap,cost;}e[M];int tot=1,head[N];
int n,m,S,T,q[N],prev[N];bool vis[N];
i64 a[N],b[N],c[N];
i64 answ,ansf,dis[N];
void add(int x,int y,i64 z,i64 cost){
    e[++tot].v=y;e[tot].cap=z;e[tot].cost=cost;e[tot].next=head[x];head[x]=tot;
    e[++tot].v=x;e[tot].cap=0;e[tot].cost=-cost;e[tot].next=head[y];head[y]=tot;
}
bool spfa(){//非负费用最大流贪心流一定是正确的
    for(int i=S;i&lt;=T;i++) vis[i]=0,dis[i]=-inf;
    unsigned short h=0,t=1;q[t]=S;dis[S]=0;
    while(h!=t){
        int x=q[++h];vis[x]=0;
        for(int i=head[x];i;i=e[i].next){
            if(e[i].cap&amp;&amp;dis[e[i].v]&lt;dis[x]+e[i].cost){
                dis[e[i].v]=dis[x]+e[i].cost;
                prev[e[i].v]=i;
                if(!vis[e[i].v]){
                    vis[e[i].v]=1;//SLF优化还比朴素慢
                    //if(dis[e[i].v]&gt;dis[x]){ 
                    //    q[h--]=e[i].v;
                    //}
                    //else{
                        q[++t]=e[i].v;
                    //}
                }
            }
        }
    }
    return answ+dis[T]&gt;=0;//费用为非负的极限    
}
void augment(){
    i64 flow=inf;
    if(dis[T]&lt;0) flow=answ/(-dis[T]);
    for(int i=T;i!=S;i=e[prev[i]^1].v){
        flow=min(flow,e[prev[i]].cap);
    }
    for(int i=T;i!=S;i=e[prev[i]^1].v){
        e[prev[i]].cap-=flow;
        e[prev[i]^1].cap+=flow;
    }
    ansf+=flow;
    answ+=flow*dis[T];
}
i64 fpow(i64 a,i64 p,i64 mod){
    i64 res=1;
    for(;p;p&gt;&gt;=1,a=a*a%mod) if(p&amp;1) res=res*a%mod;
    return res;
}
bool judge(i64 x){
    if(x&lt;2) return 0;
    if(x==2) return 1;
    if(x&amp;1^1) return 0;
    i64 a,t;
    for(int i=1;i&lt;=10;i++){
        a=rand()%M;
        if(a&gt;=x&amp;&amp;a%x==0) continue;
        t=fpow(a,x-1,x);
        if(t!=1) return 0;
    } 
    return 1;
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);S=0,T=n&lt;&lt;1|1;
    for(int i=1;i&lt;=n;i++) scanf(LL,&amp;a[i]);
    for(int i=1;i&lt;=n;i++){
        scanf(LL,&amp;b[i]);
        add(S,i,b[i],0);
        add(i+n,T,b[i],0);
    }
    for(int i=1;i&lt;=n;i++) scanf(LL,&amp;c[i]);
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            if(i==j) continue;//暴力建图 
            if(a[j]&amp;&amp;!(a[i]%a[j])&amp;&amp;judge(a[i]/a[j])){
                add(i,j+n,inf,c[i]*c[j]);
            }
            if(a[i]&amp;&amp;!(a[j]%a[i])&amp;&amp;judge(a[j]/a[i])){
                add(i,j+n,inf,c[i]*c[j]);
            }
        }
    }
    while(spfa()) augment();
    printf(LL,ansf/2);
    return 0;
}<pre><h2>Problem4517</h2><pre>#include &lt;cstdio&gt;

const int mod = 1e9 + 7, MaxN = 1e6 + 5;
typedef int arr[MaxN];

arr f, d, inv;

void Inv(int a, int &amp;r) {
	r = 1;
	for (int b = mod - 2; b; b &gt;&gt;= 1, a = (long long)a * a % mod)
	  if (b &amp; 1) r = (long long)a * r % mod;
}

void Init() {
    d[1] = 0;
    d[0] = d[2] = 1;
    f[0] = f[1] = 1;
	f[2] = 2;
	inv[0] = inv[1] = 1;
    for (int i = 3; i &lt; MaxN; ++i) {
        d[i] = (i - 1LL) * (d[i - 1] + d[i - 2]) % mod;
        f[i] = (long long)f[i - 1] * i % mod;
    }
	Inv(f[MaxN - 1], inv[MaxN - 1]);
	for (int i = MaxN - 2; i; --i)
	  inv[i] = (long long)inv[i + 1] * (i + 1) % mod;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
#endif // ONLINE_JUDGE
    int T, n, m, t;
    Init();
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        t = (long long)f[n] * inv[n - m] % mod * inv[m] % mod * d[n - m] % mod;
        printf(&quot;%d\n&quot;, t);
    }
}<pre><h2>Problem4520</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 100005
int n, m, tx, ty, rt, h[N], cmp_d;
inline void cmin(int &amp;a, const int &amp;b) {
	if (b &lt; a) a = b;
}
inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}
priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt;heap;
struct node {
	int d[2], x[2], y[2], ls, rs;
	void init(const int &amp;a, const int &amp;b) {
		d[0] = x[0] = x[1] = a;
		d[1] = y[0] = y[1] = b;
	}
}p[N];
bool cmp(const int &amp;a, const int &amp;b) {
	return p[a].d[cmp_d] &lt; p[b].d[cmp_d];
}
void update(node &amp;u, const node &amp;v) {
	cmin(u.x[0], v.x[0]);
	cmin(u.y[0], v.y[0]);
	cmax(u.x[1], v.x[1]);
	cmax(u.y[1], v.y[1]);
}
void build(int &amp;u, int l, int r, int D) {
	int mid = (l + r) &gt;&gt; 1;
	cmp_d = D;
	nth_element(h + l, h + mid, h + r + 1, cmp);
	u = h[mid];
	if (l &lt; mid) {
		build(p[u].ls, l, mid - 1, D ^ 1);
		update(p[u], p[p[u].ls]);
	}
	if (mid &lt; r) {
		build(p[u].rs, mid + 1, r, D ^ 1);
		update(p[u], p[p[u].rs]);
	}
}
inline long long p2(const int &amp;x) {
	return (long long)x * x;
}
inline long long func(const node &amp;u) {
	return max(p2(u.x[0] - tx), p2(u.x[1] - tx)) + max(p2(u.y[0] - ty), p2(u.y[1] - ty));
}
void query(int u) {
	long long dl = func(p[p[u].ls]), dr = func(p[p[u].rs]), du = p2(p[u].d[0] - tx) + p2(p[u].d[1] - ty);
	if (du &gt; heap.top()) {
		heap.pop();
		heap.push(du);
	}
	if (dl &lt; dr) {
		if (p[u].rs &amp;&amp; dr &gt; heap.top()) query(p[u].rs);
		if (p[u].ls &amp;&amp; dl &gt; heap.top()) query(p[u].ls);
	} else {
		if (p[u].ls &amp;&amp; dl &gt; heap.top()) query(p[u].ls);
		if (p[u].rs &amp;&amp; dr &gt; heap.top()) query(p[u].rs);
	}
}
int main() {
#ifndef ONLINE_JUDGE
	freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
#endif
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1, x, y; i &lt;= n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		p[i].init(x, y);
		h[i] = i;
	}
	build(rt, 1, n, 0);
	for (int i = 0; i &lt; m; ++i) {
		heap.push(0);
		heap.push(0);
	}
	for (int i = 1; i &lt;= n; ++i) {
		tx = p[i].d[0], ty = p[i].d[1];
		query(rt);
	}
	printf(&quot;%lld\n&quot;, heap.top());
	return 0;
}<pre><h2>Problem4524</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;

struct D {
	unsigned int x, y, z;
	unsigned long long val;
	D(unsigned int x, unsigned int y, unsigned int z, unsigned long long val) :
		x(x), y(y), z(z), val(val) {}
};

bool operator &lt; (const D &amp;a, const D &amp;b) {
	return a.val &lt; b.val;
}

int main() {
	static bool vis[133];
	static unsigned long long n, x;
	static unsigned int k, p[133], cnt = 0;
	static std::priority_queue&lt;D&gt; heap;
	scanf(&quot;%llu%u&quot;, &amp;n, &amp;k);
	for (register unsigned int i = 2; i ^ 128; ++i)
		if (!vis[i]) {
			x = p[++cnt] = i;
			for (register unsigned int j = 1; x  &lt;= n; x *= i, ++j)
				heap.push(D(i, j, cnt - 1, x));
			for (register unsigned int j = i * i; j &lt; 128; j += i)
				vis[j] = true;
		}
	while (--k) {
		static D t(0, 0, 0, 0);
		t = heap.top();
		heap.pop();
		if (t.y &lt;= 1) continue;
		for (register unsigned int i = 1; i &lt;= t.z; ++i)
			heap.push(D(t.x, t.y - 1, i, t.val / t.x * p[i]));
	}
	printf(&quot;%llu\n&quot;, heap.top().val);
	return 0;
}<pre><h2>Problem4537</h2><pre>#include &lt;bits/stdc++.h&gt;
inline void gi(int &amp;a) {
	static char c;
	while (c = getchar(), c &lt; '0'); a = c - '0';
	while (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

#define N 50003
#define M 100003
int fa[N], sz[N], ma[N], mb[N];
inline int gf(int u) {
	while (fa[u] ^ u) u = fa[u];
	return u;
}
bool ans[N];
struct Data {
	int u, v, a, b, id;
	void Input(const int &amp;i) {
		gi(u), gi(v), gi(a), gi(b), id = i;
	}
}edge[M], qu[N], tq[N];
bool cpa(const Data &amp;a, const Data &amp;b) {
	return (a.a ^ b.a) ? a.a &lt; b.a : a.b &lt; b.b;
}
bool operator &lt; (const Data &amp;a, const Data &amp;b) {
	return (a.b ^ b.b) ? a.b &lt; b.b : a.a &lt; b.a;
}
struct Opt {
	int u, v, sz, ma, mb;
}stk[M], *tp = stk;

inline void cmax(int &amp;a, const int &amp;b) {
	if (a &lt; b) a = b;
}

inline void merge(int u, int v, int a, int b) {
	u = gf(u), v = gf(v);
	if (sz[v] &lt; sz[u]) std::swap(u, v);
	*++tp = (Opt) {u, v, sz[v], ma[v], mb[v]};
	if (u ^ v) {
		fa[u] = v;
		sz[v] += sz[u];
		cmax(ma[v], std::max(a, ma[u]));
		cmax(mb[v], std::max(b, mb[u]));
	} else cmax(ma[v], a), cmax(mb[v], b);
}

inline void undo() {
	for (; stk &lt; tp; --tp) {
		fa[tp-&gt;u] = tp-&gt;u;
		sz[tp-&gt;v] = tp-&gt;sz;
		ma[tp-&gt;v] = tp-&gt;ma;
		mb[tp-&gt;v] = tp-&gt;mb;
	}
}

int main() {
	int n, m, rm, q, i, j, k, p, tot, u, v;
	gi(n), gi(m); rm = sqrt(m);

	for (i = 1; i &lt;= m; ++i)
		edge[i].Input(i);
	std::sort(edge + 1, edge + m + 1, cpa);

	gi(q);
	for (i = 1; i &lt;= q; ++i)
		qu[i].Input(i);
	std::sort(qu + 1, qu + q + 1);

	for (i = 1; i &lt;= m; i += rm) {
		tot = 0;
		for (j = 1; j &lt;= q; ++j)
			if (edge[i].a &lt;= qu[j].a &amp;&amp; (i + rm &gt; m || qu[j].a &lt; edge[i + rm].a))
				tq[++tot] = qu[j];
		std::sort(edge + 1, edge + i);
		for (j = 1; j &lt;= n; ++j)
			fa[j] = j, sz[j] = 1, ma[j] = mb[j] = -1;
		for (j = k = 1; j &lt;= tot; ++j) {
			for (; k &lt; i &amp;&amp; edge[k].b &lt;= tq[j].b; ++k)
				merge(edge[k].u, edge[k].v, edge[k].a, edge[k].b);
			tp = stk;
			for (p = i; p &lt; i + rm &amp;&amp; p &lt;= m; ++p)
				if (edge[p].a &lt;= tq[j].a &amp;&amp; edge[p].b &lt;= tq[j].b)
					merge(edge[p].u, edge[p].v, edge[p].a, edge[p].b);
			u = gf(tq[j].u), v = gf(tq[j].v);
			ans[tq[j].id] = (u == v &amp;&amp; ma[u] == tq[j].a &amp;&amp; mb[u] == tq[j].b);
			undo();
		}
	}
	for (i = 1; i &lt;= q; ++i)
		puts(ans[i] ? &quot;Yes&quot; : &quot;No&quot;);
	return 0;
}<pre><h2>Problem4538</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define N 100003
#define wlp while
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)

template&lt;class integer&gt;
inline void gi(integer &amp;a) {
	static char c;
	wlp (c = getchar(), c &lt; '0'); a = c - '0';
	wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

struct heap {
	priority_queue&lt;int&gt; a, b;
	void erase(const int &amp;x) {
		b.push(x);
	}
	int top() {
		wlp (!b.empty() &amp;&amp; a.top() == b.top()) {
			a.pop();
			b.pop();
		}
		return a.top();
	}
	void push(const int &amp;x) {
		a.push(x);
	}
	heap() {
		a.push(-1);
	}
}hp[N&lt;&lt;2|1];

struct event {
	int a, b, v;
}a[N];

struct edge {
	int t;
	edge *n;
}me[N&lt;&lt;1|1], *ce = me, *g[N];
#define adde(a, b) (*ce = (edge){b, g[a]}, g[a] = ce++)
#define FOR(a, b) for (edge *a = g[b]; a; a = a-&gt;n)
int fa[N], son[N], tp[N], dep[N], dfn[N], _dfn;
void d1(int u) {
	static int sz[N];
	sz[u] = 1;
	FOR(it, u) if (it-&gt;t ^ fa[u]) {
		fa[it-&gt;t] = u;
		dep[it-&gt;t] = dep[u] + 1;
		d1(it-&gt;t);
		if (sz[it-&gt;t] &gt;= sz[son[u]]) son[u] = it-&gt;t;
		sz[u] += sz[it-&gt;t];
	}
}
void d2(int u, int anc) {
	dfn[u] = ++_dfn;
	tp[u] = anc;
	if (son[u]) d2(son[u], anc);
	FOR(it, u) if (!tp[it-&gt;t]) d2(it-&gt;t, it-&gt;t);
}

#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
void upd(int u, int l, int r, const int &amp;x, const int &amp;y, const int &amp;v, const bool &amp;flag) {
	if (x &lt;= l &amp;&amp; r &lt;= y) 
		return flag ? hp[u].push(v) : hp[u].erase(v);
	int m = l + r &gt;&gt; 1;
	if (x &lt;= m) upd(ls, l, m, x, y, v, flag);
	if (y &gt;  m) upd(rs, m + 1, r, x, y, v, flag);
}

int quy(const int &amp;p) {
	static int u, l, r, v, t, m;
	for (u = 1, l = 1, r = _dfn, v = -1; l ^ r; ) {
		if (v &lt; (t = hp[u].top())) v = t;
		m = l + r &gt;&gt; 1;
		if (p &lt;= m) u = ls, r = m;
		else u = rs, l = m + 1;
	}
	if (v &lt; (t = hp[u].top())) v = t;
	return v;
}

pair&lt;int, int&gt;sg[N];
inline void modify(int u, int v, const int &amp;val, const bool &amp;flag) {
	static int cnt, i, l, r, pre;
	for (cnt = 0; tp[u] ^ tp[v];)
		if (dep[tp[u]] &lt; dep[tp[v]]) {
			sg[cnt++] = pair&lt;int, int&gt;(dfn[tp[v]], dfn[v]);
			v = fa[tp[v]];
		} else {
			sg[cnt++] = pair&lt;int, int&gt;(dfn[tp[u]], dfn[u]);
			u = fa[tp[u]];
		}
	if (dep[u] &lt; dep[v]) u ^= v ^= u ^= v;
	sg[cnt++] = pair&lt;int, int&gt;(dfn[v], dfn[u]);
	sort(sg, sg + cnt);
	pre = 0;
	for (i = 0; i &lt; cnt; ++i) {
		l = pre + 1;
		r = sg[i].first - 1;
		pre = sg[i].second;
		if (l &lt;= r) upd(1, 1, _dfn, l, r, val, flag);
	}
	if (pre ^ _dfn) upd(1, 1, _dfn, pre + 1, _dfn, val, flag);
}

int main() {
	int n, m, u, v, type, x;
	gi(n), gi(m);
	rep(i, 2, n) {
		gi(u), gi(v);
		adde(u, v);
		adde(v, u);
	}
	d1(1); d2(1, 1);
	rep(i, 1, m) {
		gi(type);
		if (!type) {
			gi(u), gi(v), gi(x);
			a[i] = (event) {u, v, x};
			modify(u, v, x, true);
		} else if (type &amp; 1) {
			gi(x);
			modify(a[x].a, a[x].b, a[x].v, false);
		} else gi(x), printf(&quot;%d\n&quot;, quy(dfn[x]));
	}
	return 0;
}<pre><h2>Problem4538</h2><pre>#pragma comment(linker, &quot;/STACK:102400000,102400000&quot;)
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define N 200003
#define wlp while
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)

template&lt;class integer&gt;
inline void gi(integer &amp;a) {
	static char c;
	wlp (c = getchar(), c &lt; '0'); a = c - '0';
	wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

typedef int arr[N];
arr tp, fa, son, dep, in, ou, tr, ans;
int dfn;

struct node {
	int a, b, v, lca;
}a[N];

struct opt {
	int type, x, id;
}q[N], tq[N];

struct edge {
	int t;
	edge *n;
}me[N&lt;&lt;1|1], *ce = me, *g[N];
#define adde(a, b) (*ce = (edge){b, g[a]}, g[a] = ce++)
#define FOR(a, b) for (edge *a = g[b]; a; a = a-&gt;n)
void d1(int u) {
	static int sz[N];
	sz[u] = 1;
	FOR(it, u) if (it-&gt;t ^ fa[u]) {
		fa[it-&gt;t] = u;
		dep[it-&gt;t] = dep[u] + 1;
		d1(it-&gt;t);
		if (sz[it-&gt;t] &gt; sz[son[u]]) son[u] = it-&gt;t;
		sz[u] += sz[it-&gt;t];
	}
}
void d2(int u, int anc) {
	in[u] = ++dfn;
	tp[u] = anc;
	if (son[u]) d2(son[u], anc);
	FOR(it, u) if (!tp[it-&gt;t]) d2(it-&gt;t, it-&gt;t);
	ou[u] = dfn;
}

inline int Lca(int u, int v) {
	wlp (tp[u] ^ tp[v]) dep[tp[u]] &lt; dep[tp[v]] ? v = fa[tp[v]] : u = fa[tp[u]];
	return dep[u] &lt; dep[v] ? u : v;
}

inline void add(int x, const int &amp;delta) {
	for (; x &lt;= dfn; x += x &amp; -x)
		tr[x] += delta;
}

inline int sum(int x) {
	static int r;
	for (r = 0; 0 &lt; x; x ^= x &amp; -x)
		r += tr[x];
	return r;
}

inline int quy(const int &amp;u) {
	return sum(ou[u]) - sum(in[u] - 1);
}

inline void modify(const int &amp;id, const int &amp;delta) {
	add(in[a[id].a], delta);
	add(in[a[id].b], delta);
	add(in[a[id].lca], -delta);
	if (fa[a[id].lca]) add(in[fa[a[id].lca]], -delta);
}

void divide(int l, int r, int L, int R) {
	if (L &gt;= R || l &gt; r) {
		rep(i, l, r) 
			if (q[i].type == 2) ans[q[i].id] = L;
		return;
	}
	int mid = (long long)L + R &gt;&gt; 1, it = l - 1, cnt = 0, _t = 0, t;
	rep(i, l, r) 
		if (q[i].type == 2) (quy(q[i].x) ^ _t) ? tq[++cnt] = q[i] : q[++it] = q[i];
		else {
			t = q[i].type ? -1 : 1;
			if (a[q[i].x].v &lt;= mid) q[++it] = q[i];
			else {
				tq[++cnt] = q[i];
				_t += t;
				modify(q[i].x, t);
			}
		}
	rep(i, 1, cnt) {
		if (tq[i].type ^ 2) {
			t = tq[i].type ? 1 : -1;
			modify(tq[i].x, t);
		}
		q[i + it] = tq[i];
	}
	divide(l, it, L, mid);
	divide(it + 1, r, mid + 1, R);
}

int main() {
	//int size = 256 &lt;&lt; 20; // 256MB  
	//char *p = (char*)malloc(size) + size;  
	//__asm__(&quot;movl %0, %%esp\n&quot; :: &quot;r&quot;(p));
	//freopen(&quot;network6.in&quot;, &quot;r&quot;, stdin);
	int n, m, u, v, mx = -1;
	gi(n), gi(m);
	rep(i, 2, n) {
		gi(u), gi(v);
		adde(u, v);
		adde(v, u);
	}
	d1(1);
	d2(1, 1);
	rep(i, 1, m) {
		gi(q[i].type);
		q[i].id = i;
		if (q[i].type) gi(q[i].x);
		else {
			gi(a[i].a), gi(a[i].b), gi(a[i].v);
			a[i].lca = Lca(a[i].a, a[i].b);
			q[i].x = i;
			if (mx &lt; a[i].v) mx = a[i].v;
		}
		ans[i] = -2;
	}
	divide(1, m, -1, mx);
	rep(i, 1, m) 
		if (ans[i] ^ -2) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}<pre><h2>Problem4538</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define N 200003
#define wlp while
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)

template&lt;class integer&gt;
inline void gi(integer &amp;a) {
	static char c;
	wlp (c = getchar(), c &lt; '0'); a = c - '0';
	wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

typedef int arr[N];
arr tp, fa, son, dep, in, ou, tr, ans;
int dfn;

struct node {
	int a, b, v, lca;
}a[N];

struct opt {
	int type, x, id;
}q[N], tq[N];

struct edge {
	int t;
	edge *n;
}me[N&lt;&lt;1|1], *ce = me, *g[N];
#define adde(a, b) (*ce = (edge){b, g[a]}, g[a] = ce++)
#define FOR(a, b) for (edge *a = g[b]; a; a = a-&gt;n)
void d1(int u) {
	static int sz[N];
	sz[u] = 1;
	FOR(it, u) if (it-&gt;t ^ fa[u]) {
		fa[it-&gt;t] = u;
		dep[it-&gt;t] = dep[u] + 1;
		d1(it-&gt;t);
		if (sz[it-&gt;t] &gt; sz[son[u]]) son[u] = it-&gt;t;
		sz[u] += sz[it-&gt;t];
	}
}
void d2(int u, int anc) {
	in[u] = ++dfn;
	tp[u] = anc;
	if (son[u]) d2(son[u], anc);
	FOR(it, u) if (!tp[it-&gt;t]) d2(it-&gt;t, it-&gt;t);
	ou[u] = dfn;
}

inline int Lca(int u, int v) {
	wlp (tp[u] ^ tp[v]) dep[tp[u]] &lt; dep[tp[v]] ? v = fa[tp[v]] : u = fa[tp[u]];
	return dep[u] &lt; dep[v] ? u : v;
}

inline void add(int x, const int &amp;delta) {
	for (; x &lt;= dfn; x += x &amp; -x)
		tr[x] += delta;
}

inline int sum(int x) {
	static int r;
	for (r = 0; 0 &lt; x; x ^= x &amp; -x)
		r += tr[x];
	return r;
}

inline int quy(const int &amp;u) {
	return sum(ou[u]) - sum(in[u] - 1);
}

inline void modify(const int &amp;id, const int &amp;delta) {
	add(in[a[id].a], delta);
	add(in[a[id].b], delta);
	add(in[a[id].lca], -delta);
	if (fa[a[id].lca]) add(in[fa[a[id].lca]], -delta);
}

void divide(int l, int r, int L, int R) {
	if (L &gt;= R || l &gt; r) {
		rep(i, l, r) 
			if (q[i].type == 2) ans[q[i].id] = L;
		return;
	}
	int mid = L + R &gt;&gt; 1, it = l - 1, cnt = 0, _t = 0, t;
	rep(i, l, r) 
		if (q[i].type == 2) (quy(q[i].x) ^ _t) ? tq[++cnt] = q[i] : q[++it] = q[i];
		else {
			t = q[i].type ? -1 : 1;
			if (a[q[i].x].v &lt;= mid) q[++it] = q[i];
			else {
				tq[++cnt] = q[i];
				_t += t;
				modify(q[i].x, t);
			}
		}
	rep(i, 1, cnt) {
		if (tq[i].type ^ 2) {
			t = tq[i].type ? 1 : -1;
			modify(tq[i].x, t);
		}
		q[i + it] = tq[i];
	}
	divide(l, it, L, mid);
	divide(it + 1, r, mid + 1, R);
}

int main() {
	int n, m, u, v, mx = -1;
	gi(n), gi(m);
	rep(i, 2, n) {
		gi(u), gi(v);
		adde(u, v);
		adde(v, u);
	}
	d1(1);
	d2(1, 1);
	rep(i, 1, m) {
		gi(q[i].type);
		q[i].id = i;
		if (q[i].type) gi(q[i].x);
		else {
			gi(a[i].a), gi(a[i].b), gi(a[i].v);
			a[i].lca = Lca(a[i].a, a[i].b);
			q[i].x = i;
			if (mx &lt; a[i].v) mx = a[i].v;
		}
		ans[i] = -2;
	}
	divide(1, m, -1, mx);
	rep(i, 1, m) 
		if (ans[i] ^ -2) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}<pre><h2>Problem4538</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second
#define mp make_pair
#define inf 0x3f3f3f3f
#define maxn 100005
#define maxm 200005
pair&lt;int,int&gt;rng[maxn];
struct node{
    int op,id,x,ans;
    bool operator&lt;(const node &amp;t)const{ return id&lt;t.id; }
}q[maxm],tmp[maxm];
int cnt,v[maxn&lt;&lt;1],next[maxn&lt;&lt;1],first[maxn];
int ss,ST[maxn&lt;&lt;2][20],log_2[maxn&lt;&lt;1],vis[maxn],dep[maxn];
int n,m,A[maxm],B[maxm],C[maxm],dfn,BIT[maxn],fa[maxn];
int read(){
    int ttt=0; char ch=0;
    while(ch&lt;'0'||ch&gt;'9')ch=getchar();
    while(ch&gt;='0'&amp;&amp;ch&lt;='9')ttt=ttt*10+ch-'0',ch=getchar();
    return ttt;
}
void add(int st,int end){
    v[++cnt]=end;
    next[cnt]=first[st];
    first[st]=cnt;
}
void dfs(int x){
    rng[x].fir=++dfn;
    ST[++ss][0]=x;
    if(!vis[x])vis[x]=ss;
    for(int e=first[x];e;e=next[e])
        if(v[e]!=fa[x]){
            fa[v[e]]=x,dep[v[e]]=dep[x]+1;
            dfs(v[e]);
            ST[++ss][0]=x;
        }
    rng[x].sec=dfn;
}
int Min(int x,int y){
    return dep[x]&lt;dep[y]?x:y;
}
void build_ST(){
    log_2[1]=0;
    for(int i=2;i&lt;=ss;i++)
        log_2[i]=log_2[i&gt;&gt;1]+1;
    for(int j=1;j&lt;=log_2[ss];j++)
        for(int i=1;i&lt;=ss;i++)
            ST[i][j]=Min(ST[i][j-1],ST[i+(1&lt;&lt;(j-1))][j-1]);
}
void update(int pos,int x){
    for(int i=pos;i&lt;=n;i+=i&amp;-i)
        BIT[i]+=x;
}
int query_ST(int x,int y){
    x=vis[x],y=vis[y];
    if(x&gt;y)swap(x,y);
    int len=log_2[y-x+1];
    return Min(ST[x][len],ST[y-(1&lt;&lt;len)+1][len]);
}
//update操作传参biubiu
void update_op(int x,int y,int op){
    int lca=query_ST(x,y);
    update(rng[x].fir,op),update(rng[y].fir,op);
    update(rng[lca].fir,-op);
    if(fa[lca])update(rng[fa[lca]].fir,-op);//
}
int query(int pos){
    int sum=0;
    for(int i=pos;i;i-=i&amp;-i)sum+=BIT[i];
    return sum;
}
int query_op(int x){
    return query(rng[x].sec)-query(rng[x].fir-1);
}
void erfn(int L,int R,int l,int r){
    if(L&gt;R)return;//
    int mid=(l+r)&gt;&gt;1;
    if(l==r){
        for(int i=L;i&lt;=R;i++)
            if(q[i].op==2)q[i].ans=mid;
        return;
    }
    int qq=L-1,tt=0,num=0;
    for(int i=L;i&lt;=R;i++){
        if(q[i].op==2){
            if(query_op(q[i].x)==num)q[++qq]=q[i];
            else tmp[++tt]=q[i];
        }
        else{
            int op=q[i].op?-1:1;
            if(C[q[i].x]&lt;=mid)q[++qq]=q[i];
            else{
                tmp[++tt]=q[i],num+=op;
                update_op(A[q[i].x],B[q[i].x],op);
            }
        }
    }
    for(int i=1;i&lt;=tt;i++)
        if(tmp[i].op!=2){
            int op=tmp[i].op?1:-1;
            update_op(A[tmp[i].x],B[tmp[i].x],op);
        }
    for(int i=1;i&lt;=tt;i++)q[qq+i]=tmp[i];
    erfn(L,qq,l,mid);
    erfn(qq+1,qq+tt,mid+1,r);
}
int main(){
    n=read(),m=read();
    int a,b;
    for(int i=1;i&lt;n;i++){
        a=read(),b=read();
        add(a,b),add(b,a);
    }
    dfs(1);
    build_ST();
    int r=0;
    for(int i=1;i&lt;=m;i++){
        q[i].op=read();
        q[i].id=i;
        if(q[i].op==0){
            A[i]=read(),B[i]=read(),C[i]=read();
            q[i].x=i;
            r=max(r,C[i]);
        }
        else q[i].x=read();
    }
    erfn(1,m,-1,r);//
    sort(q+1,q+1+m);
    for(int i=1;i&lt;=m;i++)
        if(q[i].op==2)printf(&quot;%d\n&quot;,q[i].ans);
    return 0;
}<pre><h2>Problem4538</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define N 200003
#define wlp while
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)
 
template&lt;class integer&gt;
inline void gi(integer &amp;a) {
    static char c;
    wlp (c = getchar(), c &lt; '0'); a = c - '0';
    wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}
 
typedef int arr[N];
arr tp, fa, son, dep, in, ou, tr, ans;
int dfn;
 
struct node {
    int a, b, v, lca;
}a[N];
 
struct opt {
    int type, x, id;
}q[N], tq[N];
 
struct edge {
    int t;
    edge *n;
}me[N&lt;&lt;1|1], *ce = me, *g[N];
#define adde(a, b) (*ce = (edge){b, g[a]}, g[a] = ce++)
#define FOR(a, b) for (edge *a = g[b]; a; a = a-&gt;n)
void d1(int u) {
    static int sz[N];
    sz[u] = 1;
    FOR(it, u) if (it-&gt;t ^ fa[u]) {
        fa[it-&gt;t] = u;
        dep[it-&gt;t] = dep[u] + 1;
        d1(it-&gt;t);
        if (sz[it-&gt;t] &gt;= sz[son[u]]) son[u] = it-&gt;t;
        sz[u] += sz[it-&gt;t];
    }
}
void d2(int u, int anc) {
    in[u] = ++dfn;
    tp[u] = anc;
    if (son[u]) d2(son[u], anc);
    FOR(it, u) if (!tp[it-&gt;t]) d2(it-&gt;t, it-&gt;t);
    ou[u] = dfn;
}
 
inline int Lca(int u, int v) {
    wlp (tp[u] ^ tp[v]) dep[tp[u]] &lt; dep[tp[v]] ? v = fa[tp[v]] : u = fa[tp[u]];
    return dep[u] &lt; dep[v] ? u : v;
}
 
inline void add(int x, const int &amp;delta) {
    for (; x &lt;= dfn; x += x &amp; -x)
        tr[x] += delta;
}
 
inline int sum(int x) {
    static int r;
    for (r = 0; 0 &lt; x; x ^= x &amp; -x)
        r += tr[x];
    return r;
}
 
inline int quy(const int &amp;u) {
    return sum(ou[u]) - sum(in[u] - 1);
}
 
inline void modify(const int &amp;id, const int &amp;delta) {
    add(in[a[id].a], delta);
    add(in[a[id].b], delta);
    add(in[a[id].lca], -delta);
    if (fa[a[id].lca]) add(in[fa[a[id].lca]], -delta);
}
 
void divide(int l, int r, int L, int R) {
    if (L &gt;= R || l &gt; r) {
        rep(i, l, r) 
            if (q[i].type == 2) ans[q[i].id] = L;
        return;
    }
    int mid = L + R &gt;&gt; 1, it = l - 1, cnt = 0, _t = 0, t;
    rep(i, l, r) 
        if (q[i].type == 2) (quy(q[i].x) ^ _t) ? tq[++cnt] = q[i] : q[++it] = q[i];
        else {
            t = q[i].type ? -1 : 1;
            if (a[q[i].x].v &lt;= mid) q[++it] = q[i];
            else {
                tq[++cnt] = q[i];
                _t += t;
                modify(q[i].x, t);
            }
        }
    rep(i, 1, cnt) {
        if (tq[i].type ^ 2) {
            t = tq[i].type ? 1 : -1;
            modify(tq[i].x, t);
        }
        q[i + it] = tq[i];
    }
    divide(l, it, L, mid);
    divide(it + 1, r, mid + 1, R);
}
 
int main() {
    int n, m, u, v, mx = -1;
    gi(n), gi(m);
    rep(i, 2, n) {
        gi(u), gi(v);
        adde(u, v);
        adde(v, u);
    }
    d1(1);
    d2(1, 1);
    rep(i, 1, m) {
        gi(q[i].type);
        q[i].id = i;
        if (q[i].type) gi(q[i].x);
        else {
            gi(a[i].a), gi(a[i].b), gi(a[i].v);
            a[i].lca = Lca(a[i].a, a[i].b);
            q[i].x = i;
            if (mx &lt; a[i].v) mx = a[i].v;
        }
        ans[i] = -2;
    }
    divide(1, m, -1, mx);
    rep(i, 1, m) 
        if (ans[i] ^ -2) printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}<pre><h2>Problem4539</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define N 100003
#define MS 2000003
#define wlp while
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)
template&lt;class integer&gt;
inline void gi(integer &amp;a) {
	static char c;
	wlp (c = getchar(), c &lt; '0'); a = c - '0';
	wlp (c = getchar(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}
int n, m, dfn, in[N], ou[N], dq[N];

struct segnode {
	int sum;
	segnode *ls, *rs;
} segnodeset[MS], *csegnode = segnodeset, *rt[N];
void ins(segnode *x, segnode *(&amp;y), int l, int r, const int &amp;p) {
	*(y = ++csegnode) = *x;
	++y-&gt;sum;
	if (l ^ r) {
		int mid = l + r &gt;&gt; 1;
		if (p &lt;= mid) 
		  ins(x-&gt;ls, y-&gt;ls, l, mid, p);
		else
		  ins(x-&gt;rs, y-&gt;rs, mid + 1, r, p);
	}
}
inline int quy(const int &amp;u, int k) {
	static int l, r, mid, tmp;
	static segnode *x, *y;
	x = rt[in[u] - 1], y = rt[ou[u]];
	for (l = 1, r = n; l ^ r;) {
		mid = l + r &gt;&gt; 1;
		tmp = y-&gt;ls-&gt;sum - x-&gt;ls-&gt;sum;
		if (k &lt;= tmp) {
			r = mid;
			x = x-&gt;ls;
			y = y-&gt;ls;
		} else {
			l = mid + 1;
			k -= tmp;
			x = x-&gt;rs;
			y = y-&gt;rs;
		}
	}
	return l;
}

struct node {
	int rt, fa;
	long long l, r;
}a[N];

inline int binsea(const long long &amp;x, const int &amp;R) {
	static int l, r, mid;
	for (l = 1, r = R + 1; l + 1 &lt; r;)
	  if (a[mid = l + r &gt;&gt; 1].l &lt;= x)
		l = mid;
	  else 
		r = mid;
	return l;
}

struct Graph {
	struct edge {int t, v; edge *n;} me[N&lt;&lt;1|1], *ce, *g[N];
	int sz[N], fa[N], son[N], tp[N];
	long long d[N];
	Graph() {
		ce = me;
	}
	inline void adde(const int &amp;a, const int &amp;b, const int &amp;c) {
		*ce = (edge) {b, c, g[a]}; g[a] = ce++;
	}
	void d1(int u) {
		sz[u] = 1;
		for (edge *it = g[u]; it; it = it-&gt;n)
		  if (it-&gt;t ^ fa[u]) {
			  d[it-&gt;t] = d[u] + it-&gt;v;
			  fa[it-&gt;t] = u;
			  d1(it-&gt;t);
			  if (sz[son[u]] &lt; sz[it-&gt;t])
				son[u] = it-&gt;t;
			  sz[u] += sz[it-&gt;t];
		  }
	}
	void d2(int u, int anc) {
		dq[in[u] = ++dfn] = u;
		tp[u] = anc;
		if (son[u]) d2(son[u], anc);
		for (edge *it = g[u]; it; it = it-&gt;n)
		  if (!tp[it-&gt;t]) d2(it-&gt;t, it-&gt;t);
		ou[u] = dfn;
	}
	void d3(int u, int anc) {
		tp[u] = anc;
		if (son[u]) d3(son[u], anc);
		for (edge *it = g[u]; it; it = it-&gt;n)
		  if (!tp[it-&gt;t]) d3(it-&gt;t, it-&gt;t);
	}
	inline int lca(int u, int v) const {
		wlp (tp[u] ^ tp[v]) d[tp[u]] &lt; d[tp[v]] ? v = fa[tp[v]] : u = fa[tp[u]];
		return d[u] &lt; d[v] ? u : v;
	}
	inline int Gtp(int u, const int &amp;upper) const {
		static int t;
		for (; tp[u] ^ tp[upper]; u = fa[tp[u]])
		  t = tp[u];
		return (u ^ upper) ? son[upper] : t;
	}
	inline void build_segment_tree() const {
		*csegnode = (segnode) {0, csegnode, csegnode};
		rt[0] = csegnode;
		rep(i, 1, n) ins(rt[i - 1], rt[i], 1, n, dq[i]);
	}
	inline long long dist(const int &amp;u, const int &amp;v) const {
		return d[u] + d[v] - (d[lca(u, v)] &lt;&lt; 1);
	}
}G1, G2;

int main() {
	int _, c, u, v;
	long long x, y, ans;
	gi(n), gi(m), gi(_);
	rep(i, 2, n) {
		gi(u), gi(v);
		G1.adde(u, v, 1);
		G1.adde(v, u, 1);
	}
	G1.d1(1);
	G1.d2(1, 1);
	G1.build_segment_tree();
	a[1] = (node) {1, 0, 1LL, (long long)n};
	rep(i, 1, m) {
		gi(u), gi(y);
		a[i + 1] = (node) {u, 0, a[i].r + 1LL, a[i].r + G1.sz[u]};
		c = binsea(y, i);
		a[i + 1].fa = v = quy(a[c].rt, y - a[c].l + 1);
		G2.adde(c, i + 1, G1.d[v] - G1.d[a[c].rt] + 1);
	}
	G2.d1(1);
	G2.d3(1, 1);
	++m;
	wlp (_--) {
		gi(x), gi(y);
		u = binsea(x, m);
		v = binsea(y, m);
		c = G2.lca(u, v);
		x = quy(a[u].rt, x - a[u].l + 1);
		y = quy(a[v].rt, y - a[v].l + 1);
		if (u ^ v) {
			if (u == c) {
				std::swap(u, v);
				std::swap(x, y);
			}
			if (v == c) {
				v = G2.Gtp(u, c);
				ans = G1.d[x] - G1.d[a[u].rt] + G2.d[u] - G2.d[v];
				x = a[v].fa;
				ans += G1.dist((int)x, (int)y) + 1;
			} else {
				ans = G1.d[x] - G1.d[a[u].rt] + G1.d[y] - G1.d[a[v].rt] + G2.dist(u, v);
				u = G2.Gtp(u, c);
				v = G2.Gtp(v, c);
				ans -= (G1.d[G1.lca(a[u].fa, a[v].fa)] - G1.d[a[c].rt]) &lt;&lt; 1;
			}
			printf(&quot;%lld\n&quot;, ans);
		} else printf(&quot;%lld\n&quot;, G1.dist((int)x, (int)y));
	}
	return 0;
}<pre><h2>Problem4540</h2><pre>#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;ctime&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#define N 110000
#define ll long long
using namespace std;
int sc()
{
    int i=0,f=1; char c=getchar();
    while(c&gt;'9'||c&lt;'0'){if(c=='-')f=-1;c=getchar();}
    while(c&gt;='0'&amp;&amp;c&lt;='9')i=i*10+c-'0',c=getchar();
    return i*f;
}
struct W{int l,r,p;} b[N];
long long sl[N],sr[N],ans[N],now;
int bl[N],l[N],r[N],a[N],st[N][17],q[N];
int n,Q,block;
void pre()
{
    for(int i=1;i&lt;=n;i++) st[i][0]=i;
    for(int k=1;(1&lt;&lt;k)&lt;=n;k++)
        for(int i=1;i&lt;=n;i++)
            if(i+(1&lt;&lt;k)&gt;n+1)break;
            else if(a[st[i][k-1]]&lt;a[st[i+(1&lt;&lt;k-1)][k-1]]) st[i][k]=st[i][k-1];
            else st[i][k]=st[i+(1&lt;&lt;k-1)][k-1];
    int qr=0;
    for(int i=1;i&lt;=n;i++)
    {
        while(qr&amp;&amp;a[q[qr]]&gt;=a[i])qr--;
        l[i]=q[qr]; q[++qr]=i;
        sl[i]=sl[l[i]]+1ll*a[i]*(i-l[i]);
    }
    q[qr=0]=n+1;
    for(int i=n;i&gt;=1;i--)
    {
        while(qr&amp;&amp;a[q[qr]]&gt;a[i])qr--;
        r[i]=q[qr]; q[++qr]=i;
        sr[i]=sr[r[i]]+1ll*a[i]*(r[i]-i);
    }
}
bool cmp(W a,W b)
{
    return bl[a.l]&lt;bl[b.l]||(bl[a.l]==bl[b.l]&amp;&amp;a.r&lt;b.r);
}
int get_min(int l,int r)
{
    int k=log2(r-l+1);
    int L=st[l][k],R=st[r-(1&lt;&lt;k)+1][k];
    return a[L]&lt;a[R]?L:R;
}
long long call(int l,int r)
{
    int p=get_min(l,r);
    return 1ll*(r-p+1)*a[p]+sr[l]-sr[p];
}
long long calr(int l,int r)
{
    int p=get_min(l,r);
    return 1ll*(p-l+1)*a[p]+sl[r]-sl[p];
}
int main()
{
    n=sc(),Q=sc();block=sqrt(n);
    for(int i=1;i&lt;=n;i++)
        a[i]=sc(),bl[i]=(i-1)/block;
    pre();
    for(int i=1;i&lt;=Q;i++)
        b[i].l=sc(),b[i].r=sc(),b[i].p=i;
    sort(b+1,b+Q+1,cmp);
    int L=1,R=0;
    for(int i=1;i&lt;=Q;i++)
    {
        while(L&gt;b[i].l)now+=call(L-1,R),L--;
        while(R&lt;b[i].r)now+=calr(L,R+1),R++;
        while(L&lt;b[i].l)now-=call(L,R),L++;
        while(R&gt;b[i].r)now-=calr(L,R),R--;
        ans[b[i].p]=now;
    }
    for(int i=1;i&lt;=Q;i++)
        printf(&quot;%lld\n&quot;,ans[i]);
    return 0;
}<pre><h2>Problem4540</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (int i = l, _R = (r); i &lt;= _R; ++i)
typedef int arr[N];
typedef long long arr64[N];
arr a, bel, ST[19], stk, lg;
arr64 SL, SR, Ans;
inline int Min(const int &amp;i, const int &amp;j) {
	return a[i] &lt; a[j] ? i : j;
}
struct Q {
	int l, r, id;
}q[N];
bool operator &lt; (const Q &amp;a, const Q &amp;b) {
	return (bel[a.l] ^ bel[b.l]) ? bel[a.l] &lt; bel[b.l] : bel[a.r] &lt; bel[b.r];
}
inline void Init(const int &amp;n) {
	*lg = -1;
	rep(i, 1, n) {
		ST[0][i] = i;
		lg[i] = lg[i &gt;&gt; 1] + 1;
	}
	rep(i, 1, lg[n])
		rep(j, 1, n - (1 &lt;&lt; i) + 1)
		ST[i][j] = Min(ST[i - 1][j], ST[i - 1][j + (1 &lt;&lt; i - 1)]);
	int *tp = stk;
	*tp = 0;
	rep(i, 1, n) {
		wlp (stk &lt; tp &amp;&amp; a[*tp] &gt;= a[i]) --tp;
		SL[i] = SL[*tp] + (long long)a[i] * (i - *tp);
		*++tp = i;
	}
	*(tp = stk) = n + 1;
	for (int i = n; i; --i) {
		wlp (stk &lt; tp &amp;&amp; a[*tp] &gt;= a[i]) --tp;
		SR[i] = SR[*tp] + (long long)a[i] * (*tp - i);
		*++tp = i;
	}
}

inline int gmin(const int &amp;l, const int &amp;r) {
	static int t;
	t = lg[r - l + 1];
	return Min(ST[t][l], ST[t][r - (1 &lt;&lt; t) + 1]);
}

inline long long cl(int l, int r) {
	static int t;
	t = gmin(l, r);
	return (r - t + 1LL) * (long long)a[t] + SR[l] - SR[t];
}

inline long long cr(int l, int r) {
	static int t;
	t = gmin(l, r);
	return (t - l + 1LL) * (long long)a[t] + SL[r] - SL[t];
}

int main() {
	int n, m, rm;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (rm = 1; rm * rm &lt;= n; ++rm);
	rep(i, 1, n) {
		bel[i] = (i - 1) / rm;
		scanf(&quot;%d&quot;, a + i);
	}
	Init(n);

	rep(i, 1, m) {
		scanf(&quot;%d%d&quot;, &amp;q[i].l, &amp;q[i].r);
		q[i].id = i;
	}

	std::sort(q + 1, q + m + 1);

	int l = 1, r = 0, _l, _r;
	long long ct = 0;
	rep(i, 1, m) {
		_l = q[i].l, _r = q[i].r;
		wlp (_l &lt; l) ct += cl(--l, r);
		wlp (r &lt; _r) ct += cr(l, ++r);
		wlp (l &lt; _l) ct -= cl(l++, r);
		wlp (_r &lt; r) ct -= cr(l, r--);
		Ans[q[i].id] = ct;
	}
	rep(i, 1, m)
		printf(&quot;%lld\n&quot;, Ans[i]);

	return 0;
}<pre><h2>Problem4540</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (register int i = l, _R = (r); i &lt;= _R; ++i)
typedef int arr[N];
typedef long long arr64[N];
arr a, bel, ST[19], stk, lg;
arr64 SL, SR, Ans;
#define getc() ((ins==ine&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline void geti(int &amp;ina) {
	static char inc,inb[1&lt;&lt;16], *ins=inb, *ine=inb, insign;
	for(insign = 0; (inc = getc()) &lt; '0'; insign |= inc == '-');
	for(ina = inc-'0'; '-' &lt; (inc=getc()); ina = (ina &lt;&lt; 3) + (ina&lt;&lt;1) + inc - '0');
	if (insign) ina = -ina;
}
inline int Min(const int &amp;i, const int &amp;j) {
	return a[i] &lt; a[j] ? i : j;
}
struct Q {
	int l, r, id;
	void Input(int i) {
		geti(l), geti(r);
		id = i;
	}
}q[N];
bool operator &lt; (const Q &amp;a, const Q &amp;b) {
	return (bel[a.l] ^ bel[b.l]) ? bel[a.l] &lt; bel[b.l] : bel[a.r] &lt; bel[b.r];
}
inline void Init(const int &amp;n) {
	*lg = -1;
	rep(i, 1, n) {
		ST[0][i] = i;
		lg[i] = lg[i &gt;&gt; 1] + 1;
	}
	rep(i, 1, lg[n])
		rep(j, 1, n - (1 &lt;&lt; i) + 1)
		ST[i][j] = Min(ST[i - 1][j], ST[i - 1][j + (1 &lt;&lt; i - 1)]);
	int *tp = stk;
	*tp = 0;
	rep(i, 1, n) {
		wlp (stk &lt; tp &amp;&amp; a[*tp] &gt;= a[i]) --tp;
		SL[i] = SL[*tp] + (long long)a[i] * (i - *tp);
		*++tp = i;
	}
	*(tp = stk) = n + 1;
	for (register int i = n; i; --i) {
		wlp (stk &lt; tp &amp;&amp; a[*tp] &gt;= a[i]) --tp;
		SR[i] = SR[*tp] + (long long)a[i] * (*tp - i);
		*++tp = i;
	}
}

inline int gmin(const int &amp;l, const int &amp;r) {
	static int t;
	t = lg[r - l + 1];
	return Min(ST[t][l], ST[t][r - (1 &lt;&lt; t) + 1]);
}

inline long long cl(int l, int r) {
	static int t;
	t = gmin(l, r);
	return (r - t + 1) * (long long)a[t] + SR[l] - SR[t];
}

inline long long cr(int l, int r) {
	static int t;
	t = gmin(l, r);
	return (t - l + 1) * (long long)a[t] + SL[r] - SL[t];
}

int main() {
	int n, m, rm;
	geti(n), geti(m);
	for (rm = 1; rm * rm &lt;= n; ++rm);
	rep(i, 1, n) {
		bel[i] = (i - 1) / rm;
		geti(a[i]);
	}
	Init(n);

	rep(i, 1, m) q[i].Input(i);

	std::sort(q + 1, q + m + 1);

	int l = 1, r = 0, _l, _r;
	long long ct = 0;
	rep(i, 1, m) {
		_l = q[i].l, _r = q[i].r;
		wlp (_l &lt; l) ct += cl(--l, r);
		wlp (r &lt; _r) ct += cr(l, ++r);
		wlp (l &lt; _l) ct -= cl(l++, r);
		wlp (_r &lt; r) ct -= cr(l, r--);
		Ans[q[i].id] = ct;
	}
	rep(i, 1, m)
		printf(&quot;%lld\n&quot;, Ans[i]);

	return 0;
}<pre><h2>Problem4542</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)
#define rrp(i, l, r) for (register int i = l; i &gt;= r; --i)
typedef int arr[N];
typedef long long arr64[N];
arr cnt;
arr64 sum, ha, a, ans;
char s[N];
struct Q {
	int l, r, id, _l, _r;
} q[N];
bool operator &lt; (const Q &amp;a, const Q &amp;b) {
	return (a._l ^ b._l) ? a._l &lt; b._l : a._r &lt; b._r;
}
int main() {
	long long p, ct, *end;
	int n, m, rn;
	scanf(&quot;%lld%s%d&quot;, &amp;p, s + 1, &amp;m);
	n = strlen(s + 1);
	if (!(p ^ 2) || !(p ^ 5)) {
		unsigned int _p = p, l, r;
		rep(i, 1, n) {
			cnt[i] = cnt[i - 1];
			sum[i] = sum[i - 1];
			if ((s[i] - '0') % _p == 0) {
				++cnt[i];
				sum[i] += i;
			}
		}
		wlp (m--) {
			scanf(&quot;%u%u&quot;, &amp;l, &amp;r);
			printf(&quot;%lld\n&quot;, sum[r] - sum[l - 1] - (cnt[r] - cnt[l - 1]) * (l - 1LL));
		}
		return 0;
	}
	for (rn = 1; rn * rn &lt;= n; ++rn);
	int l, r, _l, _r;
	rep(i, 1, m) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		++r;
		_l = l / rn, _r = r / rn;
		q[i] = (Q) {l, r, i, _l, _r};
	}
	std::sort(q + 1, q + m + 1);
	ct = 1;
	rrp(i, n, 1) {
		ha[i] = a[i] = (a[i + 1] + ct * (s[i] - '0')) % p;
		for (ct = (ct &lt;&lt; 3) + (ct &lt;&lt; 1); ct &gt;= p; ct -= p);
	}
	ha[++n] = 0;
	std::sort(ha + 1, ha + n + 1);
	end = std::unique(ha + 1, ha + n + 1);
	rep(i, 1, n) a[i] = std::lower_bound(ha + 1, end, a[i]) - ha;
	l = 1, r = 0;
	ct = 0;
	rep(i, 1, m) {
		_l = q[i].l, _r = q[i].r;
		wlp (_l &lt; l) ct += cnt[a[--l]]++;
		wlp (r &lt; _r) ct += cnt[a[++r]]++;
		wlp (l &lt; _l) ct -= --cnt[a[l++]];
		wlp (_r &lt; r) ct -= --cnt[a[r--]];
		ans[q[i].id] = ct;
	}
	rep(i, 1, m)
		printf(&quot;%lld\n&quot;, ans[i]);
	return 0;
}<pre><h2>Problem4542</h2><pre>#include &lt;bits/stdc++.h&gt;
#define N 100003
#define wlp while
#define rep(i, l, r) for (register int i = l; i &lt;= r; ++i)
#define rrp(i, l, r) for (register int i = l; i &gt;= r; --i)
typedef int arr[N];
typedef long long arr64[N];
arr cnt;
arr sum, ha, a;
arr64 ans;
char s[N];
struct Q {
	int l, r, id, _l, _r;
} q[N];
bool operator &lt; (const Q &amp;a, const Q &amp;b) {
	return (a._l ^ b._l) ? a._l &lt; b._l : a._r &lt; b._r;
}
int main() {
	long long ct;
	int *end, p;
	int n, m, rn;
	scanf(&quot;%d%s%d&quot;, &amp;p, s + 1, &amp;m);
	n = strlen(s + 1);
	if (!(p ^ 2) || !(p ^ 5)) {
		unsigned int _p = p, l, r;
		rep(i, 1, n) {
			cnt[i] = cnt[i - 1];
			sum[i] = sum[i - 1];
			if ((s[i] - '0') % _p == 0) {
				++cnt[i];
				sum[i] += i;
			}
		}
		wlp (m--) {
			scanf(&quot;%u%u&quot;, &amp;l, &amp;r);
			printf(&quot;%lld\n&quot;, sum[r] - sum[l - 1] - (cnt[r] - cnt[l - 1]) * (l - 1LL));
		}
		return 0;
	}
	for (rn = 1; rn * rn &lt;= n; ++rn);
	int l, r, _l, _r;
	rep(i, 1, m) {
		scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
		++r;
		_l = l / rn, _r = r / rn;
		q[i] = (Q) {l, r, i, _l, _r};
	}
	std::sort(q + 1, q + m + 1);
	ct = 1;
	rrp(i, n, 1) {
		ha[i] = a[i] = (a[i + 1] + ct * (s[i] - '0')) % p;
		for (ct = (ct &lt;&lt; 3) + (ct &lt;&lt; 1); ct &gt;= p; ct -= p);
	}
	ha[++n] = 0;
	std::sort(ha + 1, ha + n + 1);
	end = std::unique(ha + 1, ha + n + 1);
	rep(i, 1, n) a[i] = std::lower_bound(ha + 1, end, a[i]) - ha;
	l = 1, r = 0;
	ct = 0;
	rep(i, 1, m) {
		_l = q[i].l, _r = q[i].r;
		wlp (_l &lt; l) ct += cnt[a[--l]]++;
		wlp (r &lt; _r) ct += cnt[a[++r]]++;
		wlp (l &lt; _l) ct -= --cnt[a[l++]];
		wlp (_r &lt; r) ct -= --cnt[a[r--]];
		ans[q[i].id] = ct;
	}
	rep(i, 1, m)
		printf(&quot;%lld\n&quot;, ans[i]);
	return 0;
}<pre><h2>Problem4543</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxn(1e5 + 7);

struct edge {
	int to;
	edge *nxt;
}edge_mset[maxn &lt;&lt; 1], *graph[maxn], *cedge = edge_mset;

inline void add_edge(int u, int v) {
	*cedge = (edge) {v, graph[u]};
	graph[u] = cedge++;
}

int dep[maxn], longest[maxn];
long long *g[maxn], *f[maxn];
long long mset[maxn * 5], *end(mset + 1), ans;

void d1(int u, int from) {
	longest[u] = u;
	for (edge *it = graph[u]; it; it = it-&gt;nxt)
		if (it-&gt;to ^ from) {
			dep[it-&gt;to] = dep[u] + 1;
			d1(it-&gt;to, u);
			if (dep[longest[it-&gt;to]] &gt; dep[longest[u]])
				longest[u] = longest[it-&gt;to];
		}
	for (edge *it = graph[u]; it; it = it-&gt;nxt)
		if ((it-&gt;to ^ from) &amp;&amp; ((longest[it-&gt;to] ^ longest[u]) || (u == 1))) {
			int v = longest[it-&gt;to];
			end += dep[v] - dep[u] + 1;
			f[v] = end;
			g[v] = ++end;
			end += (dep[v] - dep[u]) * 2 + 1;
		}
}

void d2(int u, int from) {
	int v;
	for (edge *it = graph[u]; it; it = it-&gt;nxt)
		if ((v = it-&gt;to) ^ from) {
			d2(v, u);
			if (longest[u] == longest[v])
				f[u] = f[v] - 1, g[u] = g[v] + 1;
		}
	ans += g[u][0];
	f[u][0] = 1;
	for (edge *it = graph[u]; it; it = it-&gt;nxt)
		if (((v = it-&gt;to) ^ from) &amp;&amp; (longest[u] ^ longest[v])) {
			for (register int i = 0; i &lt; dep[longest[v]] - dep[u] + 1; ++i)
				ans += f[u][i - 1] * g[v][i] + f[v][i] * g[u][i + 1];
			for (register int i = 0; i &lt; dep[longest[v]] - dep[u] + 1; ++i) {
				g[u][i - 1] += g[v][i];
				g[u][i + 1] += f[u][i + 1] * f[v][i];
				f[u][i + 1] += f[v][i];
			}
		}
}

int main() {
	int n, u, v;
	scanf(&quot;%d&quot;, &amp;n);
	for (register int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		add_edge(u, v);
		add_edge(v, u);
	}
	d1(1, 0);
	d2(1, 0);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4547</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int mod(10000007);

struct Matrix {
    int n, m, a[3][3];
} A, B;

Matrix operator * (const Matrix &amp;a, const Matrix &amp;b) {
    static Matrix c;
    c.n = a.n, c.m = b.m;
    memset(c.a, 0, sizeof c.a);
    for (register int k = 0; k &lt; a.m; ++k)
        for (register int i = 0; i &lt; a.n; ++i)
            for (register int j = 0; j &lt; b.m; ++j)
                c.a[i][j] = (c.a[i][j] + (long long)a.a[i][k] * b.a[k][j]) % mod;
    return c;
}

int main() {
    int n, k, x;
    A.n = 1, A.m = 3;
    A.a[0][0] = A.a[0][1] = -1000000000;

    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for (register int i = 0; i &lt; n; ++i) {
        scanf(&quot;%d&quot;, &amp;x);
        A.a[0][2] = (A.a[0][2] + x) % mod;
        if (x &gt;= A.a[0][1]) {
            A.a[0][0] = A.a[0][1];
            A.a[0][1] = x;
        } else if (x &gt; A.a[0][0])
            A.a[0][0] = x;
    }

    while (A.a[0][0] &lt; 0 &amp;&amp; k) {
        --k;
        x = A.a[0][0] + A.a[0][1];
        A.a[0][2] = (A.a[0][2] + x) % mod;
        A.a[0][0] = x;
    }
    B.n = B.m = 3;
    B.a[1][0] = 1;
    B.a[0][1] = B.a[1][1] = 1;
    B.a[0][2] = B.a[1][2] = B.a[2][2] = 1;
    for (; k; (k &gt;&gt;= 1) ? (B = B * B, 1) : 0)
        if (k &amp; 1) A = A * B;
    A.a[0][2] += mod;
    printf(&quot;%d&quot;, A.a[0][2] % mod);
    return 0;
}<pre><h2>Problem4551</h2><pre>#include &lt;cstdio&gt;

const int BUF = 1&lt;&lt;16|127;
inline char gc() {
    static char b[BUF], *s = b, *e = b;
    if (s == e) e = (s = b) + fread(b, 1, BUF, stdin);
    return (s == e) ? EOF : *s++;
}
 
inline void gi(int &amp;a) {
    static char c;
    while (c = gc(), c &lt; '0'); a = c - '0';
    while (c = gc(), '-' &lt; c) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0';
}

typedef int _[100003];

_ f, fa, mark, X, opt, ans;

inline int gf(int u) {
	static int r, t;
	for (r = u; f[r] ^ r; r = f[r]);
	while (u ^ r) t = f[u], f[u] = r, u = t;
	return r;
}

int main() {
	char c;
	int n, q, u, v;
	gi(n), gi(q);
	for (register int i = 1; i &lt; n; ++i) {
		gi(u), gi(v);
		fa[v] = u;
	}
	mark[1] = 1;
	for (register int i = 0; i &lt; q; ++i) {
		do c = gc(); while ((c ^ 'Q') &amp;&amp; (c ^ 'C'));
		gi(X[i]);
		if (c ^ 'Q') ++mark[X[i]], opt[i] = 1;
	}
	for (register int i = 1; i &lt;= n; ++i)
		f[i] = mark[i] ? i : fa[i];
	for (register int i = q - 1; ~i; --i)
		if (opt[i]) {
			if (!--mark[X[i]]) f[X[i]] = fa[X[i]];
		} else ans[i] = gf(X[i]);
	for (register int i = 0; i &lt; q; ++i)
		if (!opt[i]) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}<pre><h2>Problem4552</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 1e5 + 13;
typedef int arr[MaxN];

arr a, b, opt, L, R;

#define ls u &lt;&lt; 1
#define rs u &lt;&lt; 1 | 1
#define Range const int &amp;x, const int &amp;y
#define VarMid int mid = (C[u].l + C[u].r) &gt;&gt; 1

struct node {
	int l, r, len, sum, lazy;
	bool inrange(Range);
} C[MaxN &lt;&lt; 2];

bool node :: inrange(Range) {
	return x &lt;= l &amp;&amp; r &lt;= y;
}

inline void pd(const int &amp;u)  {
	if (~C[u].lazy) {
		C[ls].sum = C[u].lazy ? C[ls].len : 0;
		C[rs].sum = C[u].lazy ? C[rs].len : 0;
		C[ls].lazy = C[rs].lazy = C[u].lazy;
		C[u].lazy = -1;
	}
}

inline void pu(const int &amp;u) {
	C[u].sum = C[ls].sum + C[rs].sum;
}

void build(int u, int l, int r) {
	C[u] = (node) {l, r, r - l + 1, 0, -1};
	if (l ^ r) {
		int mid = (l + r) &gt;&gt; 1;
		build(ls, l, mid);
		build(rs, mid + 1, r);
	}
}

void rebuild(int u) {
	C[u].lazy = -1;
	if (C[u].l ^ C[u].r) {
		rebuild(ls);
		rebuild(rs);
		pu(u);
	} else C[u].sum = b[C[u].l];
}

void modify(int u, Range, const int &amp;v) {
	if (C[u].inrange(x, y))
		return (void)(C[u].lazy = v, C[u].sum = v ? C[u].len : 0);
	VarMid; pd(u);
	if (x &lt;= mid) modify(ls, x, y, v);
	if (y &gt;  mid) modify(rs, x, y, v);
	pu(u);
}

int query(int u, Range) {
	if (C[u].inrange(x, y))
		return C[u].sum;
	VarMid, ret = 0; pd(u);
	if (x &lt;= mid) ret = query(ls, x, y);
	if (y &gt; mid) ret += query(rs, x, y);
	return ret;
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, m, i, l, r, mid, t, q;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i);
	build(1, 1, n);
	for (i = 0; i &lt; m; ++i) scanf(&quot;%d%d%d&quot;, opt + i, L + i, R + i);
	scanf(&quot;%d&quot;, &amp;q);
	for (l = 1, r = n; l &lt;= r; ) {
		mid = (l + r) &gt;&gt; 1;
		for (i = 1; i &lt;= n; ++i) b[i] = (a[i] &gt;= mid);
		rebuild(1);
		for (i = 0; i &lt; m; ++i) {
			t = query(1, L[i], R[i]);
			if (t)
				opt[i] ? modify(1, L[i], L[i] + t - 1, 1) : modify(1, R[i] - t + 1, R[i], 1);
			if (R[i] - L[i] + 1 - t)
				opt[i] ? modify(1, L[i] + t, R[i], 0) : modify(1, L[i], R[i] - t, 0);
			//printf(&quot;%d &quot;, t);
		}
		//printf(&quot;%d %d\n&quot;,mid, query(1, q, q));
		if (query(1, q, q)) l = mid + 1;
		else r = mid - 1;
	}
	printf(&quot;%d\n&quot;, l - 1);
	return 0;
}<pre><h2>Problem4555</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MaxN = 4e5 + 5;
const int mod = 7 * 17 * (1 &lt;&lt; 23) + 1, e = 3;
typedef int arr[MaxN];
inline int pw(int a, int b) {
	static int r;
	for (r = 1; b; (b &gt;&gt;= 1) ? a = (long long)a * a % mod : 0)
	  if (b &amp; 1) r = (long long)r * a % mod;
	return r;
}

arr a, b, rev, fac, inv, f;
#define rep(i, l, r) for (int i = l; i &lt; r; ++i)
#define Rep(i, l, r) for (int i = l; i &lt;= r; ++i)

inline void ntt(int *a, int n, int flg) {
	rep(i, 0, n) if (i &lt; rev[i]) swap(a[i], a[rev[i]]);
	for (int m = 2; m &lt;= n; m &lt;&lt;= 1) {
		int mid = m &gt;&gt; 1, wn = pw(e, ((mod - 1) / m * flg + mod - 1) % (mod - 1));
		for (int i = 0; i &lt; n; i += m) {
			int w = 1, t1, t2;
			rep(j, 0, mid) {
				t1 = a[i + j], t2 = (long long)a[i + j + mid] * w % mod;
				for (a[i + j] = t1 + t2; a[i + j] &gt;= mod; a[i + j] -= mod);
				for (a[i + j + mid] = t1 - t2 + mod; a[i + j + mid] &gt;= mod; a[i + j + mid] -= mod);
				w = (long long)w * wn % mod;
				//printf(&quot;%d &quot;, w);
			}	
			//puts(&quot;&quot;);
		}
	}
	if (flg &lt; 0) {
		int inv = pw(n, mod - 2);
		rep(i, 0, n) {
			a[i] = (long long)a[i] * inv % mod;
			//printf(&quot;%d\n&quot;, a[i]);
		}
	}
}

void solve(int l, int r) {
	if (l &gt;= r) return;
	int mid = (l + r) &gt;&gt; 1;
	solve(l, mid);
	int n = mid - l + r - l, len = 1;
	while ((1 &lt;&lt; len) &lt; n) ++len;
	n = 1 &lt;&lt; len;
	rep(i, 0, n) a[i] = b[i] = 0;
	Rep(i, l, mid) a[i - l] = f[i];
	Rep(i, 1, r - l) b[i - 1] = 2LL * inv[i] % mod;
	rep(i, 1, n) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (len - 1));
	ntt(a, n, 1); ntt(b, n, 1);
	rep(i, 0, n) {
		a[i] = (long long)a[i] * b[i] % mod;
		//printf(&quot;%d &quot;, a[i]);
	}
	//puts(&quot;&quot;);
	ntt(a, n, -1);
	Rep(i, mid + 1, r) {
		//printf(&quot;%d %d\n&quot;, i, f[i]);
		for (f[i] += a[i - l - 1]; f[i] &gt;= mod; f[i] -= mod);
		//printf(&quot;%d %d\n&quot;, i, f[i]);
	}
	solve(mid + 1, r);
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, ans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	fac[0] = inv[0] = 1;
	Rep(i, 1, n) {
		fac[i] = (long long)fac[i - 1] * i % mod;
		//	printf(&quot;%d &quot;, fac[i]);
	}
	//puts(&quot;&quot;);
	inv[n] = pw(fac[n], mod - 2);
	for (int i = n - 1; i; --i) inv[i] = (long long)inv[i + 1] * (i + 1) % mod;
	//Rep(i, 1, n) printf(&quot;%d &quot;, inv[i]);
	//puts(&quot;&quot;);
	f[0] = 1;
	solve(0, n);
	Rep(i, 0, n) {
		ans = (ans + (long long)f[i] * fac[i]) % mod;
		//printf(&quot;%d &quot;, f[i]);
	}
	//puts(&quot;&quot;);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4555</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MaxN = 4e5 + 5;
const int mod = 7 * 17 * (1 &lt;&lt; 23) + 1, e = 3;
typedef int arr[MaxN];
inline int pw(int a, int b) {
	static int r;
	for (r = 1; b; (b &gt;&gt;= 1) ? a = 1LL*a * a % mod : 0)
	  if (b &amp; 1) r = 1LL*r * a % mod;
	return r;
}

arr a, b, rev, fac, inv, f;
#define rep(i, l, r) for (int i = l; i &lt; r; ++i)
#define Rep(i, l, r) for (int i = l; i &lt;= r; ++i)

inline void ntt(int *a, int n, int flg) {
	rep(i, 0, n) if (i &lt; rev[i]) swap(a[i], a[rev[i]]);
	for (int m = 2; m &lt;= n; m &lt;&lt;= 1) {
		int mid = m &gt;&gt; 1, wn = pw(e, ((mod - 1) / m * flg + mod - 1) % (mod - 1));
		for (int i = 0; i &lt; n; i += m) {
			int w = 1, t1, t2;
			rep(j, 0, mid) {
				t1 = a[i + j], t2 = 1LL*a[i + j + mid] * w % mod;
				for (a[i + j] = t1 + t2; a[i + j] &gt;= mod; a[i + j] -= mod);
				for (a[i + j + mid] = t1 - t2 + mod; a[i + j + mid] &gt;= mod; a[i + j + mid] -= mod);
				w = 1LL*w * wn % mod;
				//printf(&quot;%d &quot;, w);
			}	
			//puts(&quot;&quot;);
		}
	}
	if (flg &lt; 0) {
		int inv = pw(n, mod - 2);
		rep(i, 0, n) {
			a[i] = 1LL*a[i] * inv % mod;
			//printf(&quot;%d\n&quot;, a[i]);
		}
	}
}

void solve(int l, int r) {
	if (l &gt;= r) return;
	int mid = (l + r) &gt;&gt; 1;
	solve(l, mid);
	int n = mid - l + r - l, len = 1;
	while ((1 &lt;&lt; len) &lt; n) ++len;
	n = 1 &lt;&lt; len;
	rep(i, 0, n) a[i] = b[i] = 0;
	Rep(i, l, mid) a[i - l] = f[i];
	Rep(i, 1, r - l) b[i - 1] = 2LL * inv[i] % mod;
	rep(i, 1, n) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (len - 1));
	ntt(a, n, 1); ntt(b, n, 1);
	rep(i, 0, n) {
		a[i] = 1LL*a[i] * b[i] % mod;
		//printf(&quot;%d &quot;, a[i]);
	}
	//puts(&quot;&quot;);
	ntt(a, n, -1);
	Rep(i, mid + 1, r) {
		//printf(&quot;%d %d\n&quot;, i, f[i]);
		for (f[i] += a[i - l - 1]; f[i] &gt;= mod; f[i] -= mod);
		//printf(&quot;%d %d\n&quot;, i, f[i]);
	}
	solve(mid + 1, r);
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, ans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	fac[0] = inv[0] = 1;
	Rep(i, 1, n) {
		fac[i] = 1LL*fac[i - 1] * i % mod;
		//	printf(&quot;%d &quot;, fac[i]);
	}
	//puts(&quot;&quot;);
	inv[n] = pw(fac[n], mod - 2);
	for (int i = n - 1; i; --i) inv[i] = 1LL*inv[i + 1] * (i + 1) % mod;
	//Rep(i, 1, n) printf(&quot;%d &quot;, inv[i]);
	//puts(&quot;&quot;);
	f[0] = 1;
	solve(0, n);
	Rep(i, 0, n) {
		ans = (ans + 1LL*f[i] * fac[i]) % mod;
		//printf(&quot;%d &quot;, f[i]);
	}
	//puts(&quot;&quot;);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4555</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MaxN = 3e5 + 5;
const int mod = 7 * 17 * (1 &lt;&lt; 23) + 1, e = 3;
typedef int arr[MaxN];
inline int pw(int a, int b) {
	static int r;
	for (r = 1; b; (b &gt;&gt;= 1) ? a = 1LL * a * a % mod : 0)
	  if (b &amp; 1) r = 1LL * r * a % mod;
	return r;
}

arr a, b, rev, fac, inv;
#define rep(i, l, r) for (int i = l; i &lt; r; ++i)
#define Rep(i, l, r) for (int i = l; i &lt;= r; ++i)

inline void ntt(int *a, int n, int flg) {
	rep(i, 0, n) if (i &lt; rev[i]) swap(a[i], a[rev[i]]);
	for (int m = 2; m &lt;= n; m &lt;&lt;= 1) {
		int mid = m &gt;&gt; 1, wn = pw(e, ((mod - 1) / m * flg + mod - 1) % (mod - 1));
		for (int i = 0; i &lt; n; i += m) {
			int w = 1, t1, t2;
			rep(j, 0, mid) {
				t1 = a[i + j], t2 = 1LL * a[i + j + mid] * w % mod;
				for (a[i + j] = t1 + t2; a[i + j] &gt;= mod; a[i + j] -= mod);
				for (a[i + j + mid] = t1 - t2 + mod; a[i + j + mid] &gt;= mod; a[i + j + mid] -= mod);
				w = 1LL * w * wn % mod;
				//printf(&quot;%d &quot;, w);
			}	
			//puts(&quot;&quot;);
		}
	}
	if (flg &lt; 0) {
		int inv = pw(n, mod - 2);
		rep(i, 0, n) {
			a[i] = 1LL * a[i] * inv % mod;
			//printf(&quot;%d\n&quot;, a[i]);
		}
	}
}

int main() {
	int n, len = 1, m, ans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	fac[0] = inv[0] = 1;
	Rep(i, 1, n) fac[i] = (long long)fac[i - 1] * i % mod;
	inv[n] = pw(fac[n], mod - 2);
	for (int i = n - 1; i; --i) inv[i] = (long long)inv[i + 1] * (i + 1) % mod;
	Rep(i, 0, n) {
		if (i &amp; 1) a[i] = mod - inv[i];
		else a[i] = inv[i];
		if (i ^ 1) b[i] = (pw(i, n + 1) - 1LL + mod) * (long long)pw(i - 1 + mod, mod - 2) % mod * inv[i] % mod;
		else b[i] = n + 1;
	}
	m = n &lt;&lt; 1;
	while ((1 &lt;&lt; len) &lt;= m) ++len;
	n = 1 &lt;&lt; len;
	rep(i, 0, n) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (len - 1));
	ntt(a, n, 1);
	ntt(b, n, 1);
	rep(i, 0, n) a[i] = (long long)a[i] * b[i] % mod;
	ntt(a, n, -1);
	m &gt;&gt;= 1;
	n = 1;
	Rep(i, 0, m) {
		ans = (ans + (long long)n * fac[i] % mod * a[i]) % mod;
		n &lt;&lt;= 1;
		if (n &gt;= mod) n -= mod;
		//printf(&quot;%d\n&quot;, ans);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4557</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define N 500005
#define inf 0x3f3f3f3f
char getc(){
    static char *S,*T,buf[65536];
    if(S==T){T=(S=buf)+fread(buf,1,65536,stdin);if(S==T) return EOF;}
    return *S++;
}
int read(){
    static char ch;static int D;
    while(!isdigit(ch=getc()));
    for(D=ch-'0';isdigit(ch=getc());) D=D*10+ch-'0';
    return D;
}
int n,m,d;
int g[N][22],f[N][22],w[N];
bool vis[N];
struct edge
{
    int to,next;
}e[N&lt;&lt;1];
int h[N],tp;
void ae(int u,int v)
{
    e[++tp].to=v;
    e[tp].next=h[u];
    h[u]=tp;
}
void dfs(int u,int fa)
{
    for(int i=h[u];i;i=e[i].next)
    if(e[i].to!=fa) dfs(e[i].to,u);
    for(int k=1;k&lt;=d+1;k++)
    {
        if(u==1&amp;&amp;k==d+1)
        {
            int fasd=1;
        }
        int tmp=0,mn=inf;bool flag=0;
        for(int v,i=h[u];i;i=e[i].next)
        if((v=e[i].to)!=fa) 
        {
            tmp+=min(k?g[v][k-1]:inf,f[v][min(d+1,k+1)]);
            if(g[v][k-1]&lt;f[v][min(d+1,k+1)]) flag=1;
            if(k&amp;&amp;g[v][k-1]&gt;=f[v][min(d+1,k+1)]) mn=min(mn,g[v][k-1]-f[v][min(d+1,k+1)]);
        }
        f[u][k]=tmp;g[u][k]=tmp;
        if(!flag) g[u][k]+=mn;
        tmp=0;
        if(k==d+1&amp;&amp;!vis[u])
        {
            for(int v,i=h[u];i;i=e[i].next)
            if((v=e[i].to)!=fa) 
            {
                tmp+=g[v][k];
                tmp=min(tmp,inf);
            }
            f[u][k]=min(f[u][k],tmp);
            g[u][k]=min(g[u][k],tmp);
        }
    }
    f[u][0]=g[u][0]=w[u];
    for(int v,i=h[u];i;i=e[i].next)
    if((v=e[i].to)!=fa) 
    {
        f[u][0]+=min(min(g[v][d],g[v][d+1]),f[v][1]);
        g[u][0]+=min(min(g[v][d],g[v][d+1]),f[v][1]);
    }
    for(int k=1;k&lt;=d+1;k++) g[u][k]=min(g[u][k],g[u][k-1]);
    if(vis[u]) f[u][d+1]=g[u][d];
    else f[u][0]=min(f[u][0],g[u][d+1]);
    for(int k=d;k;k--) 
    {
        f[u][k]=min(f[u][k],min(f[u][k+1],f[u][0]));
        f[u][k]=min(f[u][k],min(g[u][d],g[u][d+1]));
    }
    if(vis[u]) g[u][d+1]=inf; 
}
int main()
{
    n=read();d=read();
    for(int i=1;i&lt;=n;i++) w[i]=read();
    m=read();for(int i=1;i&lt;=m;i++) vis[read()]=1;
    for(int u,v,i=1;i&lt;n;i++)
    {
        u=read();v=read();
        ae(u,v);ae(v,u);
    }
    memset(g,0x3f,sizeof(g));
    dfs(1,0);
    int ans=inf;
    for(int i=0;i&lt;=d+1;i++) ans=min(ans,g[1][i]);
    printf(&quot;%d\n&quot;,ans);
}<pre><h2>Problem4557</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int MaxN = 500003, MaxD = 22, BUF = 1 &lt;&lt; 16 | (127);

//Fast Input
inline char gc() {
	static char b[BUF], *s = b, *e = b;
	if (s == e) {
		e = (s = b) + fread(b, 1, BUF, stdin);
		if (s == e) return EOF;
	}
	return *s++;
}
inline void gi(int &amp;a) {
	static char c;
	do c = gc(); while (c &lt; '0');
	for (a = c - 48; 47 &lt; (c = gc()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48);
}

struct edge {
	int to;
	edge *nxt;
} edge_mset[MaxN &lt;&lt; 1], *cedge = edge_mset, *G[MaxN];
#define overedge edge *it = G[u]; it; it = it-&gt;nxt
inline void add_edge(int a, int b) {
	*cedge = (edge) {b, G[a]};
	G[a] = cedge++;
}

bool vis[MaxN];
int n, m, d, f[MaxN][MaxD], g[MaxN][MaxD], w[MaxN];
#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)

inline void cmin(int &amp;a, const int &amp;b) {
	if (b &lt; a) a = b;
}

inline int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}

void dfs(int u, int fa) {
	for (overedge)
	  if (it-&gt;to ^ fa) dfs(it-&gt;to, u);
	bool flag;
	int tmp, mi, v;
	rep(k, 1, d + 1) {
		flag = true;
		tmp = 0, mi = 0x3f3f3f3f;
		for (overedge) if (it-&gt;to ^ fa) {
			v = it-&gt;to;
			if (g[v][k - 1] &lt; f[v][min(k + 1, d + 1)]) {
				flag = false;
				tmp += g[v][k - 1];
			} else {
				tmp += f[v][min(k + 1, d + 1)];
				cmin(mi, g[v][k - 1]  - f[v][min(k + 1, d + 1)]);
			}
		}
		f[u][k] = g[u][k] = tmp;
		if (flag) g[u][k] += mi;
	}
	if (!vis[u]) {
		tmp = 0;
		for (overedge) if (it-&gt;to ^ fa) {
			v = it-&gt;to;
			tmp += g[v][d + 1];
			cmin(tmp, 0x3f3f3f3f);
		}
		cmin(f[u][d + 1], tmp);
		cmin(g[u][d + 1], tmp);
	}
	f[u][0] = g[u][0] = w[u];
	for (overedge) if (it-&gt;to ^ fa) {
		v = it-&gt;to;
		tmp = min(min(g[v][d], g[v][d + 1]), f[v][1]);
		f[u][0] += tmp;
		g[u][0] += tmp;
	}
	rep(i, 1, d + 1) cmin(g[u][i], g[u][i - 1]);
	if (vis[u]) f[u][d + 1] = g[u][d];
	else cmin(f[u][0], g[u][d + 1]);
	for (int k = d; k; --k) {
		cmin(f[u][k], min(f[u][k + 1], f[u][0]));
		cmin(f[u][k], min(g[u][d], g[u][d + 1]));
	}
	if (vis[u]) g[u][d + 1] = 0x3f3f3f3f;
}

int main() {
	int x, y;
	gi(n), gi(d);
	rep(i, 1, n) gi(w[i]);
	gi(m);
	rep(i, 1, m) {
		gi(x);
		vis[x] = true;
	}
	rep(i, 2, n) {
		gi(x), gi(y);
		//printf(&quot;%d %d\n&quot;, x, y);
		add_edge(x, y);
		add_edge(y, x);
	}
	memset(g, 63, sizeof g);
	dfs(1, 0);
	x = 0x3f3f3f3f;
	rep(i, 0, d + 1) cmin(x, g[1][i]);
	printf(&quot;%d\n&quot;, x);
	return 0;
}<pre><h2>Problem4557</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int MaxN = 500003, MaxD = 22, BUF = 1 &lt;&lt; 16 | (127);
//Fast Input
inline char gc() {
	static char b[BUF], *s = b, *e = b;
	if (s == e) {
		e = (s = b) + fread(b, 1, BUF, stdin);
		if (s == e) return EOF;
	}
	return *s++;
}
inline void gi(int &amp;a) {
	static char c;
	do c = gc(); while (c &lt; '0');
	for (a = c - 48; 47 &lt; (c = gc()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48);
}
struct edge {
	int to;
	edge *nxt;
} edge_mset[MaxN &lt;&lt; 1], *cedge = edge_mset, *G[MaxN];
#define overedge edge *it = G[u]; it; it = it-&gt;nxt
inline void add_edge(int a, int b) {
	*cedge = (edge) {b, G[a]};
	G[a] = cedge++;
}
bool vis[MaxN];
int n, m, d, f[MaxN][MaxD], g[MaxN][MaxD], w[MaxN];
#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)
inline void cmin(int &amp;a, const int &amp;b) {
	if (b &lt; a) a = b;
}
inline int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}
void dfs(int u, int fa) {
	int v;
	g[u][0] = f[u][0] = vis[u] ? w[u] : 0;
	rep(i, 1, d) g[u][i] = w[u];
	g[u][d + 1] = 0x3f3f3f3f;
	for (overedge) {
		v = it-&gt;to;
		if (!(v ^ fa)) continue;
		dfs(v, u);
		rep(i, 0, d) g[u][i] = min(g[u][i] + f[v][i], f[u][i + 1] + g[v][i + 1]);
		for (int i = d; ~i; --i) cmin(g[u][i], g[u][i + 1]);
		f[u][0] = g[u][0];
		rep (i, 1, d) 
			f[u][i] = min(f[u][i - 1], f[u][i] + f[v][i - 1]);
	}
}
int main() {
	int x, y;
	gi(n), gi(d);
	rep(i, 1, n) gi(w[i]);
	gi(m);
	rep(i, 1, m) {
		gi(x);
		vis[x] = true;
	}
	rep(i, 2, n) {
		gi(x), gi(y);
		//printf(&quot;%d %d\n&quot;, x, y);
		add_edge(x, y);
		add_edge(y, x);
	}
	dfs(1, 0);
	printf(&quot;%d\n&quot;, f[1][0]);
	return 0;
}<pre><h2>Problem4558</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

const int mod = 1e8 + 7;

inline long long calc(long long l, long long r, long long d) {
	if (!l || !r || !d)
	  return 0LL;
	static long long u, a[3], cl, cr, dl, dr, ret;

	u = min(l + r, d);
	a[0] = l + 1;
	a[1] = r + 1;
	a[2] = u;
	sort(a, a + 3);

	cl = 1;
	ret = 0;
	for (register int i = 0; i ^ 3; ++i) {
		cr = a[i];
		if (cr &gt; u) break;
		if (cr &lt; 2 || cl == cr)
		  continue;
		++cl;
		dl = min(r, cl - 1) - max(1LL, cl - l) + 1;
		dr = min(r, cr - 1) - max(1LL, cr - l) + 1;
		ret += (dl + dr) * (cr - cl + 1) &gt;&gt; 1;
		ret %= mod;
		cl = cr;
	}
	return ret;
}

inline long long cal(long long u, long long d, long long l, long long r) {
	return calc(u, d, l) + calc(u, d, r) + calc(l, r, d) + calc(l, r, u) + min(u, l) + min(u, r) + min(d, l) + min(d, r);
}


typedef pair&lt;long long, long long&gt;pll;

pll p[2003];

int n, m, k;

inline bool right(const pll &amp;a) {
	return a.first &gt;= 0 &amp;&amp; a.first &lt; n &amp;&amp; a.second &gt;= 0 &amp;&amp; a.second &lt; m;
}

inline long long to_long_long(const double &amp;a) {
	if (fabs(a - (long long)(a + 0.5)) &lt; 1e-5) 
	  return a + 0.5;
	else
	  return -1;
}

inline bool check(const double &amp;x, const double &amp;y) {
	return right(pll(to_long_long(x), to_long_long(y)));
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	++n, ++m;
	long long ans = 0, cnt3 = 0, cnt4 = 0, x, y;
	for (register int i = 1, end = n &lt; m ? n : m; i &lt;= end; ++i)
	  ans = (ans + (long long)(n - i) * (m - i) % mod * i) % mod;
	for (register int i = 0; i &lt; k; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		ans -= cal(x, n - x - 1, y, m - y - 1);
		ans %= mod;
		p[i] = pll(x, y);
	}

	sort(p, p + k);

	for (register int i = 0; i &lt; k; ++i)
	  for (register int j = i + 1; j &lt; k; ++j) {
		  double nx = (p[i].first + p[j].first) / 2.0, ny = (p[i].second + p[j].second) / 2.0;
		  double dx = p[i].first - nx, dy = p[i].second - ny;
		  if (check(nx + dy, ny - dx) &amp;&amp; check(nx - dy, ny + dx))
			++ans;
		  for (register int d = -1; d &lt; 3; d += 2) {
			long long dx = p[j].first - p[i].first, dy = p[j].second - p[i].second;
			pll p1(p[i].first + dy * d, p[i].second - dx * d), p2(p[j].first + dy * d, p[j].second - dx * d);
			if (!(right(p1) &amp;&amp; right(p2)))
			  continue;
			++ans;
			unsigned int cnt = binary_search(p, p + k, p1) + binary_search(p, p + k, p2);
			if (cnt) ++cnt3;
			if (cnt &gt;&gt; 1) ++cnt4;
		  }
	  }
	ans -= cnt3 &gt;&gt; 1;
	ans -= cnt4 &gt;&gt; 2;
	ans %= mod;
	if (ans &lt; 0) ans += mod;
	printf(&quot;%d\n&quot;, int(ans));
	return 0;
}<pre><h2>Problem4559</h2><pre>#include &lt;cstdio&gt;

const int mod = 1e9 + 7, MaxN = 111;

inline int pw(int a, int b = mod - 2) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = (long long)a * a % mod)
	  if (b &amp; 1) r = (long long)r * a % mod;
	return r;
}

typedef int arr[MaxN];
arr f, g, bin, U, R, fac, inv;

inline int C(const int &amp;n, const int &amp;m) {
	return (long long)fac[n] * inv[m] % mod * inv[n - m] % mod;
}

int main() {

	int n, m, k;

	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);

	*fac = 1;
	for (register int i = 1; i &lt; MaxN; ++i) 
	  fac[i] = (long long)fac[i - 1] * i % mod;

	inv[MaxN - 1] = pw(fac[MaxN - 1]);
	for (register int i = MaxN - 2; ~i; --i)
	  inv[i] = (long long)inv[i + 1] * (i + 1) % mod;

	for (register int i = 0; i &lt; m; ++i)
	  scanf(&quot;%d&quot;, U + i);

	for (register int i = 0; i &lt; m; ++i)
	  scanf(&quot;%d&quot;, R + i);
	
	int maxrank = 0;
	for (register int i = 0; i &lt; m; ++i)
	  if (maxrank &lt; R[i]) maxrank = R[i];

	for (register int i = n - maxrank; i &gt;= k; --i) {
		int &amp;x = f[i] = C(n - 1, i);
		//printf(&quot;%d %d\n&quot;, i, x);
		for (register int j = 0; j &lt; m; ++j)
		  x = (long long)x * C(n - i - 1, R[j] - 1) % mod;
		//printf(&quot;%d %d\n&quot;, i, x);
		for (register int j = n - maxrank; j &gt; i; --j)
		  for (x -= (long long)f[j] * C(j, i)% mod; x &lt; 0; x += mod);
		//printf(&quot;%d %d\n&quot;, i, x);
	}

	int ans = f[k];
	//printf(&quot;%d\n&quot;, ans);

	for (register int i = 0; i &lt; m; ++i) {

		g[0] = U[i];
		*bin = 1;

		for (register int j = 1; j &lt;= n; ++j) {
			bin[j] = (long long)bin[j - 1] * U[i] % mod;
			g[j] = pw(U[i] + 1, j + 1) - 1;
			for (register int k = 1; k &lt;= j; ++k)
			  for (g[j] -= (long long)C(j + 1, k + 1) * g[j - k] % mod; g[j] &lt; 0; g[j] += mod);
			g[j] = (long long)g[j] * pw(j + 1) % mod;
		}
		register int tmp = 0;
		for (register int j = 0, sign = 1; j &lt; R[i]; ++j, sign = -sign)
		  tmp = (tmp + (long long)(sign + mod) * C(R[i] - 1, j) % mod * g[n - R[i] + j] % mod * bin[R[i] - j - 1]) % mod;
		ans = (long long)ans * tmp % mod;
	}

	printf(&quot;%d\n&quot;, ans);

	return 0;
}<pre><h2>Problem4561</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MaxS = 400005, MaxN = 200005;

inline int r32() {
	static int r = 0xeedeedef;
	return r = (69069 * r + 1) &amp; (~0u &gt;&gt; 1);
}

struct Circle {
	int x, y, r;
	void read() {
		scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;r);
	}
	bool operator &lt; (const Circle &amp;a) const {
		return x - r &lt; a.x - a.r;
	}
} c[MaxN];
pair&lt;int, int&gt; event[MaxS];

int now;

inline double calc(const int &amp;x, const int &amp;k) {
	static double t;
	t = (long long)(c[x].x - now) * (c[x].x - now);
	t = sqrt((long long)c[x].r * c[x].r - t);
	if (k &lt; 0) return c[x].y - t;
	else return c[x].y + t;
}

struct node {
	node *ls, *rs;
	int sum, val, key, idx;
	void maintain();
	double calc() const;
} node_mset[MaxS], *nil, *root, *cnode = node_mset;

inline node *newnode(const int &amp;x, const int &amp;idx) {
	cnode-&gt;idx = idx;
	cnode-&gt;key = r32();
	cnode-&gt;ls = cnode-&gt;rs = nil;
	cnode-&gt;sum = cnode-&gt;val = x;
	return cnode++;
}

void node :: maintain() {
	sum = val + ls-&gt;sum + rs-&gt;sum;
}

double node :: calc() const {
	return ::calc(idx, val);
}

void lrt(node * &amp;u) {
	node *t = u-&gt;rs;
	u-&gt;rs = t-&gt;ls;
	t-&gt;ls = u;
	t-&gt;sum = u-&gt;sum;
	u-&gt;maintain();
	u = t;
}
void rrt(node * &amp;u) {
	node *t = u-&gt;ls;
	u-&gt;ls = t-&gt;rs;
	t-&gt;rs = u;
	t-&gt;sum = u-&gt;sum;
	u-&gt;maintain();
	u = t;
}

void Insert(node * &amp;u, const int &amp;p, const int &amp;k) {
	if (u == nil) {
		u = newnode(k, p);
		return;
	}
	u-&gt;sum += k;
	if (u-&gt;calc() &lt; calc(p, k) || (u-&gt;val &lt; k &amp;&amp; u-&gt;calc() == calc(p, k))) {
		Insert(u-&gt;ls, p ,k);
		if (u-&gt;ls-&gt;key &gt; u-&gt;key) rrt(u);
	} else {
		Insert(u-&gt;rs, p, k);
		if (u-&gt;rs-&gt;key &gt; u-&gt;key) lrt(u);
	}
}

void Delete(node * &amp;u, const int &amp;p, const int &amp;k) {
	if (u-&gt;idx == p &amp;&amp; u-&gt;val == k) {
		if (u-&gt;ls == nil) u = u-&gt;rs;
		else if (u-&gt;rs == nil) u = u-&gt;ls;
		else if (u-&gt;ls-&gt;key &lt; u-&gt;rs-&gt;key) {
			rrt(u);
			Delete(u, p, k);
		} else {
			lrt(u);
			Delete(u, p, k);
		}
	} else {
		u-&gt;sum -= k;
		if (u-&gt;calc() &lt; calc(p, k) || (u-&gt;val &lt; k &amp;&amp; u-&gt;calc() == calc(p, k)))
		  Delete(u-&gt;ls, p, k);
		else
		  Delete(u-&gt;rs, p, k);
	}
}

inline int g(const int &amp;v) {
	int ans = 0;
	node *u = root;
	while (u != nil) {
		if (u-&gt;calc() &gt; v) {
			ans += u-&gt;ls-&gt;sum + u-&gt;val;
			u = u-&gt;rs;
		} else
		  u = u-&gt;ls;
	}
	return ans;
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int n, tot = 0;
	long long ans = 0;
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; ++i) {
		c[i].read();
		event[tot++] = make_pair(c[i].x - c[i].r, i);
		event[tot++] = make_pair(c[i].x + c[i].r, -i);
	}
	sort(event, event + tot);
	nil = cnode++;
	*nil = (node) {nil, nil, 0, 0, 0, 0};
	root = nil;
	for (int i = 0; i &lt; tot; ++i) {
		now = event[i].first;
		if (event[i].second &gt; 0) {
			if (g(c[event[i].second].y) &amp; 1)
			  ans -= (long long)c[event[i].second].r * c[event[i].second].r;
			else
			  ans += (long long)c[event[i].second].r * c[event[i].second].r;
			Insert(root, event[i].second, 1);
			Insert(root, event[i].second, -1);
		}  else {
			Delete(root, -event[i].second, 1);
			Delete(root, -event[i].second, -1);
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4566</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define LL long long
const int N=400010;
LL ans;
char ss[N];
int n,m,len[2],sa[N],c[N],rank[N],height[N],t1[N],t2[N],s[N],fa[N],st[N],en[N],a[N];
inline bool cmp(int *y,int p,int q,int k){
    int o0=p+k&gt;=n?-1:y[p+k];
    int o1=q+k&gt;=n?-1:y[q+k];
    return o0==o1&amp;&amp;y[p]==y[q];
}
inline void build_sa(){
    int i,k,p,*x=t1,*y=t2;
    for(m=28,i=0;i&lt;m;++i) c[i]=0;
    for(i=0;i&lt;n;++i) ++c[x[i]=s[i]];
    for(i=1;i&lt;m;++i) c[i]+=c[i-1];
    for(i=n-1;~i;--i) sa[--c[x[i]]]=i;
    for(k=1;k&lt;=n;k&lt;&lt;=1){
        for(p=0,i=n-k;i&lt;n;++i) y[p++]=i;
        for(i=0;i&lt;n;++i) if(sa[i]&gt;=k) y[p++]=sa[i]-k;
        for(i=0;i&lt;m;++i) c[i]=0;
        for(i=0;i&lt;n;++i) ++c[x[y[i]]];
        for(i=1;i&lt;m;++i) c[i]+=c[i-1];
        for(i=n-1;~i;--i) sa[--c[x[y[i]]]]=y[i];
        swap(x,y);
        m=1;x[sa[0]]=0;
        for(i=1;i&lt;n;++i) x[sa[i]]=cmp(y,sa[i],sa[i-1],k)?m-1:m++;
        if(m&gt;=n) break;
    }
}
inline void build_height(){
    int i,k=0,j;
    for(i=0;i&lt;n;++i) rank[sa[i]]=i;
    for(i=0;i&lt;n;++i){
        if(!rank[i]) continue;
        k=k?--k:k;
        j=sa[rank[i]-1];
        while(s[i+k]==s[j+k]) ++k;
        height[rank[i]]=k;
    }
}
inline bool CMP(int x,int y){
    return height[x]&gt;height[y];
}
inline int find(int x){
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}
inline void calc(int x){
    if(!x) return ;
    int r1=find(x),r2=find(x-1);
    ans+=(LL)(st[r1]*en[r2]+st[r2]*en[r1])*(LL)height[x];
    st[r1]+=st[r2];en[r1]+=en[r2];fa[r2]=r1;
}
int main(){
    int i,j,minn;
    scanf(&quot;%s&quot;,ss);
    len[0]=strlen(ss);
    for(i=0;i&lt;len[0];++i) s[i]=ss[i]-'a'+1;
    scanf(&quot;%s&quot;,ss);
    len[1]=strlen(ss);
    for(s[len[0]]=27,i=0;i&lt;len[1];++i) s[i+len[0]+1]=ss[i]-'a'+1;
    n=len[0]+len[1]+1;
    build_sa();
    build_height();
    for(i=0;i&lt;n;++i){
        a[i]=fa[i]=i;
        st[i]=(sa[i]&lt;len[0]);
        en[i]=1-st[i];
    }
    sort(a,a+n,CMP);
    for(i=0;i&lt;n;++i) calc(a[i]);
    printf(&quot;%lld\n&quot;,ans);
}<pre><h2>Problem4566</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define rep(i, n) for (i = 0; i &lt; (n); ++i)
#define Rep(i, n) for (i = 1; i &lt; (n); ++i)
#define rrp(i, n) for (i = n - 1; ~i; --i)
const int MaxN = 400010;
typedef int arr[MaxN], _;
_ n, len[2];
char ts[MaxN];
long long ans;
arr sa, ws, wv, ta, tb, rk, hi, fa, st, en, a, s;
#define rx(a) ((a) &gt;= n ? -1 : r[a])
inline bool cmp(int *r, int i, int j, int l) {
	return r[i] == r[j] &amp;&amp; rx(i + l) == rx(j + l);
}
inline void da() {
	_ i, j, p, *x = ta, *y = tb, *t, m = 28;
	rep(i, m) ws[i] = 0;
	rep(i, n) ++ws[x[i] = s[i]];
	Rep(i, m) ws[i] += ws[i - 1];
	rrp(i, n) sa[--ws[x[i]]] = i;
	for (p = j = 1; p &lt; n; j &lt;&lt;= 1, m = p) {
		for (p = 0, i = n - j; i &lt; n; ++i) y[p++] = i;
		rep(i, n) if (sa[i] &gt;= j) y[p++] = sa[i] - j;
		rep(i, m) ws[i] = 0;
		rep(i, n) ++ws[wv[i] = x[y[i]]];
		Rep(i, m) ws[i] += ws[i - 1];
		rrp(i, n) sa[--ws[wv[i]]] = y[i];
		for (t = x, x = y, y = t, p = i = 1, x[sa[0]] = 0; i &lt; n; ++i)
			x[sa[i]] = cmp(y, sa[i], sa[i - 1], j) ? p - 1 : p++;
	}
}
inline void calcheight() {
	_ i, j, k;
	rep(i, n) rk[sa[i]] = i;
	for (i = k = 0; i &lt; n; hi[rk[i++]] = k) {
		if (!rk[i]) continue;
		k ? --k : 0;
		for (j = sa[rk[i] - 1]; s[i + k] == s[j + k]; ++k);
	}
}
int gf(_ u) {
	return fa[u] == u ? u : fa[u] = gf(fa[u]);
}
inline void calc(const _ &amp;x) {
	if (!x) return;
	_ r1 = gf(x), r2 = gf(x - 1);
	ans += ((long long)st[r1] * en[r2] + (long long)st[r2] * en[r1]) * hi[x];
	st[r1] += st[r2], en[r1] += en[r2], fa[r2] = r1;
}
inline bool _cmp(const _ &amp;a, const _ &amp;b) {
	return hi[a] &gt; hi[b];
}
int main() {
	_ i;
	scanf(&quot;%s&quot;, ts);
	len[0] = strlen(ts);
	rep(i, len[0]) s[i] = ts[i] - 'a' + 1;
	s[len[0]] = 27;
	scanf(&quot;%s&quot;, ts);
	len[1] = strlen(ts);
	rep(i, len[1]) s[i + len[0] + 1] = ts[i] - 'a' + 1;
	n = len[0] + len[1] + 1;
	da();
	calcheight();
	rep(i, n) {
		a[i] = fa[i] = i;
		st[i] = (sa[i] &lt; len[0]);
		en[i] = st[i] ^ 1;
	}
	std::sort(a, a + n, _cmp);
	rep(i, n) calc(a[i]);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4566</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define rep(i, n) for (i = 0; i &lt; (n); ++i)
#define Rep(i, n) for (i = 1; i &lt; (n); ++i)
#define rrp(i, n) for (i = n - 1; ~i; --i)
const int MaxN = 400010;
typedef int arr[MaxN], _;
_ n, len[2];
char ts[MaxN];
long long ans;
arr sa, ws, wv, ta, tb, rk, hi, fa, st, en, a, s;
#define rx(a) ((a) &gt;= n ? -1 : r[a])
inline bool cmp(int *r, int i, int j, int l) {
    return r[i] == r[j] &amp;&amp; rx(i + l) == rx(j + l);
}
inline void da() {
    _ i, j, p, *x = ta, *y = tb, *t, m = 28;
    rep(i, m) ws[i] = 0;
    rep(i, n) ++ws[x[i] = s[i]];
    Rep(i, m) ws[i] += ws[i - 1];
    rrp(i, n) sa[--ws[x[i]]] = i;
    for (p = j = 1; p &lt; n; j &lt;&lt;= 1, m = p) {
        for (p = 0, i = n - j; i &lt; n; ++i) y[p++] = i;
        rep(i, n) if (sa[i] &gt;= j) y[p++] = sa[i] - j;
        rep(i, m) ws[i] = 0;
        rep(i, n) ++ws[wv[i] = x[y[i]]];
        Rep(i, m) ws[i] += ws[i - 1];
        rrp(i, n) sa[--ws[wv[i]]] = y[i];
        for (t = x, x = y, y = t, p = i = 1, x[sa[0]] = 0; i &lt; n; ++i)
            x[sa[i]] = cmp(y, sa[i], sa[i - 1], j) ? p - 1 : p++;
    }
}
inline void calcheight() {
    _ i, j, k;
    rep(i, n) rk[sa[i]] = i;
    for (i = k = 0; i &lt; n; hi[rk[i++]] = k) {
        if (!rk[i]) continue;
        k ? --k : 0;
        for (j = sa[rk[i] - 1]; s[i + k] == s[j + k]; ++k);
    }
}
int gf(_ u) {
    return fa[u] == u ? u : fa[u] = gf(fa[u]);
}
inline void calc(const _ &amp;x) {
    if (!x) return;
    _ r1 = gf(x), r2 = gf(x - 1);
    ans += (long long)(st[r1] * en[r2] + st[r2] * en[r1]) * hi[x];
    st[r1] += st[r2], en[r1] += en[r2], fa[r2] = r1;
}
inline bool _cmp(const _ &amp;a, const _ &amp;b) {
    return hi[a] &gt; hi[b];
}
int main() {
    _ i;
    scanf(&quot;%s&quot;, ts);
    len[0] = strlen(ts);
    rep(i, len[0]) s[i] = ts[i] - 'a' + 1;
    s[len[0]] = 27;
    scanf(&quot;%s&quot;, ts);
    len[1] = strlen(ts);
    rep(i, len[1]) s[i + len[0] + 1] = ts[i] - 'a' + 1;
    n = len[0] + len[1] + 1;
    da();
    calcheight();
    rep(i, n) {
        a[i] = fa[i] = i;
        st[i] = (sa[i] &lt; len[0]);
        en[i] = st[i] ^ 1;
    }
    std::sort(a, a + n, _cmp);
    rep(i, n) calc(a[i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}<pre><h2>Problem4566</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

struct SAM {
	static const int MaxS = 800000 + 5;
	struct node {
		int step, sz1, sz2, d;
		node *pre, *ch[26];
		void clear() {
			pre = NULL;
			sz1 = sz2 = d = 0;
			memset(ch, 0, sizeof ch);
		}
	} node_mset[MaxS], *cnode, *root, *last;
	long long ans;
	queue&lt;node*&gt; q;
	inline node *newnode(const int &amp;step) {
		cnode-&gt;clear();
		cnode-&gt;step = step;
		return cnode++;
	}
	
	void Init() {
		ans = 0LL;
		cnode = node_mset;
		root = last = newnode(0);
	}
	
	void Insert(const int &amp;c) {
		node *p = last, *np = newnode(p-&gt;step + 1);
		for (; p &amp;&amp; !p-&gt;ch[c]; p = p-&gt;pre)
			p-&gt;ch[c] = np;
		if (!p)
			np-&gt;pre = root;
		else {
			node *q = p-&gt;ch[c];
			if (p-&gt;step + 1 == q-&gt;step)
				np-&gt;pre = q;
			else {
				node *nq = newnode(p-&gt;step + 1);
				memcpy(nq-&gt;ch, q-&gt;ch, sizeof q-&gt;ch);
				nq-&gt;pre = q-&gt;pre;
				q-&gt;pre = np-&gt;pre = nq;
				for (; p &amp;&amp; p-&gt;ch[c] == q; p = p-&gt;pre)
					p-&gt;ch[c] = nq;
			}
		}
		
		last = np;
		
	}

	void calc() {
		for (node *i = node_mset; i &lt; cnode; ++i)
			if (i-&gt;pre)
				++(i-&gt;pre-&gt;d);
		
		for (node *i = node_mset; i &lt; cnode; ++i)
			if (!i-&gt;d) q.push(i);
		while (!q.empty()) {
			node *u = q.front();
			q.pop();
			if (u-&gt;pre) {
				u-&gt;pre-&gt;sz1 += u-&gt;sz1;
				u-&gt;pre-&gt;sz2 += u-&gt;sz2;
				if (!--(u-&gt;pre-&gt;d))
					q.push(u-&gt;pre);
			}
		}
		long long t;
		for (node *i = node_mset; i &lt; cnode; ++i) {
			t = i-&gt;step;
			if (i-&gt;pre)
				t -= i-&gt;pre-&gt;step;
			ans += t * i-&gt;sz1 * i-&gt;sz2;
		}
	}
	
} sam;

char s[200005];

int main() {
	sam.Init();
	
	scanf(&quot;%s&quot;, s);
	for (char *i = s; *i; ++i) {
		sam.Insert(*i - 'a');
		++sam.last-&gt;sz1;
	}
	scanf(&quot;%s&quot;, s);
	sam.last = sam.root;
	for (char *i = s; *i; ++i) {
		sam.Insert(*i - 'a');
		++sam.last-&gt;sz2;
	}
	sam.calc();
	printf(&quot;%lld\n&quot;, sam.ans);
	return 0;
}<pre><h2>Problem4567</h2><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 510002
int ch[26][N],tn; bool d[N];
inline void insert(char *s) {
	int u=0,i=strlen(s)-1;
	for(;~i;u=ch[s[i--]-'a'][u])if(!ch[s[i]-'a'][u])ch[s[i]-'a'][u]=++tn;
	d[u]=true;
}
int sz[N],id[N]; long long ans;
inline bool cmp(const int&amp;a,const int&amp;b){return sz[a]&lt;sz[b];}
vector&lt;int&gt;g[N];
void build(int u,int fa) {
	int t=0;
	if(d[u])g[fa].push_back(t=++tn),fa=t;
	for(int i=0;i&lt;26;++i)if(ch[i][u])build(ch[i][u],fa);
	if(t) {
		sz[t]=1;
		for(int i=0;i&lt;g[t].size();++i)sz[t]+=sz[g[t][i]];
	}
}
void cal(int u) {
	id[u]=++tn;
	sort(g[u].begin(),g[u].end(),cmp);
	for(int i=0;i&lt;g[u].size();++i) {
		ans+=tn+1-id[u];
		cal(g[u][i]);
	}
}
char ts[N];
int main() {
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--) {
		scanf(&quot;%s&quot;,ts);
		insert(ts);
	}
	tn=0; build(0,0);
	tn=0; cal(0);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}<pre><h2>Problem4568</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline long long getll() {
	register long long a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 20002
#define Q 200002
long long a[N][61],t[61],val[N],ans[Q];
inline void add_val(long long val,long long*c) {
	for(register int i=59;(~i)&amp;&amp;val;--i)
		if(val&gt;&gt;i&amp;1) (c[i])?(val^=c[i]):(c[i]=val,val=0);
}
inline long long quy(long long*c) {
	long long r=0;
	for(register int i=59;~i;--i)
		if((r^c[i])&gt;r)r^=c[i];
	return r;
}
int to[N&lt;&lt;1],nt[N&lt;&lt;1],hd[N],te;
#define adde(a,b) (to[te]=b,nt[te]=hd[a],hd[a]=te++)
int tq[Q&lt;&lt;5],nq[Q&lt;&lt;5],hq[N],cq,U[Q],V[Q];
#define addq(a,b) (tq[cq]=b,nq[cq]=hq[a],hq[a]=cq++)
int siz[N],rt,mif,all,ps[N],st[Q]; bool vis[N];
void getroot(int u,int fa) {
	int f=0;siz[u]=1;
	for(int i=hd[u];~i;i=nt[i])
		if(!vis[i&gt;&gt;1]&amp;&amp;(to[i]^fa)) {
			getroot(to[i],u);
			siz[u]+=siz[to[i]];
			if(siz[to[i]]&gt;f) f=siz[to[i]];
		}
	if(all-siz[u]&gt;f) f=all-siz[u];
	if(f&lt;mif) rt=u,mif=f;
}
#define mst(a) memset(a,0,sizeof a)
#define mcp(a,b) memcpy(a,b,sizeof a)
void dfs(int u,int fa,int anc) {
	ps[u]=anc; mcp(a[u],a[fa]);
	add_val(val[u],a[u]);
	for(int i=hd[u];~i;i=nt[i])
		if(!vis[i&gt;&gt;1]&amp;&amp;(to[i]^fa))dfs(to[i],u,anc);
}
void cal(int u) {
	if(!(~hq[u]))return;
	mif=all=siz[u];
	getroot(u,rt=0);
	ps[rt]=rt; mst(a[rt]);
	add_val(val[rt],a[rt]);
	for(int i=hd[rt];~i;i=nt[i])if(!vis[i&gt;&gt;1])dfs(to[i],rt,to[i]);
	int tp=0,x,y,i,j;
	for(i=hq[u];~i;i=nq[i])st[++tp]=tq[i];hq[u]=-1;
	for(i=1;i&lt;=tp;++i)
		if(ps[x=U[st[i]]]==ps[y=V[st[i]]])addq(ps[x],st[i]);
		else {
			mcp(t,a[x]);
			for(j=59;~j;--j)if(a[y][j])add_val(a[y][j],t);
			ans[st[i]]=quy(t);
		}
	for(i=hd[rt];~i;i=nt[i])if(!vis[i&gt;&gt;1])vis[i&gt;&gt;1]=1,cal(to[i]);
}
int main() {
	register int n=geti(),q=geti(),i,a,b;
	for(i=1;i&lt;=n;++i)val[i]=getll(),hq[i]=hd[i]=-1;
	for(i=1;i&lt;n;++i){
		a=geti(),b=geti();
		adde(a,b);adde(b,a);
	}
	for(i=1;i&lt;=q;++i) {
		U[i]=geti(),V[i]=geti();
		if(U[i]^V[i])addq(1,i);
		else ans[i]=val[U[i]];
	}
	siz[1]=n;cal(1);
	for(i=1;i&lt;=q;++i)printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem4568</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char inb[1&lt;&lt;16],*ins=inb,*ine=inb;
#define getc (((ins==ine)&amp;&amp;(ine=(ins=inb)+fread(inb,1,1&lt;&lt;16,stdin),ins==ine))?EOF:*ins++)
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
inline long long getll() {
	register long long a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 20002
#define Q 200002
long long a[N][61],t[61],val[N],ans[Q];
inline void add_val(long long val,long long*c) {
	for(register int i=59;(~i)&amp;&amp;val;--i)
		if(val&gt;&gt;i&amp;1) (c[i])?(val^=c[i]):(c[i]=val,val=0);
}
inline long long quy(long long*c) {
	long long r=0;
	for(register int i=59;~i;--i)
		if((r^c[i])&gt;r)r^=c[i];
	return r;
}
int to[N&lt;&lt;1],nt[N&lt;&lt;1],hd[N],te;
#define adde(a,b) (to[te]=b,nt[te]=hd[a],hd[a]=te++)
int tq[Q&lt;&lt;5],nq[Q&lt;&lt;5],hq[N],cq,U[Q],V[Q];
#define addq(a,b) (tq[cq]=b,nq[cq]=hq[a],hq[a]=cq++)
int siz[N],rt,mif,all,ps[N],st[Q]; bool vis[N];
void getroot(const int&amp;u,const int&amp;fa) {
	int f=0;siz[u]=1;
	for(int i=hd[u];~i;i=nt[i])
		if(!vis[i&gt;&gt;1]&amp;&amp;(to[i]^fa)) {
			getroot(to[i],u);
			siz[u]+=siz[to[i]];
			if(siz[to[i]]&gt;f) f=siz[to[i]];
		}
	if(all-siz[u]&gt;f) f=all-siz[u];
	if(f&lt;mif) rt=u,mif=f;
}
#define mst(a) memset(a,0,sizeof a)
#define mcp(a,b) memcpy(a,b,sizeof a)
void dfs(const int&amp;u,const int&amp;fa,const int&amp;anc) {
	ps[u]=anc; mcp(a[u],a[fa]);
	add_val(val[u],a[u]);
	for(int i=hd[u];~i;i=nt[i])
		if(!vis[i&gt;&gt;1]&amp;&amp;(to[i]^fa))dfs(to[i],u,anc);
}
void cal(const int&amp;u) {
	if(!(~hq[u]))return;
	mif=all=siz[u];
	getroot(u,rt=0);
	ps[rt]=rt; mst(a[rt]);
	add_val(val[rt],a[rt]);
	for(int i=hd[rt];~i;i=nt[i])if(!vis[i&gt;&gt;1])dfs(to[i],rt,to[i]);
	int tp=0,x,y,i,j;
	for(i=hq[u];~i;i=nq[i])st[++tp]=tq[i];hq[u]=-1;
	for(i=1;i&lt;=tp;++i)
		if(ps[x=U[st[i]]]==ps[y=V[st[i]]])addq(ps[x],st[i]);
		else {
			mcp(t,a[x]);
			for(j=59;~j;--j)if(a[y][j])add_val(a[y][j],t);
			ans[st[i]]=quy(t);
		}
	for(i=hd[rt];~i;i=nt[i])if(!vis[i&gt;&gt;1])vis[i&gt;&gt;1]=1,cal(to[i]);
}
int main() {
	register int n=geti(),q=geti(),i,a,b;
	for(i=1;i&lt;=n;++i)val[i]=getll(),hq[i]=hd[i]=-1;
	for(i=1;i&lt;n;++i){
		a=geti(),b=geti();
		adde(a,b);adde(b,a);
	}
	for(i=1;i&lt;=q;++i) {
		U[i]=geti(),V[i]=geti();
		if(U[i]^V[i])addq(1,i);
		else ans[i]=val[U[i]];
	}
	siz[1]=n;cal(1);
	for(i=1;i&lt;=q;++i)printf(&quot;%lld\n&quot;,ans[i]);
	return 0;
}<pre><h2>Problem4569</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
int f[18][100005]; bool vis[100005];
int gf(int k,int u){return (f[k][u]^u)?f[k][u]=gf(k,f[k][u]):u;}
void Union(int k,int u,int v) {
	if(gf(k,u)^gf(k,v)) {
		f[k][f[k][u]]=f[k][v];
		if(!k--) return;
		Union(k,u,v); Union(k,u+(1&lt;&lt;k),v+(1&lt;&lt;k));
	}
}
int main() {
	register int n=geti(),m=geti(),a,b,c,d,i,j;
	for(a=0;(1&lt;&lt;a)&lt;=n;++a)
		for(b=1;b+(1&lt;&lt;a)-1&lt;=n;++b)
			f[a][b]=b;
	while(m--) {
		a=geti(),b=geti(),c=geti(),d=geti();
		for(i=0,j=b-a+1;(1&lt;&lt;i+1)&lt;=j;++i);j=1&lt;&lt;i;
		Union(i,a,c); Union(i,b-j+1,d-j+1);
	}
	a=9;vis[gf(0,1)]=true;
	m=1e9+7;
	for(i=2;i&lt;=n;++i)if(!vis[gf(0,i)])vis[gf(0,i)]=true,a=a*10LL%m;
	printf(&quot;%d\n&quot;,a); return 0;
}<pre><h2>Problem4570</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
/*
  s(a,b)
  =max(atk(a,b))+max(dnf(a,b))
  =atk+a/b*dnf+dnf+b/a*atk
  (let k b/a)
  =atk+dnf+k*atk+dnf/k
  for const S=s(a,b)
  (1+k)*atk=S-(1+1/k)*dnf
  atk=S/(1+k)-(1+1/k)/(1+k)*dnf
  for const K
  to-let S/(1+K) -&gt; min
*/
inline int geti() {
	register int a; register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
struct P{int x,y;P(int _x=0,int _y=0):x(_x),y(_y){}}p[1000005],st[1000005];
inline P operator - (const P&amp;a,const P&amp;b) {return P(a.x-b.x,a.y-b.y);}
inline bool operator &lt; (const P&amp;a,const P&amp;b) {return (a.x^b.x)?a.x&lt;b.x:a.y&lt;b.y;}
inline long long operator * (const P&amp;a,const P&amp;b) {return (long long)a.x*b.y-(long long)a.y*b.x;}
const double oo=1e20;
inline double g(const P&amp;a){return -sqrt((double)a.y/a.x);}
inline double gk(const P&amp;a,const P&amp;b) {return (a.x^b.x)?(double)(a.y-b.y)/(double)(a.x-b.x):oo;}
inline double cal(const P&amp;a,const double&amp;k) {return k&gt;=0?oo:a.x+a.y-k*a.x-a.y/k;}
inline double cmin(double&amp;a,const double&amp;b){if(b&lt;a)a=b;}
int main() {
	register int n=geti(),i,tp=0;
	for(i=0;i&lt;n;++i)p[i]=(P){geti(),geti()};
	std::sort(p,p+n);
	st[++tp]=*p;
	for(i=1;i&lt;n;++i) {
		while(1&lt;tp&amp;&amp;(st[tp]-st[tp-1])*(p[i]-st[tp-1])&gt;=0)--tp;
		st[++tp]=p[i];
	}
	if(tp&lt;2) printf(&quot;%.4lf\n&quot;,cal(st[1],g(st[1]))),0;
	double ans=oo,k,k1,k2;
	k2=gk(st[1],st[2]),k=g(st[1]);
	if(k&gt;=k2)cmin(ans,cal(st[1],k));
	k1=gk(st[tp-1],st[tp]),k=g(st[tp]);
	if(k&lt;=k1)cmin(ans,cal(st[tp],k));
	cmin(ans,cal(st[tp],k1));
	for(i=2;i&lt;tp;++i) {
		k1=gk(st[i-1],st[i]),k2=gk(st[i],st[i+1]),k=g(st[i]);
		cmin(ans,cal(st[i],k1));
		if(k&lt;=k1&amp;&amp;k&gt;=k2)cmin(ans,cal(st[i],k));
	}
	printf(&quot;%.4lf\n&quot;,ans);
	return 0;
}
<pre><h2>Problem4570</h2><pre>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

const int MaxN = 1e6 + 5;
const double oo = 1e66;

struct Point {
	int x, y;
	Point() {}
	Point(int x, int y) :
		x(x), y(y) {}
	bool operator &lt; (const Point &amp;a) const {
		return (x ^ a.x) ? x &lt; a.x : y &lt; a.y;
	}
	Point operator - (const Point &amp;a) const {
		return Point(x - a.x, y - a.y);
	}
	long long operator * (const Point &amp;a) const {
		return (long long)x * a.y - (long long)y * a.x;
	}
}p[MaxN], stk[MaxN];

inline double g(const Point &amp;a) {
	return -sqrt((double)a.y / a.x);
}

inline double g(const Point &amp;a, const Point &amp;b) {
	return (a.x ^ b.x) ? (double)(a.y - b.y) / (double)(a.x - b.x) : oo;
}

inline double g(const Point &amp;a, const double &amp;k) {
	return k &lt; 0 ? a.x + a.y - k * a.x - a.y / k : oo;
}

inline void g(double &amp;a, const double &amp;b) {
	if (b &lt; a)
		a = b;
}

int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	register int i, tp;
	for (i = tp = 0; i &lt; n; ++i)
		scanf(&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y);
	std::sort(p, p + n);
	stk[++tp] = *p;
	for (i = 1; i &lt; n; ++i) {
		while (1 &lt; tp &amp;&amp; (stk[tp] - stk[tp - 1]) * (p[i] - stk[tp - 1]) &gt;= 0)
			--tp;
		stk[++tp] = p[i];
	}
	if (tp &lt; 2) {
		printf(&quot;%.4lf\n&quot;, g(stk[1], g(stk[1])));
		return 0;
	}
	double ans = oo, k, k1, k2;

	k1 = g(stk[tp - 1], stk[tp]);
	k = g(stk[tp]);
	if (k &lt;= k1)
		g(ans, g(stk[tp], k));
	g(ans, g(stk[tp], k1));
	
	k2 = g(stk[1], stk[2]);
	k = g(stk[1]);
	if (k &gt;= k2)
		g(ans, g(stk[1], k));
	
	for (i = 1; i &lt; tp; ++i) {
		k1 = k2;
		k2 = g(stk[i], stk[i + 1]);
		k = g(stk[i]);
		if (k &lt;= k1 &amp;&amp; k &gt;= k2)
			g(ans, g(stk[i], k));
		g(ans, g(stk[i], k1));
	}

	printf(&quot;%.4lf\n&quot;, ans);
	
	return 0;
}<pre><h2>Problem4571</h2><pre>#include &lt;cstdio&gt;
inline int geti() {
	register int a;register char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 200005
#define M 10000005
int tnd,rt[N],s[M],ls[M],rs[M];
void upd(int l,int r,int la,int&amp;cu,int v) {
	cu=++tnd;
	s[cu]=s[la]+1,ls[cu]=ls[la],rs[cu]=rs[la];
	if(l&gt;=r)return;
	int m=l+r&gt;&gt;1;
	if(v&lt;=m)upd(l,m,ls[la],ls[cu],v);
	else upd(m+1,r,rs[la],rs[cu],v);
}
bool quy(int l,int r,int la,int cu,int x,int y) {
	if(!(s[cu]-s[la]))return false;
	if(x&lt;=l&amp;&amp;r&lt;=y)return true;
	bool ret=0; int m=l+r&gt;&gt;1;
	if(x&lt;=m)ret=ret||quy(l,m,ls[la],ls[cu],x,y);
	if(y &gt;m)ret=ret||quy(m+1,r,rs[la],rs[cu],x,y);
	return ret;
}
int main() {
	register int n=geti(),m=geti(),l,r,x,L,R,i,mi,b;
	for(x=1;x&lt;=n;++x)upd(0,N,rt[x-1],rt[x],geti());
	while(m--) {
		b=geti(),x=geti(),l=geti(),r=geti();
		L=0,R=(1&lt;&lt;19)-1;
		for(i=18;~i;--i) {
			mi=L+R&gt;&gt;1;
			if(b&amp;(1&lt;&lt;i))quy(0,N,rt[l-1],rt[r],L-x,mi-x)?(R=mi):(L=mi+1);
			else quy(0,N,rt[l-1],rt[r],mi-x+1,R-x)?(L=mi+1):(R=mi);
		}
		printf(&quot;%d\n&quot;,b^L);
	}return 0;
}
<pre><h2>Problem4572</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

const int MOD = int(1e9 + 7);
const int StateSize = (1 &lt;&lt; 12) + 5;

int n, m, c, q, r1[10], r2[10], f1[10], f2[10];
int f[StateSize][6][6], g[StateSize][6][6], t1[10][10], t2[10][10];
char c1[10], c2[10];

inline int Change(int s, int t, int mask) {
	if (t &lt; 0)
		return s;
	else
		return s ^ ((mask ^ ((s &gt;&gt; t) &amp; 1)) &lt;&lt; t);
}

inline int FastPow(int a, int b) {
	register int r = 1;
	for (; b &gt; 0; a = 1ll * a * a % MOD, b &gt;&gt;= 1)
		if (b &amp; 1) r = 1ll * r * a % MOD;
	return r;
}

inline int GetType(char c) {
	if (c == 'W')
		return 1;
	else if (c == 'B')
		return 2;
	else
		return 0;
}

inline void KMP(int *r, int *f) {
	register int p = 0;
	for (register int i = 2; i &lt;= ::c; ++i) {
		while (p != 0 &amp;&amp; r[p + 1] != r[i])
			p = f[p];
		f[i] = (r[p + 1] == r[i]) ? ++p : 0;
	}
}

inline void ModAdd(int &amp;x, const int &amp;y) {
	x += y;
	if (x &gt;= MOD)
		x -= MOD;
}

int main() {
	scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;c, &amp;q);
	int ans_max = FastPow(3, n * m);

	while (q--) {
		scanf(&quot;%s %s&quot;, c1 + 1, c2 + 1);
		for (register int i = 1; i &lt;= c; ++i)
			r1[i] = GetType(c1[i]);
		for (register int i = 1; i &lt;= c; ++i)
			r2[i] = GetType(c2[i]);
	  KMP(r1, f1);
	  KMP(r2, f2);

		for (register int i = 0; i &lt; c; ++i)
			for (register int j = 0; j &lt; 3; ++j) {
				register int p;
				for (p = i; p != 0 &amp;&amp; r1[p + 1] != j; p = f1[p]);
				t1[i][j] = (r1[p + 1] == j) ? p + 1 : 0;
				for (p = i; p != 0 &amp;&amp; r2[p + 1] != j; p = f2[p]);
				t2[i][j] = (r2[p + 1] == j) ? p + 1 : 0;
			}

		memset(f, 0, sizeof(f));
		memset(g, 0, sizeof(g));
		g[0][0][0] = 1;
		int base = (1 &lt;&lt; (m - c + 1)) - 1;
		for (register int i = 1; i &lt;= n; ++i) {
			for (register int j = 1; j &lt;= m; ++j) {
				if (j != 1)
					memcpy(f, g, sizeof(f));
				else {
					memset(f, 0, sizeof(f));
					for (register int s = 0; s &lt;= base; ++s)
						for (register int x = 0; x &lt; c; ++x)
							for (register int y = 0; y &lt; c; ++y)
								if (g[s][x][y] != 0)
									ModAdd(f[s][0][0], g[s][x][y]);
				}
				memset(g, 0, sizeof(g));

				for (register int s = 0; s &lt;= base; ++s)
					for (register int x = 0; x &lt; c; ++x)
						for (register int y = 0; y &lt; c; ++y)
							if (f[s][x][y] != 0) {
								for (register int now = 0; now &lt; 3; ++now) {
									int nx = t1[x][now], ny = t2[y][now], T;
									if (ny == c &amp;&amp; j - c &gt;= 0 &amp;&amp; ((s &gt;&gt; (j - c)) &amp; 1) != 0)
										continue;
									if (nx == c)
										T = Change(s, j - c, 1);
									else
										T = Change(s, j - c, 0);
									if (nx == c)
										nx = f1[c];
									if (ny == c)
										ny = f2[c];
									ModAdd(g[T][nx][ny], f[s][x][y]);
								}
							}
			}
		}

		int ans = ans_max;
		for (register int s = 0; s &lt;= base; ++s)
			for (register int x = 0; x &lt; c; ++x)
				for (register int y = 0; y &lt; c; ++y)
					ModAdd(ans, MOD - g[s][x][y]);
		printf(&quot;%d\n&quot;, ans);

	}

	return 0;
}
<pre><h2>Problem4584</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

typedef int arr1[503], arr2[1003];

int main() {

	static const int mod(1e9 + 7);
	static int n, cnt(0);
	static arr1 a, b, inv = {1, 1};
	static arr2 ha, c[503] = {1}, l;

	scanf(&quot;%d&quot;, &amp;n);
	for (register int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d%d&quot;, a + i, b + i);
		ha[cnt++] = a[i];
		ha[cnt++] = b[i] + 1;
	}
	std::sort(ha, ha + cnt);
	cnt = std::unique(ha, ha + cnt) - ha;

	for (register int i = 1; i &lt;= n; ++i) {
		a[i] = std::upper_bound(ha, ha + cnt, a[i]) - ha;
		b[i] = std::upper_bound(ha, ha + cnt, b[i]) - ha;
	}

	for (register int i = 1; i &lt; cnt; ++i) {
		c[0][i] = 1;
		l[i] = ha[i] - ha[i - 1];
	}

	for (register int i = 2; i &lt; 503; ++i)
		inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;

	for (register int i = 1; i &lt;= n; ++i) {
		c[i][0] = 1;
		for (register int j = a[i]; j &lt;= b[i]; ++j) {
			c[i][j] = 1ll * c[i - 1][j - 1] * l[j] % mod;
			static int tot, res;
			tot = 1, res = l[j] - 1;
			for (register int k = i - 1; k; --k)
				if (a[k] &lt;= j &amp;&amp; j &lt;= b[k]) {
					++tot;
					res = 1ll * res * (l[j] + tot - 2) % mod * inv[tot] % mod;
					if (!res) break;
					c[i][j] = (c[i][j] + 1ll * c[k - 1][j - 1] * res) % mod;
				}
		}
		for (register int j = 1; j &lt; cnt; ++j)
			c[i][j] = (1ll * c[i][j] + c[i - 1][j] + c[i][j - 1] - c[i - 1][j - 1] + mod) % mod;
	}

	printf(&quot;%d\n&quot;, (c[n][cnt - 1] - 1 + mod) % mod);

	return 0;
}<pre><h2>Problem4585</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

typedef int arr[int(6e5 + 5)];

arr fa, dis, rt, l, r, son;
long long v[int(6e5 + 5)], sum;

int merge(int x, int y) {
	if (!x || !y) return x + y;
	if (v[x] &lt; v[y]) std::swap(x, y);
	r[x] = merge(r[x], y);
	std::swap(l[x], r[x]);
	return x;
}

inline void pop(int &amp;x) {
	x = merge(l[x], r[x]);
}

void dfs(int u) {
    if (!u) return;
    sum -= v[u];
    dfs(l[u]);
    dfs(r[u]);
}

int main() {
	
	int n, m, tot(0);
	
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	
	for (int i = 2; i &lt;= n + m; ++i) {
		scanf(&quot;%d%d&quot;, fa + i, dis + i);
		++son[fa[i]], sum += dis[i];
	}
	
	for (int i = n + m; i ^ 1; --i) {
		static long long L, R;
		if (son[i]) {
			while (--son[i]) pop(rt[i]);
			L = v[rt[i]], pop(rt[i]);
			R = v[rt[i]], pop(rt[i]);
		} else L = R = 0;
		v[++tot] = L + dis[i];
		v[++tot] = R + dis[i];
		rt[i] = merge(rt[i], merge(tot, tot - 1));
		rt[fa[i]] = merge(rt[i], rt[fa[i]]);
	}
	
	while (son[1]--) pop(rt[1]);
	
	dfs(rt[1]);
	
	printf(&quot;%lld\n&quot;, sum);
	
	return 0;
}<pre><h2>Problem4586</h2><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
using namespace std;

char inb[1 &lt;&lt; 16 | 123], *ine = inb, *ins = inb;
#define gc() ((ins == ine &amp;&amp; (ine = (ins = inb) + fread(inb, 1, 1 &lt;&lt; 16 | 123, stdin), ins == ine)) ? EOF : *ins++)
inline int gi(int &amp;a) {
	static char c;
	do c = gc(); while (c &lt; 48);
	for (a = c - 48; 47 &lt; (c = gc()); a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - '0');
}

const int MaxS = 100000 * 20 + 1, MaxM = 100000;

vector&lt;int&gt; row[MaxS];
long long result[2][MaxS];
int n, x, y, z, rty[MaxS];

inline void cmin(long long &amp;a, const long long &amp;b) {
	if (b &lt; a) a = b;
}

inline void dp(vector&lt;int&gt; &amp;v, long long *res) {
	int m = v.size(), i = -2, j = 1;
	long long ci = 0, cj = 0, cl = 1LL &lt;&lt; 60, t;
	for (; j &lt; m; j += 2) {
		if (j &gt; 1) {
			t = z * abs(v[j - 2] - v[j - 1]);
			cj += t;
			cl += t;
		}
		while (i + 2 &lt; j &amp;&amp; x + y &lt;= z * abs(v[j] - v[i + 2])) {
			if (i += 2) ci += z * abs(v[i] - v[i - 1]);
			cmin(cl, x + y + cj - ci + (i ? res[i - 1] : 0LL));
		}
		res[j] = min(cl, z * abs(v[j] - v[j - 1]) + (1 &lt; j ? res[j - 2] : 0LL));
	}
}

inline long long solve(vector&lt;int&gt; &amp;v, int etc) {
	int m = v.size();
	if (m &lt; 2) return m ? etc : 0LL;
	dp(v, result[0]);
	if (m &amp; 1) {
		reverse(v.begin(), v.end());
		dp(v, result[1]);
		reverse(result[1], result[1] + m);
		long long ret = min(result[0][m - 2], result[1][1]);
		for (int i = 2; i &lt; m - 2; i += 2)
			cmin(ret, result[0][i - 1] + result[1][i + 1]);
		return ret + etc;
	} else
		return result[0][m - 1];
}

int main() {
	//freopen(&quot;t.in&quot;, &quot;r&quot;, stdin);
	int a, b, m, d, ld = 0, lev = MaxM, i;
	gi(n), gi(x), gi(y), gi(z);
	for (i = 0; i &lt; n; ++i) {
		gi(a), gi(b);
		d = (a &gt;= b) ? 1 : -1;
		m = abs(a - b);
		while (m--) {
			if (ld == d) lev += d;
			if (!rty[lev]) rty[lev] = d;
			row[lev].push_back(i);
			ld = d;
		}
	}
	long long ans = 0LL;
	for (i = 0; i &lt; MaxS; ++i)
		ans += solve(row[i], rty[i] &gt; 0 ? y : x);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}<pre><h2>Problem4590</h2><pre>#include &lt;cstdio&gt;

int l, k, x[100001];

int check(long long n) {
	long long curtenlength = 0;
	int accnt = 0, i;
	for (i = 0; i &lt; l; ++i) {
		curtenlength += x[i];
		if (curtenlength &gt;= n)
		  ++accnt, curtenlength = 0LL;
		if (curtenlength &lt; 0)
		  curtenlength = 0LL;
	}
	return accnt;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;l, &amp;k);
	for (int i = 0; i &lt; l; ++i) 
	  scanf(&quot;%d&quot;, x + i);
	long long l = 1, r = 1LL &lt;&lt; 60, mid;
	while (l &lt;= r)
	  if (check(mid = (l + r) &gt;&gt; 1) &lt;= k)
		r = mid - 1;
	  else 
		l = mid + 1;
	if (check(r + 1) ^ k)
	  return puts(&quot;-1&quot;), 0;
	printf(&quot;%lld &quot;, r + 1);
	l = 1, r = 1LL &lt;&lt; 60;
	while (l &lt;= r)
	  if (check(mid = (l + r) &gt;&gt; 1) &gt;= k)
		l = mid + 1;
	  else
		r = mid - 1;
	printf(&quot;%lld\n&quot;, l - 1);
	return 0;
}<pre><h2>Problem4591</h2><pre>#include &lt;cstdio&gt;

#define mod 2333

int C[mod][mod], S[mod][mod];

int Lucas(long long n, long long k) {
	int ret = 1, _n, _k;
	while (n &amp;&amp; k) {
		_n = n % mod, _k = k % mod;
		if (_n &lt; _k)
		  return 0;
		ret = ret * C[_n][_k] % mod;
		n /= mod, k /= mod;
	}
	return ret;
}

int Cal(long long n, long long k) {
	if (k &lt; 0)
	  return 0;
	if (k &lt; 1)
	  return 1;
	long long _n = n / mod, _k = k / mod;
	int s1 = Cal(_n, _k - 1);
	int s2 = s1 + Lucas(_n, _k);
	if (s2 &gt;= mod)
	  s2 -= mod;
	return (S[n % mod][k % mod] * s2 % mod + (S[n % mod][mod - 1] - S[n % mod][k % mod] + mod) * s1 % mod + mod) % mod;
}

int main() {
	unsigned int _;
	long long k, n;
	C[0][0] = 1;
	for (int i = 1; i &lt; mod; ++i) {
		C[i][0] = C[i][i] = 1;
		for (int j = 1; j &lt; i; ++j)
		  for (C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; C[i][j] &gt;= mod; C[i][j] -= mod);
	}

	for (int i = 0; i &lt; mod; ++i) {
		S[i][0] = 1;
		for (int j = 1; j &lt; mod; ++j)
		  for (S[i][j] = S[i][j - 1] + C[i][j]; S[i][j] &gt;= mod; S[i][j] -= mod);
	}

	scanf(&quot;%u&quot;, &amp;_);
	while (_--) {
		scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k);
		printf(&quot;%d\n&quot;, Cal(n, k));
	}
	return 0;
}<pre><h2>Problem4650</h2><pre>#include&lt;bits/stdc++.h&gt;
#define N 30005
#define M (l+r+1&gt;&gt;1)
using std::min;
const int m=1000000097;
int i,j,n,t,l,r,p,q;
int f[N],a[N],u[N],v[N];
char s[N];
int hash(int i,int j){
    return(f[j]-1ll*f[i]*a[j-i]%m+m)%m;
}
int main(){
    for(a[0]=i=1;i&lt;N;++i)
        a[i]=223ll*a[i-1]%m;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--){
        scanf(&quot;%s&quot;,s+1);
        n=strlen(s+1);
        for(i=1;i&lt;=n;++i){
            u[i]=v[i]=0;
            f[i]=(223ll*f[i-1]+s[i])%m;
        }
        for(i=1;i*2&lt;=n;++i)
            for(j=1;j+i&lt;=n;j+=i){
                l=0,r=min(i,j);
                while(r^l)
                    if(hash(j+i-M,j+i)==hash(j-M,j))
                        l=M;
                    else r=M-1;
                p=j-l+1;
                l=0,r=min(i-1,n-j-i);
                while(r^l)
                    if(hash(j+i,j+i+M)==hash(j,j+M))
                        l=M;
                    else r=M-1;
                q=j+l+1;
                if(p+i&lt;=q){
                    ++u[p],--v[q+i];
                    --u[q-i+1];
                    ++v[p+i*2-1];
                }
            }
        long long k=0;
        for(i=1;i&lt;=n;++i){
            u[i]+=u[i-1];
            v[i]+=v[i-1];
            k+=u[i]*v[i-1];
        }
        printf(&quot;%lld\n&quot;,k);
    }
}<pre><h2>Problem4650</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define N 30005
const int mo=1000000097;
char s[N];
int ha[N],p[N],f[N],g[N];
inline int hash(int l,int r){return(ha[r]-1LL*ha[l]*p[r-l]%mo+mo)%mo;}
inline int min(int a,int b){return a&lt;b?a:b;}
int main() {
	register int i,j,n,l,r,x,y,m;
	int t;
	register long long ans;
	for(*p=i=1;i^N;++i)p[i]=p[i-1]*223LL%mo;
	for(scanf(&quot;%d&quot;,&amp;t);t;--t) {
		scanf(&quot;%s&quot;,s+1);
		n=strlen(s+1);
		for(i=1;i&lt;=n;++i)
			f[i]=g[i]=0,ha[i]=(ha[i-1]*223LL+s[i])%mo;
		for(i=1;(i&lt;&lt;1)&lt;=n;++i)
			for(j=1;j+i&lt;=n;j+=i) {
				l=0,r=min(i,j);
				while(l^r)
					if(m=(l+r+1&gt;&gt;1),hash(j+i-m,j+i)==hash(j-m,j))
						l=m;
					else r=m-1;
				x=j-l+1;
				l=0,r=min(i-1,n-j-i);
				while(l^r)
					if(m=(l+r+1&gt;&gt;1),hash(j+i,j+i+m)==hash(j,j+m))
						l=m;
					else r=m-1;
				y=j+l+1;
				if(x+i&lt;=y) {
					++f[x],--f[y-i+1];
					++g[x+i*2-1],--g[y+i];
				}
			}
		ans=0;
		for(i=1;i&lt;=n;++i) {
			f[i]+=f[i-1];
			g[i]+=g[i-1];
			ans+=f[i]*g[i-1];
		}
		printf(&quot;%lld\n&quot;,ans);
	}
}
<pre><h2>Problem4650</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
typedef int arr[100005];
arr wa,wb,ws,wv,a,sa,rk,hi,st[20],lg,cnt;
char s[100005];
inline bool cmp(int*r,int i,int j,int l) {return r[i]==r[j]&amp;&amp;r[i+l]==r[j+l];}
inline int min(const int&amp;a,const int&amp;b) {return a&lt;b?a:b;}
inline void da(int n,int m) {
	static int i,j,p,*x=wa,*y=wb,*t;
	for(i=0;i&lt;m;++i)ws[i]=0;
	for(i=0;i&lt;n;++i)++ws[x[i]=a[i]];
	for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
	for(i=n-1;~i;--i)sa[--ws[x[i]]]=i;
	for(j=p=1;p&lt;n;j&lt;&lt;=1,m=p) {
		for(p=0,i=n-j;i&lt;n;++i)y[p++]=i;
		for(i=0;i&lt;n;++i)if(sa[i]&gt;=j)y[p++]=sa[i]-j;
		for(i=0;i&lt;m;++i)ws[i]=0;
		for(i=0;i&lt;n;++i)++ws[wv[i]=x[y[i]]];
		for(i=1;i&lt;m;++i)ws[i]+=ws[i-1];
		for(i=n-1;~i;--i)sa[--ws[wv[i]]]=y[i];
		for(t=x,x=y,y=t,p=i=1,x[sa[0]]=0;i&lt;n;++i)
			x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
	}
}
inline void ghi(int n) {
	int i,j,k;
	for(i=0;i&lt;n;++i)rk[sa[i]]=i;
	for(i=k=0;i&lt;n;hi[rk[i++]]=k)
		if(rk[i])for(k?--k:0,j=sa[rk[i]-1];a[j+k]==a[i+k];++k);
}
inline void initst(int n) {
	static int i,j;
	for(i=1;i&lt;n;++i)(*st)[i]=hi[i];
	for(i=1;i&lt;=lg[n];++i)
		for(j=1;j+(1&lt;&lt;i)-1&lt;n;++j)
			st[i][j]=min(st[i-1][j],st[i-1][j+(1&lt;&lt;i-1)]);
}
inline int ask(int i,int j) {
	i=rk[i],j=rk[j];
	if(j&lt;i)i^=j^=i^=j; ++i;
	int t=lg[j-i+1];
	return min(st[t][i],st[t][j-(1&lt;&lt;t)+1]);
}
int main() {
	int i,j,__,n,len,t1,t2;
	long long ans;
	for(i=2;i&lt;60005;++i)lg[i]=lg[i&gt;&gt;1]+1;
	scanf(&quot;%d&quot;,&amp;__);
	while(__--) {
		scanf(&quot;%s&quot;,s);
		memset(a,0,sizeof a);
		memset(wa,0,sizeof wa);
		memset(wb,0,sizeof wb);
		memset(cnt,0,sizeof cnt);
		for(n=0;s[n];++n)a[n]=s[n]-'a'+2;
		for(i=0;i&lt;n;++i)a[n+i+1]=a[n-i-1];
		a[len=n]=1; n=n&lt;&lt;1|1;
		da(n,30); ghi(n); initst(n);
		for(i=1;i&lt;=len;++i)
			for(j=0;j+i&lt;n;j+=i)
				if(a[j]==a[j+i]) {
					t1=min(ask(j,j+i),i),t2=min(ask(n-i-j-1,n-j-1),i);
					if(t1+t2&lt;=i) continue;
					++cnt[j-t2+1];--cnt[j+t1-i+1];
				}
		for(i=1;i&lt;n;++i)cnt[i]+=cnt[i-1];
		ans=0;
		for(i=1;i&lt;len-1;++i)ans+=(long long)cnt[i]*cnt[n-i];
		printf(&quot;%lld\n&quot;,ans);
	}
	return 0;
}<pre><h2>Problem4719</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
#define N 300000
struct edge{int to;edge*nt;}ME[N&lt;&lt;1],*ce=ME,*hd[N];
inline void adde(int a,int b) {ce-&gt;to=b,ce-&gt;nt=hd[a],hd[a]=ce++;}
struct LcaQuery{int id;LcaQuery*nt;}MQ[N&lt;&lt;1],*cq=MQ,*hq[N];
inline void AddLcaQuery(int a,int b) {cq-&gt;id=b,cq-&gt;nt=hq[a],hq[a]=cq++;}
struct Operator{int to;Operator*nt;}MO[N&lt;&lt;1],*co=MO,*h1[N],*h2[N];
inline void AddOperator(int a,int b,Operator**ho) {co-&gt;to=b,co-&gt;nt=ho[a],ho[a]=co++;}
typedef int arr[N];
arr f,w,s,t,lca,dep,ans,val,dis;
int count[N&lt;&lt;1],n,m;
bool vis[N];
inline int gf(int u) {
	int r=u;
	while(f[r]^r)r=f[r];
	for(int t;u^r;t=f[u],f[u]=r,u=t);
	return r;
}
void tarjan(int u) {
	f[u]=u; vis[u]=true;
	for(LcaQuery*it=hq[u];it;it=it-&gt;nt) {
		int id=it-&gt;id;
		if(u==s[id]&amp;&amp;vis[t[id]])lca[id]=gf(t[id]);
		if(u==t[id]&amp;&amp;vis[s[id]])lca[id]=gf(s[id]);
	}
	for(edge*it=hd[u];it;it=it-&gt;nt)
		if(!vis[it-&gt;to]) dep[it-&gt;to]=dep[u]+1,tarjan(it-&gt;to),f[it-&gt;to]=u;
}
void dfs1(int u,int fa) {
	int t1=w[u]+dep[u],t2=count[t1];
	for(edge*it=hd[u];it;it=it-&gt;nt)
		if(it-&gt;to^fa)dfs1(it-&gt;to,u);
	count[dep[u]]+=val[u];
	ans[u]=count[t1]-t2;
	for(Operator*it=h1[u];it;it=it-&gt;nt)--count[it-&gt;to];
}
void dfs2(int u,int fa) {
	int t1=dep[u]-w[u]+N,t2=count[t1];
	for(edge*it=hd[u];it;it=it-&gt;nt)
		if(it-&gt;to^fa)dfs2(it-&gt;to,u);
	for(Operator*it=h1[u];it;it=it-&gt;nt)++count[N+it-&gt;to];
	ans[u]+=count[t1]-t2;
	for(Operator*it=h2[u];it;it=it-&gt;nt)--count[N+it-&gt;to];
}
int main() {
	int i,j,u,v;
	n=gi(),m=gi();
	for(i=1;i&lt;n;++i) adde(u=gi(),v=gi()),adde(v,u);
	for(i=1;i&lt;=n;++i)w[i]=gi();
	for(i=1;i&lt;=m;++i) {
		s[i]=gi(),t[i]=gi();
		AddLcaQuery(s[i],i);
		AddLcaQuery(t[i],i);
	}
	dep[1]=1;
	tarjan(1);
	for(i=1;i&lt;=m;++i) {
		++val[s[i]];
		dis[i]=dep[s[i]]+dep[t[i]]-2*dep[lca[i]];
		AddOperator(lca[i],dep[s[i]],h1);
	}
	dfs1(1,0);
	memset(count,0,sizeof count);
	memset(h1,0,sizeof h1);
	co=MO;
	for(i=1;i&lt;=m;++i) {
		AddOperator(t[i],dep[t[i]]-dis[i],h1);
		AddOperator(lca[i],dep[t[i]]-dis[i],h2);
	}
	dfs2(1,0);
	for(i=1;i&lt;=m;++i)if(dep[s[i]]-dep[lca[i]]==w[lca[i]])--ans[lca[i]];
	printf(&quot;%d&quot;,ans[1]);
	for(i=2;i&lt;=n;++i)printf(&quot; %d&quot;,ans[i]);
	return 0;
}
<pre><h2>Problem4720</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
template&lt;class data&gt;data min(const data&amp;a,const data&amp;b){return a&lt;b?a:b;}
inline int gi() {
	static int a; static char c;
	while(c=getchar(),c&lt;'0');a=c-'0';
	while(c=getchar(),'-'&lt;c)a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0';
	return a;
}
double f[2005][2005],g[2005][2005],p[2005];
int dis[302][302],c[2005],d[2005];
//f chose ; g don't chose
int main() {
	int n=gi(),m=gi(),v=gi(),e=gi();
	for(int i=1;i&lt;=n;++i)c[i]=gi();
	for(int i=1;i&lt;=n;++i)d[i]=gi();
	for(int i=1;i&lt;=n;++i)scanf(&quot;%lf&quot;,p+i);
	for(int i=1;i&lt;=v;++i)
		for(int j=1;j&lt;=v;++j)
			dis[i][j]=(i==j)?0:0x3f3f3f3f;
	for(int x,y,z;e;--e) {
		x=gi(),y=gi(),z=gi();
		if(z&gt;=dis[x][y]) continue;
		dis[x][y]=dis[y][x]=z;
	}
	for(int k=1;k&lt;=v;++k)
		for(int i=1;i&lt;=v;++i)
			for(int j=1;j&lt;=v;++j)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	for(int i=0;i&lt;=n;++i)
		for(int j=0;j&lt;=m;++j)
			f[i][j]=g[i][j]=1e9;
	f[1][1]=g[1][0]=0;
	for(int i=2;i&lt;=n;++i) {
		int lim=min(i,m)+1;
		g[i][0]=g[i-1][0]+dis[c[i-1]][c[i]];
		for(int j=1;j&lt;lim;++j) {
			g[i][j]=min(g[i-1][j]+dis[c[i-1]][c[i]],
						f[i-1][j]+dis[d[i-1]][c[i]]*p[i-1]+dis[c[i-1]][c[i]]*(1-p[i-1]));
			f[i][j]=min(g[i-1][j-1]+dis[c[i-1]][c[i]]*(1-p[i])+dis[c[i-1]][d[i]]*p[i],
						f[i-1][j-1]+dis[c[i-1]][c[i]]*(1-p[i])*(1-p[i-1])+
						dis[c[i-1]][d[i]]*(1-p[i-1])*p[i]+dis[d[i-1]][c[i]]*p[i-1]*(1-p[i])
						+dis[d[i-1]][d[i]]*p[i-1]*p[i]);
		}
	}
	double ans=1e9;
	for(int i=0;i&lt;=m;++i)
		ans=min(ans,min(f[n][i],g[n][i]));
	printf(&quot;%.2lf\n&quot;,ans);
	return 0;
}
<pre><h2>Problem4721</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
typedef int arr[7000010];
int a[100010],n,m,q,u,v,t;
arr x,y,z;
//p=u/v;
int main() {
	register int i,mx,type,delta=0;
	int *xl,*xr,*yl,*yr,*zl,*zr;
	scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t);
	for(i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i);
	std::sort(a+1,a+n+1);
	xl=xr=x;
	yl=yr=y;
	zl=zr=z;
	for(i=n;i;--i)*xr++=a[i];
	for(i=1;i&lt;=m;++i) {
		mx=-2147483647;
		if(xl&lt;xr&amp;&amp;mx&lt;*xl)mx=*xl,type=1;
		if(yl&lt;yr&amp;&amp;mx&lt;*yl)mx=*yl,type=2;
		if(zl&lt;zr&amp;&amp;mx&lt;*zl)mx=*zl,type=3;
		if(type&lt;2)++xl;
		else if(type^3)++yl;
		else ++zl;
		mx+=delta; delta+=q;
		if(i%t==0)printf(i+t&gt;m?&quot;%d&quot;:&quot;%d &quot;,mx);
		type=(long long)mx*u/v;
		*yr++=type-delta,*zr++=mx-type-delta;
	}
	puts(&quot;&quot;);
	for(i=1;i&lt;=n+m;++i) {
		mx=-2147483647;
		if(xl&lt;xr&amp;&amp;mx&lt;*xl)mx=*xl,type=1;
		if(yl&lt;yr&amp;&amp;mx&lt;*yl)mx=*yl,type=2;
		if(zl&lt;zr&amp;&amp;mx&lt;*zl)mx=*zl,type=3;
		if(type&lt;2)++xl;
		else if(type^3)++yl;
		else ++zl;
		if(i%t==0) printf(i+t&gt;n+m?&quot;%d&quot;:&quot;%d &quot;,mx+delta);
	}
	return 0;
}<pre><h2>Problem4722</h2><pre>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define V 1003
#define N 100003
#define MaxS 10360
int C[N], p[17][N], a[N];
int main() {
	int n, m, v, i, j, x, lg, lim, opt, l, r, t;
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;v);
	for (lim = 0; (1 &lt;&lt; lim) &lt;= v; ++lim);
	for (lg = 0; (1 &lt;&lt; lg) &lt;= m; ++lg);
	for (i = 1; i &lt;= n; ++i)
		scanf(&quot;%d&quot;, a + i);
	for (i = 0; i &lt; v; ++i)
		p[0][i] = (long long)i * i * i % v;
	for (i = 1; i &lt; lg; ++i)
		for (j = 0; j &lt; v; ++j)
			p[i][j] = p[i - 1][p[i - 1][j]];
	while (m--) {
		scanf(&quot;%d%d%d&quot;, &amp;opt, &amp;l, &amp;r);
		if (opt &amp; 1) {
			if (r - l &gt;= lim) puts(&quot;Yuno&quot;);
			else {
				bitset&lt;MaxS&gt;s(1U);
				for (i = l; i &lt;= r; ++i) {
					x = a[i], t = 0;
					for (j = i; j; j ^= j &amp; -j)
						t += C[j];
					for (j = 0; j &lt; lg; ++j)
						if (t &gt;&gt; j &amp; 1) x = p[j][x];
					++x;
					if ((s &amp; s &lt;&lt; x).any()) {
						puts(&quot;Yuno&quot;);
						goto ANS;
					}
					s |= s &lt;&lt; x;
				}
				puts(&quot;Yuki&quot;);
			ANS:;
				}
		} else {
			for (i = l; i &lt;= n; i += i &amp; -i) ++C[i];
			for (i = r + 1; i &lt;= n; i += i &amp; -i) --C[i];
		}
	}
	return 0;
}<pre><h2>Problem4762</h2><pre>#include &lt;cstdio&gt;
int main() {
	static int n, x, dp[1025][1025], mod = 1e9 + 7;
	scanf(&quot;%d&quot;, &amp;n);
	dp[0][0] = 1;
	for (register int _ = 0; _ &lt; n; ++_) {
		scanf(&quot;%d&quot;, &amp;x);
		x ^= 1023;
		for (register int i = 1023, ti, tj, unt; ~i; --i)
			if (unt = (ti = x | i) ^ i) {
				for (register int j = i; ; (--j) &amp;= i) {
					tj = j - (j &amp; x);
					dp[ti][tj] += dp[i][j];
					dp[ti][tj|unt] -= dp[i][j];
					if (dp[ti][tj] &gt;= mod) dp[ti][tj] -= mod;
					if (dp[ti][tj|unt] &lt; 0) dp[ti][tj|unt] += mod;
					if (!j) break;
				}
			}
	}
	printf(&quot;%d\n&quot;, dp[1023][0]);
	return 0;
}<pre><h2>Problem4762</h2><pre>#include &lt;cstdio&gt;
inline void gi(int &amp;a) {
	register char c;
	do c = getchar_unlocked(); while (c &lt; 48);
	a = c - 48;
	while (47 &lt; (c = getchar_unlocked())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48;
}
int main() {
	static int n, x, dp[1025][1025], mod = 1e9 + 7;
	gi(n);
	dp[0][0] = 1;
	while (n--) {
		gi(x);
		x ^= 1023;
		for (register int i = 1023, ti, tj, unt; ~i; --i)
			if (unt = (ti = x | i) ^ i) {
				for (register int j = i; ; (--j) &amp;= i) {
					tj = j - (j &amp; x);
					dp[ti][tj] += dp[i][j];
					dp[ti][tj|unt] -= dp[i][j];
					if (dp[ti][tj] &gt;= mod) dp[ti][tj] -= mod;
					if (dp[ti][tj|unt] &lt; 0) dp[ti][tj|unt] += mod;
					if (!j) break;
				}
			}
	}
	printf(&quot;%d\n&quot;, dp[1023][0]);
	return 0;
}<pre><h2>Problem4763</h2><pre>#include &lt;cstdio&gt;

const int maxr(325), maxn(1e5 + 7);
typedef int arr[maxn];

inline int rd() {
    static int r = 19260817;
    return r = (r * 69069LL + 1) &amp; (~0U &gt;&gt; 1);
}

struct bitset {
    int max;
    unsigned long long a[469];
    inline void clear() {
        for (register int i = 0; i &lt;= max; ++i)
            a[i] = 0ULL;
        max = 0;
    }
    inline void operator |= (const bitset &amp;lambda) {
        if (lambda.max &gt; max)
            max = lambda.max;
        for (register int i = 0; i &lt;= max; ++i)
            a[i] |= lambda.a[i];
    }
    inline void operator |= (const int &amp;lambda) {
        a[lambda &gt;&gt; 6] |= 1ULL &lt;&lt; (lambda &amp; 63);
        if ((lambda &gt;&gt; 6) &gt; max)
            max = lambda &gt;&gt; 6;
    }
    inline int count(unsigned long long x) const {
        int ret = 0;
        for (; x; x &amp;= x - 1)
            ++ret;
        return ret;
    }
    inline int count() const {
        int ret = 0;
        for (register int i = 0; i &lt;= max; ++i)
            ret += count(a[i]);
        return ret;
    }
    inline int mex() const {
        for (register int i = 0; i &lt;= max; ++i)
            if (count(a[i]) &lt; 64) {
                for (register int j = 0; j &lt; 64; ++j)
                    if (~a[i] &gt;&gt; j &amp; 1)
                        return (i &lt;&lt; 6) | j;
            }
        return (max + 1) &lt;&lt; 6;
    }
} temp, pre[maxr][maxr];

struct edge {
    int to;
    edge *nxt;
} *g[maxn];

inline void add_edge(int u, int v) {
    static edge edge_mest[maxn * 2], *cedge = edge_mest;
    *cedge = (edge) {v, g[u]};
    g[u] = cedge++;
}

arr dep, top, fa, son, size;

void d1(int u) {
    size[u] = 1;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if (it-&gt;to ^ fa[u]) {
            fa[it-&gt;to] = u;
            dep[it-&gt;to] = dep[u] + 1;
            d1(it-&gt;to);
            if (size[it-&gt;to] &gt; size[son[u]])
                son[u] = it-&gt;to;
            size[u] += size[it-&gt;to];
        }
}

void d2(int u, int anc) {
    top[u] = anc;
    if (son[u]) d2(son[u], anc);
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if (!top[it-&gt;to]) d2(it-&gt;to, it-&gt;to);
}

inline int lca(int u, int v) {
    while (top[u] ^ top[v]) dep[top[u]] &lt; dep[top[v]] ? v = fa[top[v]] : u = fa[top[u]];
    return dep[u] &lt; dep[v] ? u : v;
}

inline void swap(int &amp;a, int &amp;b) {
    a ^= b ^= a ^= b;
}

arr val, tag, rand_arr, up;

int main() {

#ifndef ONLINE_JUDGE
    freopen(&quot;xuehui.in&quot;, &quot;r&quot;, stdin);
#endif

    int n, m, f, lastans = 0, u, v, t, rand_num, a, anc;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;f);

    for (register int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, val + i);

    for (register int i = 1; i &lt;  n; ++i) {
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        add_edge(u, v);
        add_edge(v, u);
    }


    dep[1] = 1;
    d1(1);
    d2(1, 1);

    rand_num = n &lt; 320 ? n : 320;
    for (register int i = 1; i &lt;= n; ++i) rand_arr[i] = i;
    for (register int i = 1; i &lt;= n; ++i) swap(rand_arr[rd() % n + 1], rand_arr[rd() % n + 1]);
    for (register int i = 1; i &lt;= rand_num; ++i) tag[rand_arr[i]] = i;

    for (register int i = 1; i &lt;= rand_num; ++i) {
        u = rand_arr[i];
        temp.clear();
        while (u) {
            temp |= val[u];
            if (u != rand_arr[i] &amp;&amp; tag[u]) {
                pre[i][tag[u]] = temp;
                if (!up[rand_arr[i]])
                    up[rand_arr[i]] = u;
            }
            u = fa[u];
        }
    }

    while (m--) {
        scanf(&quot;%d&quot;, &amp;a);
        temp.clear();
        while (a--) {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            if (f) u ^= lastans, v ^= lastans;
            anc = lca(u, v);
            temp |= val[anc];
            for (; !tag[u] &amp;&amp; u != anc; u = fa[u])
                temp |= val[u];
            t = u;
            while (dep[up[u]] &gt;= dep[anc])
                u = up[u];
            temp |= pre[tag[t]][tag[u]];
            for (; u != anc; u = fa[u])
                temp |= val[u];

            for (; !tag[v] &amp;&amp; v != anc; v = fa[v])
                temp |= val[v];
            t = v;
            while (dep[up[v]] &gt;= dep[anc])
                v = up[v];
            temp |= pre[tag[t]][tag[v]];
            for (; v != anc; v = fa[v])
                temp |= val[v];

            //t = temp.count();
            //lastans = temp.mex();
            //printf(&quot;%d %d\n&quot;, t, lastans);
            //lastans += t;
        }
        t = temp.count();
        lastans = temp.mex();
        printf(&quot;%d %d\n&quot;, t, lastans);
        lastans += t;
    }

    return 0;
}<pre><h2>Problem4763</h2><pre>#include &lt;cstdio&gt;

const int maxr(325), maxn(1e5 + 7);
typedef int arr[maxn];

inline int rd() {
    static int r = 19260817;
    return r = (r * 69069LL + 1) &amp; (~0U &gt;&gt; 1);
}

struct bitset {
    int max;
    unsigned long long a[469];
    inline void clear() {
        for (register int i = 0; i &lt;= max; ++i)
            a[i] = 0ULL;
        max = 0;
    }
    inline void operator |= (const bitset &amp;lambda) {
        if (lambda.max &gt; max)
            max = lambda.max;
        for (register int i = 0; i &lt;= max; ++i)
            a[i] |= lambda.a[i];
    }
    inline void operator |= (const int &amp;lambda) {
        a[lambda &gt;&gt; 6] |= 1ULL &lt;&lt; (lambda &amp; 63);
        if ((lambda &gt;&gt; 6) &gt; max)
            max = lambda &gt;&gt; 6;
    }
    inline int count(unsigned long long x) const {
        int ret = 0;
        for (; x; x &amp;= x - 1)
            ++ret;
        return ret;
    }
    inline int count() const {
        int ret = 0;
        for (register int i = 0; i &lt;= max; ++i)
            ret += count(a[i]);
        return ret;
    }
    inline int mex() const {
        for (register int i = 0; i &lt;= max; ++i)
            if (count(a[i]) &lt; 64) {
                for (register int j = 0; j &lt; 64; ++j)
                    if (~a[i] &gt;&gt; j &amp; 1)
                        return (i &lt;&lt; 6) | j;
            }
        return (max + 1) &lt;&lt; 6;
    }
} temp, pre[maxr][maxr];

struct edge {
    int to;
    edge *nxt;
} *g[maxn];

inline void add_edge(int u, int v) {
    static edge edge_mest[maxn * 2], *cedge = edge_mest;
    *cedge = (edge) {v, g[u]};
    g[u] = cedge++;
}

arr dep, top, fa, son, size;

void d1(int u) {
    size[u] = 1;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if (it-&gt;to ^ fa[u]) {
            fa[it-&gt;to] = u;
            dep[it-&gt;to] = dep[u] + 1;
            d1(it-&gt;to);
            if (size[it-&gt;to] &gt; size[son[u]])
                son[u] = it-&gt;to;
            size[u] += size[it-&gt;to];
        }
}

void d2(int u, int anc) {
    top[u] = anc;
    if (son[u]) d2(son[u], anc);
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if (!top[it-&gt;to]) d2(it-&gt;to, it-&gt;to);
}

inline int lca(int u, int v) {
    while (top[u] ^ top[v]) dep[top[u]] &lt; dep[top[v]] ? v = fa[top[v]] : u = fa[top[u]];
    return dep[u] &lt; dep[v] ? u : v;
}

inline void swap(int &amp;a, int &amp;b) {
    a ^= b ^= a ^= b;
}

arr val, tag, rand_arr, up;

int main() {

#ifndef ONLINE_JUDGE
    freopen(&quot;xuehui.in&quot;, &quot;r&quot;, stdin);
#endif

    int n, m, f, lastans = 0, u, v, t, rand_num, a, anc;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;f);

    for (register int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, val + i);

    for (register int i = 1; i &lt;  n; ++i) {
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        add_edge(u, v);
        add_edge(v, u);
    }


    dep[1] = 1;
    d1(1);
    d2(1, 1);

    t = n &gt;&gt; 1;
    for (register int i = 1; i &lt;= n; ++i) rand_arr[i] = i;
    for (rand_num = 1; rand_num * rand_num &lt;= n; ++rand_num);
    for (register int i = 1; i &lt;= t; ++i) swap(rand_arr[rd() % n + 1], rand_arr[rd() % n + 1]);
    for (register int i = 1; i &lt;= rand_num; ++i) tag[rand_arr[i]] = i;

    for (register int i = 1; i &lt;= rand_num; ++i) {
        u = rand_arr[i];
        temp.clear();
        while (u) {
            temp |= val[u];
            if (u != rand_arr[i] &amp;&amp; tag[u]) {
                pre[i][tag[u]] = temp;
                if (!up[rand_arr[i]])
                    up[rand_arr[i]] = u;
            }
            u = fa[u];
        }
    }

    while (m--) {
        scanf(&quot;%d&quot;, &amp;a);
        temp.clear();
        while (a--) {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            if (f) u ^= lastans, v ^= lastans;
            anc = lca(u, v);
            temp |= val[anc];
            for (; !tag[u] &amp;&amp; u != anc; u = fa[u])
                temp |= val[u];
            t = u;
            while (dep[up[u]] &gt;= dep[anc])
                u = up[u];
            temp |= pre[tag[t]][tag[u]];
            for (; u != anc; u = fa[u])
                temp |= val[u];

            for (; !tag[v] &amp;&amp; v != anc; v = fa[v])
                temp |= val[v];
            t = v;
            while (dep[up[v]] &gt;= dep[anc])
                v = up[v];
            temp |= pre[tag[t]][tag[v]];
            for (; v != anc; v = fa[v])
                temp |= val[v];
        }
        t = temp.count();
        lastans = temp.mex();
        printf(&quot;%d %d\n&quot;, t, lastans);
        lastans += t;
    }

    return 0;
}<pre><h2>Problem4763</h2><pre>#include &lt;cstdio&gt;

const int maxr(325), maxn(1e5 + 7);
typedef int arr[maxn];

inline int rd() {
    static int r = 19260817;
    return r = (r * 69069LL + 1) &amp; (~0U &gt;&gt; 1);
}

struct bitset {
    int max;
    unsigned long long a[469];
    inline void clear() {
        for (register int i = 0; i &lt;= max; ++i)
            a[i] = 0ULL;
        max = 0;
    }
    inline void operator |= (const bitset &amp;lambda) {
        if (lambda.max &gt; max)
            max = lambda.max;
        for (register int i = 0; i &lt;= max; ++i)
            a[i] |= lambda.a[i];
    }
    inline void operator |= (const int &amp;lambda) {
        a[lambda &gt;&gt; 6] |= 1ULL &lt;&lt; (lambda &amp; 63);
        if ((lambda &gt;&gt; 6) &gt; max)
            max = lambda &gt;&gt; 6;
    }
    inline int count(unsigned long long x) const {
        int ret = 0;
        for (; x; x &amp;= x - 1)
            ++ret;
        return ret;
    }
    inline int count() const {
        int ret = 0;
        for (register int i = 0; i &lt;= max; ++i)
            ret += count(a[i]);
        return ret;
    }
    inline int mex() const {
        for (register int i = 0; i &lt;= max; ++i)
            if (count(a[i]) &lt; 64) {
                for (register int j = 0; j &lt; 64; ++j)
                    if (~a[i] &gt;&gt; j &amp; 1)
                        return (i &lt;&lt; 6) | j;
            }
        return (max + 1) &lt;&lt; 6;
    }
} temp, pre[maxr][maxr];

struct edge {
    int to;
    edge *nxt;
} *g[maxn];

inline void add_edge(int u, int v) {
    static edge edge_mest[maxn * 2], *cedge = edge_mest;
    *cedge = (edge) {v, g[u]};
    g[u] = cedge++;
}

arr dep, top, fa, son, size;

void d1(int u) {
    size[u] = 1;
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if (it-&gt;to ^ fa[u]) {
            fa[it-&gt;to] = u;
            dep[it-&gt;to] = dep[u] + 1;
            d1(it-&gt;to);
            if (size[it-&gt;to] &gt; size[son[u]])
                son[u] = it-&gt;to;
            size[u] += size[it-&gt;to];
        }
}

void d2(int u, int anc) {
    top[u] = anc;
    if (son[u]) d2(son[u], anc);
    for (edge *it = g[u]; it; it = it-&gt;nxt)
        if (!top[it-&gt;to]) d2(it-&gt;to, it-&gt;to);
}

inline int lca(int u, int v) {
    while (top[u] ^ top[v]) dep[top[u]] &lt; dep[top[v]] ? v = fa[top[v]] : u = fa[top[u]];
    return dep[u] &lt; dep[v] ? u : v;
}

inline void swap(int &amp;a, int &amp;b) {
    a ^= b ^= a ^= b;
}

arr val, tag, rand_arr, up;

int main() {

#ifndef ONLINE_JUDGE
    freopen(&quot;xuehui.in&quot;, &quot;r&quot;, stdin);
#endif

    int n, m, f, lastans = 0, u, v, t, rand_num, a, anc;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;f);

    for (register int i = 1; i &lt;= n; ++i)
        scanf(&quot;%d&quot;, val + i);

    for (register int i = 1; i &lt;  n; ++i) {
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        add_edge(u, v);
        add_edge(v, u);
    }


    dep[1] = 1;
    d1(1);
    d2(1, 1);

    for (register int i = 1; i &lt;= n; ++i) rand_arr[i] = i;
    for (rand_num = 1; rand_num * rand_num &lt;= n; ++rand_num);
    for (register int i = 1; i &lt;= n; ++i) swap(rand_arr[rd() % n + 1], rand_arr[rd() % n + 1]);
    for (register int i = 1; i &lt;= rand_num; ++i) tag[rand_arr[i]] = i;

    for (register int i = 1; i &lt;= rand_num; ++i) {
        u = rand_arr[i];
        temp.clear();
        while (u) {
            temp |= val[u];
            if (u != rand_arr[i] &amp;&amp; tag[u]) {
                pre[i][tag[u]] = temp;
                if (!up[rand_arr[i]])
                    up[rand_arr[i]] = u;
            }
            u = fa[u];
        }
    }

    while (m--) {
        scanf(&quot;%d&quot;, &amp;a);
        temp.clear();
        while (a--) {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            if (f) u ^= lastans, v ^= lastans;
            anc = lca(u, v);
            temp |= val[anc];
            for (; !tag[u] &amp;&amp; u != anc; u = fa[u])
                temp |= val[u];
            t = u;
            while (dep[up[u]] &gt;= dep[anc])
                u = up[u];
            temp |= pre[tag[t]][tag[u]];
            for (; u != anc; u = fa[u])
                temp |= val[u];

            for (; !tag[v] &amp;&amp; v != anc; v = fa[v])
                temp |= val[v];
            t = v;
            while (dep[up[v]] &gt;= dep[anc])
                v = up[v];
            temp |= pre[tag[t]][tag[v]];
            for (; v != anc; v = fa[v])
                temp |= val[v];
        }
        t = temp.count();
        lastans = temp.mex();
        printf(&quot;%d %d\n&quot;, t, lastans);
        lastans += t;
    }

    return 0;
}<pre><h2>Problem4763</h2><pre>program Mirai_Nikki;
const
   MxDword=65535;
type
   Table=object
   e:longint;
   head:array[0..100005]of longint;
   next,node:array[0..200005]of longint;
procedure ad(u,v:longint);
end;

procedure Table.ad(u,v:longint);
begin
   inc(e);
   next[e]:=head[u];
   head[u]:=e;
   node[e]:=v
end;

var
   n,m,Dues,i,j,u,v,tim,blo,blonum,a,Knd,Mex,LastAns:longint;
   MxQword:qword;
   Sz:array[0..65536]of longint;
   c,d,fa,dfn,iskey:array[0..100005]of longint;
   key,key_fa:array[0..355]of longint;
   h:array[0..200005]of longint;
   z:array[0..17,0..200005]of longint;
   Tr:Table;

type
   Bit=object
   a:array[0..470]of qword;
procedure clear;
   procedure pt(x:longint);
      function siz(const x:qword):longint;
         function knd:longint;
            function mex:longint;
            end;

            procedure Bit.clear;
            begin
               fillchar(a,sizeof(a),0)
            end;

            procedure Bit.pt(x:longint);
            begin
               a[x&gt;&gt;6]:=a[x&gt;&gt;6]or(qword(1)&lt;&lt;(x and 63))
            end;

            function Bit.siz(const x:qword):longint;
            begin
               exit(sz[x and MxDword]+sz[(x&gt;&gt;16)and MxDword]+sz[(x&gt;&gt;32)and MxDword]+sz[x&gt;&gt;48])
            end;

            function Bit.knd:longint;
            var i:longint;
            begin
               knd:=0;
               for i:=0 to 469 do inc(knd,siz(a[i]))
            end;

            function Bit.mex:longint;
            var i,j:longint;
            begin
               for i:=0 to 469 do if a[i]&lt;&gt;MxQword then
                  for j:=0 to 63 do if a[i]or(qword(1)&lt;&lt;j)&lt;&gt;a[i] then exit(i&lt;&lt;6+j)
            end;

         operator or(const a,b:Bit)c:Bit;
         var i:longint;
         begin
            for i:=0 to 469 do c.a[i]:=a.a[i]or b.a[i]
         end;

      var
         f:array[0..355,0..355]of Bit;
         tmp:Bit;
         pb:^Bit;

         function max(a,b:longint):longint;
         begin if a&gt;b then exit(a); exit(b) end;

         function sk(u:longint):longint;
         var i,v:longint;
         begin
            sk:=0;
            inc(tim);
            z[0,tim]:=u;
            dfn[u]:=tim;
            i:=Tr.head[u];
            while i&lt;&gt;0 do
            begin
               v:=Tr.node[i];
               if dfn[v]=0 then
               begin
                  fa[v]:=u;
                  d[v]:=d[u]+1;
                  sk:=max(sk,sk(v));
                  inc(tim);
                  z[0,tim]:=u
               end;
               i:=Tr.next[i]
            end;
            if (u=1)or(sk&lt;blo) then exit(sk+1);
            inc(blonum);
            key[blonum]:=u;
            iskey[u]:=blonum;
            exit(0)
         end;

         function lw(x,y:longint):longint;
         begin if d[x]&lt;d[y] then exit(x); exit(y) end;

         procedure st;
         var i,j:longint;
         begin
            for i:=2 to tim do h[i]:=h[i&gt;&gt;1]+1;
            for j:=1 to 17 do
               for i:=1 to tim-1&lt;&lt;j+1 do z[j,i]:=lw(z[j-1,i],z[j-1,i+1&lt;&lt;(j-1)])
         end;

         procedure sw(var a,b:longint);
         var c:longint; begin c:=a; a:=b; b:=c end;

         function lca(u,v:longint):longint;
         var w:longint;
         begin
            u:=dfn[u]; v:=dfn[v]; if u&gt;v then sw(u,v); w:=h[v-u+1];
            exit(lw(z[w,u],z[w,v-1&lt;&lt;w+1]))
         end;

         procedure qs(l,r:longint);
         var i,j,m:longint;
         begin
            i:=l; j:=r; m:=dfn[key[(l+r)&gt;&gt;1]];
            repeat
               while dfn[key[i]]&lt;m do inc(i);
               while dfn[key[j]]&gt;m do dec(j);
               if i&lt;=j then begin sw(key[i],key[j]);
                  sw(iskey[key[i]],iskey[key[j]]); inc(i); dec(j) end
            until i&gt;j;
            if i&lt;r then qs(i,r);
            if l&lt;j then qs(l,j)
         end;

         procedure Chor(u,v:longint);
         var
            w:longint;

            procedure up(x:longint);
            var i,j,o:longint;
            begin
               while x&lt;&gt;w do
               begin
                  i:=iskey[x];
                  if i&lt;&gt;0 then
                  begin
                     j:=0;
                     o:=i;
                     while (o&lt;&gt;1)and(d[key[key_fa[o]]]&gt;=d[w]) do
                     begin
                        inc(j);
                        o:=key_fa[o]
                     end;
                     if j&gt;0 then
                     begin
                        Tmp:=Tmp or f[i,j];
                        x:=key[o];
                        if x=w then exit;
                     end
                  end;
                  Tmp.pt(c[x]);
                  x:=fa[x]
               end
            end;

         begin
            w:=lca(u,v);
            up(u);
            up(v);
            Tmp.pt(c[w])
         end;

      begin

         for i:=1 to 65535 do Sz[i]:=Sz[i xor(i and(-i))]+1;
         MxQword:=1; MxQword:=MxQword&lt;&lt;63; MxQword:=MxQword-1+MxQword;

         read(n,m,Dues);
         for i:=1 to n do read(c[i]);
         for i:=2 to n do
         begin
            read(u,v);
            Tr.ad(u,v);
            Tr.ad(v,u)
         end;
         blo:=trunc(sqrt(n))+1;
         blonum:=1;
         key[1]:=1;
         iskey[1]:=1;
         sk(1);
         st;
         qs(1,blonum);
         for i:=2 to blonum do
            for j:=i-1 downto 1 do
               if lca(key[i],key[j])=key[j] then begin key_fa[i]:=j; break end;
         for i:=2 to blonum do
            if key_fa[i]&lt;&gt;0 then
            begin
               pb:=@f[i,1];
               u:=key[i];
               v:=key[key_fa[i]];
               while u&lt;&gt;v do begin pb^.pt(c[u]); u:=fa[u] end; pb^.pt(c[u]);
               j:=1;
               v:=key_fa[i];
               while key_fa[v]&lt;&gt;0 do
               begin
                  inc(j);
                  f[i,j]:=f[i,j-1]or f[v,1];
                  v:=key_fa[v]
               end
            end;

         Knd:=0;
         Mex:=0;
         LastAns:=0;
         for i:=1 to m do
         begin
            tmp.Clear;
            read(a);
            for a:=1 to a do
            begin
               read(u,v);
               if Dues=1 then begin u:=u xor LastAns; v:=v xor LastAns end;
               Chor(u,v)
            end;
            Knd:=Tmp.knd;
            Mex:=Tmp.mex;
            writeln(Knd,' ',Mex);
            LastAns:=Knd+Mex
         end;

      end.<pre><h2>Problem4765</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MaxN(100005);
typedef unsigned long long ull;
struct FastInput {
	char b[5&lt;&lt;20], *s;
	FastInput() : s(b) {
		b[fread(b, 1, 5 &lt;&lt; 20, stdin)] = 0;
	}
	inline void gi(int &amp;a) {
		while (*s &lt; 48) ++s;
		a = *s++ - 48;
		while (47 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
	}
} io;
struct FastOutput {
	char bufout[3&lt;&lt;19], outtmp[50], *pout;
	FastOutput() : pout(bufout) {}
	inline void write() {
		*pout = 0;
		fwrite(bufout, sizeof(char), pout - bufout, stdout);
	}
#define out_char(c) *(pout++) = c
	inline void out_int(ull x) {
		if(!x) {
			out_char('0');
			return;
		}
		register int len = 0;
		while(x) {
			outtmp[len++] = x % 10 + 48;
			x /= 10;
		}
		for(--len; ~len; --len) out_char(outtmp[len]);
		out_char('\n');
	}
} op;
struct edge {
	int to;
	edge *nxt;
} edge_mset[MaxN &lt;&lt; 1], *cedge = edge_mset, *g[MaxN];
inline void add_edge(int u, int v) {
	*cedge = (edge) {v, g[u]};
	g[u] = cedge++;
}
ull s1[320], s2[320], s3[MaxN];
int a[MaxN], in[MaxN], ou[MaxN], d[320][MaxN], bel[MaxN], dq[MaxN];
#define sum(l, r) (s3[r] - ((bel[l - 1] ^ bel[l]) ? 0 : s3[l - 1]) + s2[bel[r] - 1] - s2[bel[l] - 1])
inline void dfs(int u) {
	static int dfn = 0;
	dq[in[u] = ++dfn] = u;
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if (!in[it-&gt;to]) dfs(it-&gt;to);
	ou[u] = dfn;
}
int main() {
	int n, m, a, b, type, blo, root;
	io.gi(n), io.gi(m);
	for (blo = 1; blo * blo &lt;= n; ++blo);
	for (register int i = 1; i &lt;= n; ++i) {
		io.gi(::a[i]);
		bel[i] = (i - 1) / blo + 1;
	}
	for (register int i = 0; i &lt; n; ++i) {
		io.gi(a), io.gi(b);
		if (a) {
			add_edge(a, b);
			add_edge(b, a);
		} else
			root = b;
	}
	dfs(root);
	a = bel[n] + 1;
	for (register int i = 1, j = 1; i &lt; a; ++i) {
		s2[i] += s2[i - 1];
		for (b = min(i * blo, n) + 1; j &lt; b; ++j) {
			++d[i][in[j]], --d[i][ou[j] + 1];
			s2[i] += (s3[j] = ::a[dq[j]]);
			s3[j] += (bel[j] ^ bel[j - 1]) ? 0 : s3[j - 1];
		}
		for (b = 1; b &lt;= n; ++b) s1[i] += (ull)(d[i][b] += d[i][b - 1]) * ::a[dq[b]];
	}
	while (m--) {
		io.gi(type), io.gi(a), io.gi(b);
		if (type &amp; 1) {
			static int delta;
			delta = b - ::a[a];
			::a[a] = b;
			for (register int i = 1; i &lt;= bel[n]; ++i) s1[i] += (ull)(d[i][in[a]]) * delta;
			for (register int i = bel[in[a]]; i &lt;= bel[n]; ++i) s2[i] += delta;
			for (register int i = in[a]; bel[i] == bel[in[a]]; ++i) s3[i] += delta;
		} else {
			static ull ans;
			ans = 0;
			if (bel[b] - bel[a] &lt;= 1)
				for (register int i = a; i &lt;= b; ++i)
					ans += sum(in[i], ou[i]);
			else {
				for (register int i = bel[a] + 1; i &lt; bel[b]; ++i)
					ans += s1[i];
				for (register int i = a; bel[i] == bel[a]; ++i)
					ans += sum(in[i], ou[i]);
				for (register int i = b; bel[i] == bel[b]; --i)
					ans += sum(in[i], ou[i]);
			}
			//printf(&quot;%llu\n&quot;, ans);
			op.out_int(ans);
		}
	}
	op.write();
	return 0;
}<pre><h2>Problem4765</h2><pre>#include&lt;bits/stdc++.h&gt;
#define K 317
#define N 100005
#define M 200005
using namespace std;
typedef unsigned long long ll;
struct graph{
	int nxt,to;
}e[M];
int g[N],f[N],n,m,cnt;
ll a[N];bool v[N];
ll tot[N][K],s_d[K&lt;&lt;1],s_n[K],key[N&lt;&lt;1];
int fro[N],beh[N],r_d,t_d=1,r_n,t_n;
int n_n[N],n_f[N],n_b[N];
struct FastInput {
    char b[5&lt;&lt;20], *s;
    FastInput() : s(b) {
        b[fread(b, 1, 5 &lt;&lt; 20, stdin)] = 0;
    }
	template&lt;class T&gt;
    inline void gi(T &amp;a) {
        while (*s &lt; 48) ++s;
        a = *s++ - 48;
        while (47 &lt; *s) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + *s++ - 48;
    }
} io;
inline void addedge(int x,int y){
	e[++cnt].nxt=g[x];g[x]=cnt;e[cnt].to=y;
}
inline void dfs(int u){
	int sta[N],top=0;
	cnt=0;v[u]=true;
	for(int i=g[u];i;i=e[i].nxt){
		v[e[i].to]=true;
		sta[++top]=e[i].to;
		++tot[e[i].to][n_n[e[i].to]];
	}
	while(top){
		u=sta[top];fro[u]=++cnt;
		if(v[e[g[u]].to]){
			beh[u]=++cnt;--top;
			while(f[u]){
				u=sta[top--];beh[u]=++cnt;
			}
		}
		else f[e[g[u]].to]=u;
		for(int i=g[u];i;i=e[i].nxt)
		  if(!v[e[i].to]){
			  v[e[i].to]=true;
			  sta[++top]=e[i].to;
			  for(int j=1;j&lt;=t_n;++j)
				tot[e[i].to][j]=tot[u][j];
			  ++tot[e[i].to][n_n[e[i].to]];
		  }
	}
}
inline void change(int u,ll k){
	a[u]+=k;
	for(int i=1;i&lt;=t_n;++i)
	  s_n[i]+=tot[u][i]*k;
	for(int i=1;i&lt;n_f[u];++i)
	  s_d[i]+=k;
	if(n_f[u]*r_d==fro[u])
	  s_d[n_f[u]]+=k;
	else for(int i=(n_f[u]-1)*r_d+1;i&lt;=fro[u];++i)
	  key[i]+=k;
}
inline void init(){
	//n=read();m=read();
	io.gi(n), io.gi(m);
	for(int i=1;i&lt;=n;++i)
	  //a[i]=read_ll();
	  io.gi(a[i]);
	for(int i=1,j,k;i&lt;=n;++i){
		//j=read();k=read();
		io.gi(j), io.gi(k);
		addedge(j,k);addedge(k,j);
	}
	r_n=sqrt(n);
	for(int i=1;i&lt;=n;i+=r_n){
		++t_n;
		for(int j=0;j&lt;r_n&amp;&amp;i+j&lt;=n;++j)
		  n_n[i+j]=t_n;
	}
	dfs(0);
	r_d=sqrt(n&lt;&lt;1);t_d=((n&lt;&lt;1)+r_d-1)/r_d;
	for(int i=1;i&lt;=n;++i){
		n_f[i]=(fro[i]+r_d-1)/r_d;
		n_b[i]=(beh[i]+r_d-1)/r_d;
	}
	for(int i=1;i&lt;=n;++i){
		a[0]=a[i];a[i]=0;change(i,a[0]);
	}
	int op,l,r,u;ll v,ans;
	while(m--){
		//op=read();
		io.gi(op);
		if(op==1){
			//u=read();v=read_ll();
			io.gi(u), io.gi(v);
			change(u,v-a[u]);
		}
		else{
			//l=read();r=read();ans=0;
			io.gi(l), io.gi(r);ans=0;
			if(n_n[l]!=n_n[r]){
				for(int i=n_n[l]+1;i&lt;n_n[r];++i)
				  ans+=s_n[i];
				if(l==(n_n[l]-1)*r_n+1) ans+=s_n[n_n[l]];
				else for(int i=n_n[l]*r_n;i&gt;=l;--i)
				  ans+=(s_d[n_f[i]]+key[fro[i]])-(s_d[n_b[i]]+key[beh[i]]);
				if(r==n_n[r]*r_n) ans+=s_n[n_n[r]];
				else for(int i=(n_n[r]-1)*r_n+1;i&lt;=r;++i)
				  ans+=(s_d[n_f[i]]+key[fro[i]])-(s_d[n_b[i]]+key[beh[i]]);
			}
			else{
				if(l==(n_n[l]-1)*r_n+1&amp;&amp;r==n_n[r]*r_n){
					ans=s_n[n_n[l]];
				}
				else for(int i=l;i&lt;=r;++i)
				  ans+=(s_d[n_f[i]]+key[fro[i]])-(s_d[n_b[i]]+key[beh[i]]);
			}
			printf(&quot;%llu\n&quot;,ans);
		}
	}
}
int main(){
	init();
	return 0;
}<pre><h2>Problem4766</h2><pre>#include &lt;cstdio&gt;
typedef unsigned long long ull;
ull n, m, p;
inline ull add(ull a, ull b) {
	a += b;
	return a &lt; p ? a : (a - p);
}
inline ull mul(ull a, ull b) {
	static ull r;
	for (r = 0; b; b &gt;&gt;= 1, a = add(a, a))
		if (b &amp; 1) r = add(a, r);
	return r;
}
inline ull pw(ull a, ull b) {
	static ull r;
	for (r = 1; b; b &gt;&gt;= 1, a = mul(a, a))
		if (b &amp; 1) r = mul(a, r);
	return r;
}
int main() {
	scanf(&quot;%llu%llu%llu&quot;, &amp;n, &amp;m, &amp;p);
	printf(&quot;%llu\n&quot;, mul(pw(n % p, m - 1), pw(m % p, n - 1)));
	return 0;
}<pre><h2>Problem4766</h2><pre>var n,m,p:int64;function x(a,b:int64):int64;begin a:=a+b;if a&lt;p then x:=a else x:=a-p;end;function y(a,b:int64):int64;begin y:=0;while b&gt;0 do begin if(b and 1)&gt;0 then y:=x(a,y);a:=x(a,a);b:=b&gt;&gt;1;end;end;function z(a,b:int64):int64;begin z:=1;while(b&gt;0)do begin if (b and 1)&gt;0 then z:=y(a,z);a:=y(a,a);b:=b&gt;&gt;1;end;end;begin read(n,m,p);writeln(y(z(n mod p,m-1),z(m mod p,n-1)));end.<pre><h2>Problem4767</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N=505,M=1e6,P=1e9+7;
inline int read(){
    char c=getchar();int x=0,f=1;
    while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=getchar();}
    while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int x,y,n,x1,y1,x2,y2;
struct Point{
    int x,y;
    bool operator &lt;(const Point &amp;r)const{return x&lt;r.x || (x==r.x &amp;&amp; y&lt;r.y);}
}a[N];
int m;
bool solEqu(int x,int y,Point &amp;p){//printf(&quot;solEqu %d %d\n&quot;,x,y);
    int a=x*y1-y*x1,b=x2*y1-y2*x1;//printf(&quot;a b %d %d\n&quot;,a,b);
    if(a%b) return 0;else p.x=a/b;
    a=x*y2-y*x2,b=x1*y2-y1*x2;//printf(&quot;a b %d %d\n&quot;,a,b);
    if(a%b) return 0;else p.y=a/b;//printf(&quot;Point %d %d\n&quot;,p.x,p.y);
    return 1;
}
ll inv[M],fac[M],facInv[M];
void ini(int n){
    inv[1]=1;fac[0]=facInv[0]=1;
    for(int i=1;i&lt;=n;i++){
        if(i!=1) inv[i]=(P-P/i)*inv[P%i]%P;
        fac[i]=fac[i-1]*i%P;
        facInv[i]=facInv[i-1]*inv[i]%P;
    }
}
inline ll C(int n,int m){return fac[n]*facInv[m]%P*facInv[n-m]%P;}
ll f[N];
inline void modify(ll &amp;x){if(x&lt;0) x+=P;}
void dp(){
    for(int i=1;i&lt;=m;i++){
        f[i]=C(a[i].x+a[i].y,a[i].x);
        for(int j=1;j&lt;i;j++) if(a[j].x&lt;=a[i].x &amp;&amp; a[j].y&lt;=a[i].y)
            modify(f[i]-=C(a[i].x-a[j].x+a[i].y-a[j].y , a[i].x-a[j].x) * f[j] %P);
    }
}
int main(){
    ini(500000);
    x=read();y=read();n=read();
    x1=read();y1=read();x2=read();y2=read();
    if(!solEqu(x,y,a[++m])) {puts(&quot;0&quot;);return 0;}
    for(int i=1;i&lt;=n;i++){
        x=read();y=read();
        if(!solEqu(x,y,a[++m]) || a[m].x&gt;a[1].x || a[m].y&gt;a[1].y) m--;
    }
    sort(a+1,a+1+m);
    dp();
    printf(&quot;%lld&quot;,f[m]);
}<pre><h2>Problem4767</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
const int maxn(505), maxm(1e6), mod(1e9 + 7);
int fac[maxm], inv[maxm], _fac[maxm];
inline void init() {
	fac[0] = _fac[0] = 1;
	fac[1] = inv[1] = _fac[1] = 1;
	for (register int i = 2; i &lt; maxm; ++i) {
		fac[i] = (long long) fac[i - 1] * i % mod;
		inv[i] = (long long) (mod - mod / i) * inv[mod % i] % mod;
		_fac[i] = (long long) _fac[i - 1] * inv[i] % mod;
	}
}
inline int C(int n, int m) {
  if (m &lt; 0 || n - m &lt; 0) return 0;
	return (long long)fac[n] * _fac[m] % mod * _fac[n - m] % mod;
}
int dp[maxn], cnt;
typedef std::pair&lt;int, int&gt; point;
point p[maxn];
struct equation {
	int x1, y1, x2, y2;
	equation(int x1, int y1, int x2, int y2) :
		x1(x1), y1(y1), x2(x2), y2(y2) {}
	inline bool solve_equation(int x, int y, point &amp;ans) {
		int a = x * y1 - y * x1, b = x2 * y1 - y2 * x1;
		if (a % b)
		  return false;
		ans.first = a / b;
		a = x * y2 - y * x2, b = -b;
		if (a % b)
		  return false;
		ans.second = a / b;
		return true;
	}
};
inline void solve() {
	for (register int i = 0; i &lt; cnt; ++i) {
		dp[i] = C(p[i].first + p[i].second, p[i].second);
		for (register int j = 0; j &lt; i; ++j)
		  if (p[i].first &gt;= p[j].first &amp;&amp; p[i].second &gt;= p[j].second) {
			  dp[i] -= (long long) C(p[i].first - p[j].first + p[i].second - p[j].second, p[i].first - p[j].first) * dp[j] % mod;
			  if (dp[i] &lt; 0) dp[i] += mod;
		  }
	}
}
int main() {
	init();
	int ex, ey, n, ax, ay, bx, by;
	scanf(&quot;%d%d%d&quot;, &amp;ex, &amp;ey, &amp;n);
	scanf(&quot;%d%d%d%d&quot;, &amp;ax, &amp;ay, &amp;bx, &amp;by);
	equation eq(ax, ay, bx, by);
	cnt = 0;
	if (!eq.solve_equation(ex, ey, p[cnt++]))
    return puts(&quot;0&quot;), 0;
	for (register int i = 0; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;ex, &amp;ey);
		if (!eq.solve_equation(ex, ey, p[cnt]) || p[cnt].first &gt; p-&gt;first || p[cnt].second &gt; p-&gt;second)
		  continue;
		++cnt;
	}
	std::sort(p, p + cnt);
	solve();
	printf(&quot;%d\n&quot;, dp[cnt - 1]);
	return 0;
}
<pre><h2>Problem4770</h2><pre>#include&lt;iostream&gt;
int a[55][9]={{},{0,0,0,0,0,0,0,0,0,},{0,129140164,129140165,129140167,129140171,129140179,129140195,129140227,129140291,},{0,193710246,64570084,24213786,236084373,77181450,157515737,140774228,215031499,},{0,225995287,121068906,238102183,203547108,218712265,116264831,99443036,79121964,},{0,112997644,108962016,46788094,36549268,117877184,14509798,100438248,107231500,},{0,185638986,53976556,134689163,96426552,194242540,153639990,120659378,101104631,},{0,221959657,227256424,124881873,171543395,157647025,162557411,23785165,258144187,},{0,110979829,87995657,38609442,206828800,253024756,206227824,141710270,10320181,},{0,55489915,109955160,56272067,231265411,63090854,237048705,171426005,85709662,},{0,27744958,238738659,7008635,102222843,120595225,256801988,235521295,180619543,},{0,143012643,24411822,194556475,215231251,130161896,73648531,208001599,170619964,},{0,71506322,157216049,153352677,156238751,192264872,27770309,226347497,54161031,},{0,164893325,184923874,246796406,52697789,171780083,21983921,223228206,185664220,},{0,82446663,171588386,198224372,24087433,169856546,85584783,15039313,51032118,},{0,41223332,233770283,237290397,226108046,172324917,242546032,177098806,40173324,},{0,149751830,40172257,206855876,234897786,42845559,190284536,34527590,26337201,},{0,204016079,44767891,130125758,198580206,248091586,33588797,142939578,109276637,},{0,102008040,53378114,117153053,140321556,207663118,231585645,18039713,42557731,},{0,180144184,222551860,141542926,124678758,256378666,58621640,169814611,164503795,},{0,219212256,51118260,22017057,107400239,71063488,208194809,141040710,82368253,},{0,238746292,9389787,73404282,197290983,187666354,33421568,243481387,230191654,},{0,248513310,258085441,206092103,175865014,46934405,238338656,34885039,160507772,},{0,253396819,46472091,52427070,10622380,31557757,78236842,121818911,78588165,},{0,126698410,14223592,100655489,4793966,28513326,106020021,130112147,61905360,},{0,192489369,53937637,55392462,243667232,206236595,2350355,2101084,238304638,},{0,96244685,115840796,252931583,12885294,108834416,142226001,41501066,77317254,},{0,48122343,186440092,145791627,175931570,191171533,54681626,171376190,8284899,},{0,24061172,35579780,244199696,219925978,194916377,159910040,18680912,56283054,},{0,141170750,129762427,191545910,85767863,96762108,75032252,68489928,100763661,},{0,199725539,123091219,123096044,64432902,33418232,219199667,205120656,160043295,},{0,99862770,147188326,236754524,80629277,18247771,18374728,15226623,146765106,},{0,179071549,43396121,1036568,86131407,196354204,129359671,55657413,95474816,},{0,89535775,177223515,164355065,176671379,141757722,64001077,97905256,148393376,},{0,44767888,56089100,9744293,28759687,254183618,187978963,48484166,10384133,},{0,151524108,71287253,195783672,235105036,63372602,48706668,248893454,173302144,},{0,204902218,189910711,57376262,237466820,231810127,127325080,116537614,29856382,},{0,231591273,257256954,207490218,200639665,46244374,29857601,109793313,58979680,},{0,115795637,205506176,45896798,234868496,29541064,251294633,256749187,63816439,},{0,57897819,124985457,245728025,115443775,144062289,195058805,171514012,53312683,},{0,28948910,21882968,223817069,76823424,21491759,227107331,131344269,97420818,},{0,143614619,14590716,250142242,217871110,158025913,120380172,59940904,105696964,},{0,71807310,75057742,38795205,80612780,246470934,120257251,3687048,158432457,},{0,165043819,201462147,168744597,172739460,61176618,38568071,97892751,11175058,},{0,82521910,219673862,27383363,66850809,196775038,6183180,92038631,31326683,},{0,170401119,101187108,75392768,51235977,45924565,86039077,51855151,254177214,},{0,85200560,221423464,251701329,91563073,211230946,180879303,101994951,244856176,},{0,171740444,202450882,103638399,9527704,148889553,41207463,141727928,145038853,},{0,215010386,225504065,114480260,68277350,11820640,1248372,121446262,9716295,},{0,236645357,26119321,236275454,147928086,206426334,162743844,101312146,105149937,},{0,118322679,258260157,59715480,13946009,169602037,225439100,30268418,150919282,},},n,m;
int main(){std::cin&gt;&gt;n&gt;&gt;m;std::cout&lt;&lt;a[n][m];}<pre><h2>Problem4771</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxn(1e5 + 7), INT_MAX(0x7fffffff);

struct edge {
	int to;
	edge *nxt;
} edge_mset[maxn], *g[maxn], *cedge;

inline void add_edge(int u, int v) {
	*cedge = (edge) {v, g[u]};
	g[u] = cedge++;
}

int col[maxn], dep[maxn], n, m;

struct seg {
	int val;
	seg *ls, *rs;
} node_mset[maxn * 100], *cnode, *nil1, *nil2, *rt1[maxn], *rt2[maxn];

void modify(seg *x, seg * &amp;y, int l, int r, const int &amp;pos, const int &amp;val) {
	*(y = cnode++) = *x;
	y-&gt;val = val;
	if (l == r) return;
	int mid = (l + r) &gt;&gt; 1;
	if (pos &lt;= mid)
		modify(x-&gt;ls, y-&gt;ls, l, mid, pos, val);
	else
		modify(x-&gt;rs, y-&gt;rs, mid + 1, r, pos, val);
}


void _modify(seg *x, seg * &amp;y, int l, int r, const int &amp;pos, const int &amp;val) {
	*(y = cnode++) = *x;
	y-&gt;val += val;
	if (l == r) return;
	int mid = (l + r) &gt;&gt; 1;
	if (pos &lt;= mid)
		_modify(x-&gt;ls, y-&gt;ls, l, mid, pos, val);
	else
		_modify(x-&gt;rs, y-&gt;rs, mid + 1, r, pos, val);
}

seg *merge1(seg *x, seg *y, int l, int r) {
	if (x == nil1) return y;
	if (y == nil1) return x;
	seg *n = cnode++;
	int mid = (l + r) &gt;&gt; 1;
	n-&gt;val = x-&gt;val + y-&gt;val;
	n-&gt;ls = merge1(x-&gt;ls, y-&gt;ls, l, mid);
	n-&gt;rs = merge1(x-&gt;rs, y-&gt;rs, mid + 1, r);
	return n;
}

inline int max(const int &amp;a, const int &amp;b) {
	return a &lt; b ? b : a;
}

inline int min(const int &amp;a, const int &amp;b) {
	return a &lt; b ? a : b;
}

seg *merge2(seg *x, seg *y, int l, int r, seg * &amp;z) {
	if (x == nil2) return y;
	if (y == nil2) return x;
	seg *n = cnode++;
	if (l == r) {
		n-&gt;val = min(x-&gt;val, y-&gt;val);
		if (max(x-&gt;val, y-&gt;val) != INT_MAX)
			_modify(z, z, 1, ::n, max(x-&gt;val, y-&gt;val), -1);
	}
	int mid = (l + r) &gt;&gt; 1;
	n-&gt;ls = merge2(x-&gt;ls, y-&gt;ls, l, mid, z);
	n-&gt;rs = merge2(x-&gt;rs, y-&gt;rs, mid + 1, r, z);
	return n;
}

void dfs(int u) {
	modify(nil1, rt1[u], 1, n, dep[u], 1);
	modify(nil2, rt2[u], 1, n, col[u], dep[u]);

	for (edge *it = g[u]; it; it = it-&gt;nxt) {
		dfs(it-&gt;to);

		rt1[u] = merge1(rt1[u], rt1[it-&gt;to], 1, n);
		rt2[u] = merge2(rt2[u], rt2[it-&gt;to], 1, n, rt1[u]);
	}

}

int query(seg*u, int l, int r, const int &amp;x, const int &amp;y) {
	if (x &lt;= l &amp;&amp; r &lt;= y)
		return u-&gt;val;
	int mid = (l + r) &gt;&gt; 1, ret = 0;
	if (x &lt;= mid) ret += query(u-&gt;ls, l, mid, x, y);
	if (y &gt;  mid) ret += query(u-&gt;rs, mid + 1, r, x, y);
	return ret;
}

int main() {
	int o_o, u, lastans, x, d;
	scanf(&quot;%d&quot;, &amp;o_o);
	while (o_o--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
		for (register int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%d&quot;, col + i);
			g[i] = NULL;
		}

		cedge = edge_mset;
		dep[1] = 1;
		for (register int i = 2; i &lt;= n; ++i) {
			scanf(&quot;%d&quot;, &amp;u);
			add_edge(u, i);
			dep[i] = dep[u] + 1;
		}

		cnode = node_mset;
		nil1 = cnode++;
		nil2 = cnode++;

		*nil1 = (seg) {0, nil1, nil1};
		*nil2 = (seg) {INT_MAX, nil2, nil2};

		dfs(1);

		lastans = 0;

		while (m--) {
			scanf(&quot;%d%d&quot;, &amp;x, &amp;d);
			x ^= lastans, d ^= lastans;
			lastans = query(rt1[x], 1, n, dep[x], dep[x] + d);
			printf(&quot;%d\n&quot;, lastans);
		}

	}
	return 0;
}
<pre><h2>Problem4772</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int mod(1e9 + 7), maxn(2007), maxk(1e5 + 7), maxa(1e7 + 7);

inline int gcd(int a, int b) {
	for (static int t; b; t = a % b, a = b, b = t);
	return a;
}

bool vis[maxa];
int a[maxk], n, k, type, d[maxa], phi[maxa], g[maxa], p[maxn], pri[maxa / 10], tot, e[maxa];

inline int fast_pow(int a, int b) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = (long long)a * a % k)
		if (b &amp; 1) r = (long long)r * a % k;
	return r;
}
inline int F(int x, int y) {
	if (type == 1)
		return 1;
	if (type == 2)
		return gcd(x, y) % k;
	return (fast_pow(x, y) + fast_pow(y, x) + (x xor y)) % k;
}

inline void calc_p(const int &amp;n) {
	p[0] = 1;
	for (register int i = 1; i &lt;= n; ++i)
		for (register int j = i; j &lt;= n; ++j)
			for (p[j] += p[j - i]; p[j] &gt;= mod; p[j] -= mod);
}

inline void silver() {
	g[1] = 1;
	for (register int i = 2; i &lt; maxa; ++i) {
		if (!vis[i]) {
			pri[tot++] = i;
			d[i] = 2;
			e[i] = 1;
			phi[i] = i - 1;
		}
		for (register int j = 0, t; (t = pri[j] * i) &lt; maxa; ++j) {
			vis[t] = true;
			if (i % pri[j]) {
				d[t] = d[i] * d[pri[j]];
				e[t] = 1;
				phi[t] = phi[i] * (pri[j] - 1);
			} else {
				d[t] = d[i] / (e[i] + 1) * (e[i] + 2);
				e[t] = e[i] + 1;
				phi[t] = phi[i] * pri[j];
				break;
			}
		}
		g[i] = (long long)d[i] * phi[i] % mod;
	}
}

int main() {

	scanf(&quot;%d%d%d&quot;, &amp;type, &amp;n, &amp;k);
	for (register int i = 0; i &lt; k; ++i)
		scanf(&quot;%d&quot;, a + i);

	silver();
	calc_p(n);
	int ans = 0, cnt;
	long long f;
	for (register int x = 1; x &lt;= n; ++x)
		for (register int y = x; y &lt;= n; ++y) {
			f = g[a[F(x, y)]];
			cnt = 0;
			if (f) for (register int i = 1, _i = x; _i &lt; n; ++i, _i += x)
				for (register int j = 1, _j = _i + y; _j &lt;= n; _j += y)
					for (cnt += p[n - _j]; cnt &gt;= mod; cnt -= mod);
			ans = (f * cnt + ans) % mod;
		}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4772</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int mod(1e9 + 7), maxn(2007), maxk(1e5 + 7), maxa(1e7 + 7);

inline int gcd(int a, int b) {
	for (static int t; b; t = a % b, a = b, b = t);
	return a;
}

bool vis[maxa];
int a[maxk], n, k, type, d[maxa], phi[maxa], g[maxa], p[maxn], pri[maxa / 10], tot, e[maxa];

inline int fast_pow(int a, int b) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = (long long)a * a % k)
		if (b &amp; 1) r = (long long)r * a % k;
	return r;
}
inline int F(int x, int y) {
	if (type == 1)
		return 1;
	if (type == 2)
		return gcd(x, y) % k;
	return (fast_pow(x, y) + fast_pow(y, x) + (x xor y)) % k;
}

inline void calc_p(const int &amp;n) {
	p[0] = 1;
	for (register int i = 1; i &lt;= n; ++i)
		for (register int j = i; j &lt;= n; ++j)
			for (p[j] += p[j - i]; p[j] &gt;= mod; p[j] -= mod);
}

inline void silver(const int &amp;maxa) {
	g[1] = 1;
	for (register int i = 2; i &lt; maxa; ++i) {
		if (!vis[i]) {
			pri[tot++] = i;
			d[i] = 2;
			e[i] = 1;
			phi[i] = i - 1;
		}
		for (register int j = 0, t; (t = pri[j] * i) &lt; maxa; ++j) {
			vis[t] = true;
			if (i % pri[j]) {
				d[t] = d[i] * d[pri[j]];
				e[t] = 1;
				phi[t] = phi[i] * (pri[j] - 1);
			} else {
				d[t] = d[i] / (e[i] + 1) * (e[i] + 2);
				e[t] = e[i] + 1;
				phi[t] = phi[i] * pri[j];
				break;
			}
		}
		g[i] = (long long)d[i] * phi[i] % mod;
	}
}

int main() {

	scanf(&quot;%d%d%d&quot;, &amp;type, &amp;n, &amp;k);
	int _maxa = -1;
	for (register int i = 0; i &lt; k; ++i) {
		scanf(&quot;%d&quot;, a + i);
		if (_maxa &lt; a[i])
			_maxa = a[i];
	}

	silver(_maxa + 5);
	calc_p(n);
	int ans = 0, cnt;
	long long f;
	for (register int x = 1; x &lt;= n; ++x)
		for (register int y = x; y &lt;= n; ++y) {
			f = g[a[F(x, y)]];
			cnt = 0;
			if (f) for (register int i = 1, _i = x; _i &lt; n; ++i, _i += x)
					   for (register int j = 1, _j = _i + y; _j &lt;= n; _j += y)
						   for (cnt += p[n - _j]; cnt &gt;= mod; cnt -= mod);
			ans = (f * cnt + ans) % mod;
		}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4772</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int mod(1e9 + 7), maxn(2007), maxk(1e5 + 7), maxa(1e7 + 7);

inline int gcd(int a, int b) {
	for (static int t; b; t = a % b, a = b, b = t);
	return a;
}

inline void gi(int &amp;a) {
	static char c;
	do c = getchar_unlocked(); while (c &lt; 48);
	a = c - 48;
	while (47 &lt; (c = getchar_unlocked())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48;
}

bool vis[maxa];
int a[maxk], n, k, type, d[maxa], phi[maxa], p[maxn], pri[maxa / 10], tot, e[maxa];

inline int fast_pow(int a, int b) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = (long long)a * a % k)
		if (b &amp; 1) r = (long long)r * a % k;
	return r;
}
inline int F(int x, int y) {
	if (type == 1)
		return 1;
	if (type == 2)
		return gcd(x, y) % k;
	return (fast_pow(x, y) + fast_pow(y, x) + (x xor y)) % k;
}

inline void calc_p(const int &amp;n) {
	p[0] = 1;
	for (register int i = 1; i &lt;= n; ++i)
		for (register int j = i; j &lt;= n; ++j) {
			p[j] += p[j - i];
			if (p[j] &gt;= mod) p[j] -= mod;
		}
}

inline void silver(const int &amp;maxa) {
	d[1] = phi[1] = 1;
	for (register int i = 2; i &lt; maxa; ++i) {
		if (!vis[i]) {
			pri[tot++] = i;
			d[i] = 2;
			e[i] = 1;
			phi[i] = i - 1;
		}
		for (register int j = 0, t; (t = pri[j] * i) &lt; maxa; ++j) {
			vis[t] = true;
			if (i % pri[j]) {
				d[t] = d[i] * d[pri[j]];
				e[t] = 1;
				phi[t] = phi[i] * (pri[j] - 1);
			} else {
				d[t] = d[i] / (e[i] + 1) * (e[i] + 2);
				e[t] = e[i] + 1;
				phi[t] = phi[i] * pri[j];
				break;
			}
		}
	}
}

inline long long g(int x) {
	return (long long)d[x] * phi[x] % mod;
}

int main() {
	gi(type), gi(n), gi(k);
	int _maxa = -1;
	for (register int i = 0; i &lt; k; ++i) {
		gi(a[i]);
		if (_maxa &lt; a[i])
			_maxa = a[i];
	}

	calc_p(n);
	silver(_maxa + 5);
	int ans = 0, cnt;
	long long f;
	for (register int x = 1; x &lt;= n; ++x)
		for (register int y = x; y &lt;= n; ++y) {
			f = g(a[F(x, y)]);
			cnt = 0;
			for (register int i = x; i &lt; n; i += x)
					   for (register int j = i + y; j &lt;= n; j += y) {
					   		cnt += p[n - j];
					   		if (cnt &gt;= mod) cnt -= mod;
					   }
			ans = (f * cnt + ans) % mod;
		}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4772</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int mod(1e9 + 7), maxn(2007), maxk(1e5 + 7), maxa(1e7 + 7);

inline int gcd(int a, int b) {
	for (static int t; b; t = a % b, a = b, b = t);
	return a;
}

inline void gi(int &amp;a) {
	register char c;
	do c = getchar_unlocked(); while (c &lt; 48);
	a = c - 48;
	while (47 &lt; (c = getchar_unlocked())) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + c - 48;
}

bool vis[maxa];
int a[maxk], n, k, type, d[maxa], phi[maxa], p[maxn], pri[maxa / 10], tot, e[maxa];

inline int fast_pow(int a, int b) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = 1LL * a * a % k)
	  if (b &amp; 1) r = 1LL * r * a % k;
	return r;
}
inline int F(int x, int y) {
	if (type == 1)
	  return 1;
	if (type == 2)
	  return gcd(x, y) % k;
	return (fast_pow(x, y) + fast_pow(y, x) + (x xor y)) % k;
}

inline void calc_p(const int &amp;n) {
	p[0] = 1;
	for (register int i = 1; i &lt;= n; ++i)
	  for (register int j = i; j &lt;= n; ++j) {
		  p[j] += p[j - i];
		  if (p[j] &gt;= mod) p[j] -= mod;
	  }
}

inline void silver(const int &amp;maxa) {
	d[1] = phi[1] = 1;
	for (register int i = 2; i &lt; maxa; ++i) {
		if (!vis[i]) {
			pri[tot++] = i;
			d[i] = 2;
			e[i] = 1;
			phi[i] = i - 1;
		}
		for (register int j = 0, t; (t = pri[j] * i) &lt; maxa; ++j) {
			vis[t] = true;
			if (i % pri[j]) {
				d[t] = d[i] * d[pri[j]];
				e[t] = 1;
				phi[t] = phi[i] * (pri[j] - 1);
			} else {
				d[t] = d[i] / (e[i] + 1) * (e[i] + 2);
				e[t] = e[i] + 1;
				phi[t] = phi[i] * pri[j];
				break;
			}
		}
	}
}

inline int g(int x) {
	return 1LL * d[x] * phi[x] % mod;
}

int main() {
	gi(type), gi(n), gi(k);
	int _maxa = -1;
	for (register int i = 0; i &lt; k; ++i) {
		gi(a[i]);
		if (_maxa &lt; a[i])
		  _maxa = a[i];
	}

	calc_p(n);
	silver(_maxa + 5);
	int ans = 0, cnt, f;
	for (register int x = 1; x &lt;= n; ++x)
	  for (register int y = x; y &lt;= n; ++y) {
		  f = g(a[F(x, y)]), cnt = 0;
		  for (register int i = x; i &lt; n; i += x)
			for (register int j = i + y; j &lt;= n; j += y) {
				cnt += p[n - j];
				if (cnt &gt;= mod) cnt -= mod;
			}
		  ans = (1LL * f * cnt + ans) % mod;
	  }
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4772</h2><pre>#include &lt;cstdio&gt;

const int MOD = (int)(1e9 + 7), N = 2007, K = 100007, A = 10000007;

int (*F)(int, int), k;
int F1(int x, int y)
{
    return 1;
}
int F2(int x, int y)
{
    int t;
    while (y != 0)
    {
        t = x % y;
        x = y;
        y = t;
    }
    return x % k;
}
int F3(int x, int y)
{
    int c1 = 1, c2 = 1;
    for (int a = x, b = y; b != 0; b &gt;&gt;= 1, a = 1LL * a * a % k)
        if ((b &amp; 1) != 0)
            c1 = 1ll * c1 * a % k;
    for (int a = y, b = x; b != 0; b &gt;&gt;= 1, a = 1LL * a * a % k)
        if ((b &amp; 1) != 0)
            c2 = 1ll * c2 * a % k;
    return (c1 + c2 + (x ^ y)) % k;
}

bool vis[A];
int a[K], d[A], phi[A], p[N], pri[A / 10], e[A];

void calc_p(const int &amp;n)
{
    p[0] = 1;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = i; j &lt;= n; ++j)
        {
            p[j] += p[j - i];
            if (p[j] &gt;= MOD)
                p[j] -= MOD;
        }
}

void silver(const int &amp;A)
{
    int tot = 0;
    d[1] = phi[1] = 1;
    for (int i = 2; i &lt; A; ++i)
    {
        if (!vis[i])
        {
            pri[tot++] = i;
            d[i] = 2;
            e[i] = 1;
            phi[i] = i - 1;
        }
        for (int j = 0, t; (t = pri[j] * i) &lt; A; ++j)
        {
            vis[t] = true;
            if (i % pri[j] != 0)
            {
                d[t] = d[i] * d[pri[j]];
                e[t] = 1;
                phi[t] = phi[i] * (pri[j] - 1);
            }
            else
            {
                d[t] = d[i] / (e[i] + 1) * (e[i] + 2);
                e[t] = e[i] + 1;
                phi[t] = phi[i] * pri[j];
                break;
            }
        }
    }
}

int g(const int &amp;x)
{
    return 1ll * d[x] * phi[x] % MOD;
}

int main()
{
    int type, n, _A = -1;
    scanf(&quot;%d %d %d&quot;, &amp;type, &amp;n, &amp;k);
    for (int i = 0; i &lt; k; ++i)
    {
        scanf(&quot;%d&quot;, a + i);
        if (_A &lt; a[i])
            _A = a[i];
    }

    calc_p(n);
    silver(_A + 5);
    switch (type)
    {
    case 1:
        F = F1;
        break;
    case 2:
        F = F2;
        break;
    case 3:
        F = F3;
        break;
    default:
        F = NULL;
        break;
    }

    int ans = 0, cnt, f;
    for (int x = 1; x &lt;= n; ++x)
        for (int y = x; y &lt;= n; ++y)
        {
            cnt = 0;
            f = g(a[F(x, y)]);
            for (int i = x; i &lt; n; i += x)
                for (int j = i + y; j &lt;= n; j += y)
                {
                    cnt += p[n - j];
                    if (cnt &gt;= MOD)
                        cnt -= MOD;
                }
            ans = (1ll * f * cnt + ans) % MOD;
        }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}<pre><h2>Problem4773</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

int f[302][302], g[302][302];

inline void cmin(int &amp;a, const int &amp;b) {
    if (b &lt; a) a = b;
}

struct edge {
    int to, cost;
    edge *nxt;
} e[302 * 302], *h[302];

int main() {

    int n, m, u, v, w;

    memset(f, 63, sizeof f);

    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

    for (register int i = 0; i &lt; m; ++i) {
        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
        e[i] = (edge) {v, w, h[u]};
        h[u] = e + i;
    }

    for (register int i = 1; i &lt;= n; ++i)
        f[i][i] = 0;

    for (register int step = 1; step &lt;= n; ++step) {
        memcpy(g, f, sizeof g);
        for (register int s = 1; s &lt;= n; ++s)
            for (register int stop = 1; stop &lt;= n; ++stop)
                for (edge *it = h[stop]; it; it = it-&gt;nxt)
                    cmin(g[s][it-&gt;to], f[s][stop] + it-&gt;cost);
        memcpy(f, g, sizeof f);
        for (register int i = 1; i &lt;= n; ++i)
            if (f[i][i] &lt; 0)
                return printf(&quot;%d\n&quot;, step), 0;
    }
    puts(&quot;0&quot;);
    return 0;
}<pre><h2>Problem4784</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxn(5e5 + 7), maxm(2e6 + 7), mod(998244353);

struct edge {
	int to;
	edge *nxt;
} edge_mset[maxm], *g[maxn], *cedge;

inline void add_edge(int u, int v) {
	*cedge = (edge) {v, g[u]};
	g[u] = cedge++;
}

int f[maxn], d[maxn], dfn[maxn], fa[maxn], vis[maxn], _dfn;

bool dfs(int u) {
	dfn[u] = ++_dfn;
	for (edge *it = g[u]; it; it = it-&gt;nxt)
		if (!dfn[it-&gt;to]) {
			fa[it-&gt;to] = u;
			if (dfs(it-&gt;to))
				return true;
		} else if (dfn[it-&gt;to] &gt; dfn[u]) {
			d[u] -= 2;
			for (int v = it-&gt;to; u ^ v; d[v] -= 2, vis[v] = 1, v = fa[v])
				if (vis[v]) return true;
		}
	return false;
}

int main() {
	int o_o, n, m, ans, u, v;
	scanf(&quot;%d&quot;, &amp;o_o);
	f[0] = f[1] = 1;
	for (register int i = 2; i &lt; maxn; ++i) f[i] = ((i - 1ll) * f[i - 2] + f[i - 1]) % mod;
	while (o_o--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
		for (register int i = 1; i &lt;= n; ++i)
			g[i] = NULL, d[i] = dfn[i] = fa[i] = vis[i] = 0;

		cedge = edge_mset;

		while (m--) {
			scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
			add_edge(u, v), add_edge(v, u);
			++d[u];
			++d[v];
		}
		_dfn = 0;
		if (dfs(1))
			puts(&quot;0&quot;);
		else {
			ans = 1;
			for (register int i = 1; i &lt;= n; ++i)
				ans = 1ll * ans * f[d[i]] % mod;
			printf(&quot;%d\n&quot;, ans);
		}

	}
	return 0;
}
<pre><h2>Problem4785</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const int maxn(1e5 + 7), mod(998244353);

inline int fast_pow(int a, int b) {
	static int r;
	for (r = 1; b; b &gt;&gt;= 1, a = 1LL * a * a % mod)
		if (b &amp; 1) r = 1LL * r * a % mod;
	return r;
}

struct seg {
	int val;
	seg *ls, *rs;
} *rt[maxn &lt;&lt; 2];

int n;

inline seg *newnode() {
	static seg seg_mset[maxn * 250], *cseg(seg_mset);
	return cseg++;
}

inline int add(int a, int b) {
	return (1LL * a * (mod + 1 - b) + 1LL * b * (mod + 1 - a)) % mod;
}

int _x, _y, x, y, delta, pos;

inline void modify(seg* &amp;u, int l, int r) {
	if (!u) u = newnode();
	if (_x &lt;= l &amp;&amp; r &lt;= _y) {
		u-&gt;val = add(u-&gt;val, delta);
		return;
	}
	int mid = (l + r) &gt;&gt; 1;
	if (_x &lt;= mid) modify(u-&gt;ls, l, mid);
	if (_y &gt;  mid) modify(u-&gt;rs, mid + 1, r);
}

inline void modify(int u, int l, int r) {
	if (x &lt;= l &amp;&amp; r &lt;= y) {
		modify(rt[u], 0, n);
		return;
	}

	int mid = (l + r) &gt;&gt; 1;
	if (x &lt;= mid) modify(u &lt;&lt; 1, l, mid);
	if (y &gt;  mid) modify(u &lt;&lt; 1 | 1, mid + 1, r);
}

inline int query(seg *u, int l, int r) {
	if (u == NULL) return 0;
	if (l == r) return u-&gt;val;
	int mid = (l + r) &gt;&gt; 1;
	if (y &lt;= mid)
		return add(u-&gt;val, query(u-&gt;ls, l, mid));
	else
		return add(u-&gt;val, query(u-&gt;rs, mid + 1, r));
}

inline int query(int u, int l, int r) {
	if (l == r)
		return query(rt[u], 0, n);
	int mid = (l + r) &gt;&gt; 1, ret = query(rt[u], 0, n);
	if (x &lt;= mid)
		ret = add(ret, query(u &lt;&lt; 1, l, mid));
	else
		ret = add(ret, query(u &lt;&lt; 1 | 1, mid + 1, r));
	return ret;
}

int main() {

	//freopen(&quot;291.in&quot;, &quot;r&quot;, stdin);

	int n, m, opt, sum = 0, l, r;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	::n = n;
	while (m--) {
		scanf(&quot;%d%d%d&quot;, &amp;opt, &amp;l, &amp;r);
		if (opt &amp; 1) {
			++sum;
			delta = fast_pow(r - l + 1, mod - 2);
			x = l, y = r, _x = r + 1, _y = n;
			modify(1, 0, n);
			x = 0, y = l - 1, _x = l, _y = r;
			modify(1, 0, n);
			delta &lt;&lt;= 1;
			if (delta &gt;= mod) delta -= mod;
			x = _x = l, y = _y = r;
			modify(1, 0, n);
		} else {
			x = l - 1, y = r;
			delta = mod + 1 - query(1, 0, n);
			if (l == 1 &amp;&amp; (sum &amp; 1)) delta = mod + 1 - delta;
			while (delta &gt;= mod) delta -= mod;
			printf(&quot;%d\n&quot;, delta);
		}
	}

	return 0;
}<pre><h2>Problem4800</h2><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef unsigned long long ullong;

static ullong nums[40];
static ullong sums[1 &lt;&lt; 20];
static unsigned nsums;
static ullong total;
static ullong atmost;

typedef void (*gscbk) (ullong);

static void
record (ullong x)
{
  sums[nsums++] = x;
}

static void
count (ullong x)
{
  ullong sf = atmost - x;
  int l = 0, h = nsums, m;  /* sums[h] &gt; sf, sums[l] &lt;= sf */

  while (h &gt; l + 1)
    {
      m = (h + l) / 2;

      if (sums[m] &gt; sf)
	h = m;
      else
	l = m;
    }

  total += h;
}

static void
gen_sums (ullong ns[], int n, ullong asum, ullong max, gscbk cb)
{
  if (asum &gt; max)
    return;

  if (n == 0)
    {
      cb (asum);
      return;
    }

  gen_sums (ns + 1, n - 1, asum, max, cb);
  gen_sums (ns + 1, n - 1, asum + ns[0], max, cb);
}

static int
cmpullong (const void *a, const void *b)
{
  ullong aa = *(ullong *) a;
  ullong bb = *(ullong *) b;

  if (aa &lt; bb)
    return -1;

  if (aa &gt; bb)
    return 1;

  return 0;
}

int main (void)
{
  int i, n, r;

  scanf (&quot;%d%llu&quot;, &amp;n, &amp;atmost);
  for (i = 0; i &lt; n; i++)
    scanf (&quot;%llu&quot;, nums + i);

  r = n / 2;

  gen_sums (nums, r, 0, atmost, record);
  qsort (sums, nsums, sizeof (ullong), cmpullong);
  gen_sums (nums + r, n - r, 0, atmost, count);

  printf (&quot;%llu\n&quot;, total);

  return 0;
}<pre><h2>Problem4800</h2><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
typedef unsigned long long ullong;
 
static ullong nums[40];
static ullong sums[1 &lt;&lt; 20];
static unsigned nsums;
static ullong total;
static ullong atmost;
 
typedef void (*gscbk) (ullong);
 
static void
record (ullong x)
{
  sums[nsums++] = x;
}
 
static void
count (ullong x)
{
  ullong sf = atmost - x;
  int l = 0, h = nsums, m;  /* sums[h] &gt; sf, sums[l] &lt;= sf */
 
  while (h &gt; l + 1)
    {
      m = (h + l) / 2;
 
      if (sums[m] &gt; sf)
    h = m;
      else
    l = m;
    }
 
  total += h;
}
 
static void
gen_sums (ullong ns[], int n, ullong asum, ullong max, gscbk cb)
{
  if (asum &gt; max)
    return;
 
  if (n == 0)
    {
      cb (asum);
      return;
    }
 
  gen_sums (ns + 1, n - 1, asum, max, cb);
  gen_sums (ns + 1, n - 1, asum + ns[0], max, cb);
}
 
static int
cmpullong (const void *a, const void *b)
{
  ullong aa = *(ullong *) a;
  ullong bb = *(ullong *) b;
 
  if (aa &lt; bb)
    return -1;
 
  if (aa &gt; bb)
    return 1;
 
  return 0;
}
 
int main (void)
{
  int i, n, r;
 
  scanf (&quot;%d%llu&quot;, &amp;n, &amp;atmost);
  for (i = 0; i &lt; n; i++)
    scanf (&quot;%llu&quot;, nums + i);
 
  r = n / 2;
 
  gen_sums (nums, r, 0, atmost, record);
  qsort (sums, nsums, sizeof (ullong), cmpullong);
  gen_sums (nums + r, n - r, 0, atmost, count);
 
  printf (&quot;%llu\n&quot;, total);
 
  return 0;
}<pre><h2>Problem4800</h2><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
  
typedef unsigned long long ullong;
  
static ullong nums[40];
static ullong sums[1 &lt;&lt; 20];
static unsigned nsums;
static ullong total;
static ullong atmost;
  
typedef void (*gscbk) (ullong);
  
static void
record (ullong x)
{
  sums[nsums++] = x;
}
  
static void
count (ullong x)
{
  ullong sf = atmost - x;
  int l = 0, h = nsums, m;  /* sums[h] &gt; sf, sums[l] &lt;= sf */
  
  while (h &gt; l + 1)
    {
      m = (h + l) / 2;
  
      if (sums[m] &gt; sf)
    h = m;
      else
    l = m;
    }
  
  total += h;
}
  
static void
gen_sums (ullong ns[], int n, ullong asum, ullong max, gscbk cb)
{
  if (asum &gt; max)
    return;
  
  if (n == 0)
    {
      cb (asum);
      return;
    }
  
  gen_sums (ns + 1, n - 1, asum, max, cb);
  gen_sums (ns + 1, n - 1, asum + ns[0], max, cb);
}
  
static int
cmpullong (const void *a, const void *b)
{
  ullong aa = *(ullong *) a;
  ullong bb = *(ullong *) b;
  
  if (aa &lt; bb)
    return -1;
  
  if (aa &gt; bb)
    return 1;
  
  return 0;
}
  
int main (void)
{
  int i, n, r;
  
  scanf (&quot;%d%llu&quot;, &amp;n, &amp;atmost);
  for (i = 0; i &lt; n; i++)
    scanf (&quot;%llu&quot;, nums + i);
  
  r = n / 2;
  
  gen_sums (nums, r, 0, atmost, record);
  qsort (sums, nsums, sizeof (ullong), cmpullong);
  gen_sums (nums + r, n - r, 0, atmost, count);
  
  printf (&quot;%llu\n&quot;, total);
  
  return 0;
}<pre><h2>Problem4800</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
typedef unsigned long long ull;
int n, mid;
ull m, a[45], c1[1 &lt;&lt; 20 | 1], c2[1 &lt;&lt; 20 | 1], *it, *end, *e1, *e2, ans;
void dfs(ull *cur, ull sum) {
	if (sum &gt; m) return;
	if (cur == end) {
		*it++ = sum;
		return;
	}
	dfs(cur + 1, sum);
	dfs(cur + 1, sum + *cur);
}

int main() {
	scanf(&quot;%d%llu&quot;, &amp;n, &amp;m);
	for (register int i = 0; i &lt; n; ++i) scanf(&quot;%lld&quot;, a + i);
	mid = n &gt;&gt; 1;
	it = c1, end = a + mid, dfs(a, 0), e1 = it;
	it = c2, end = a + n, dfs(a + mid, 0), e2 = it;
	std::sort(c1, e1);
	for (it = c2; it &lt; e2; ++it) ans += std::upper_bound(c1, e1, m - *it) - c1;
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}
<pre><h2>Problem4800</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
typedef unsigned long long ull;
int n, mid, ed;
ull m, a[45], c1[1 &lt;&lt; 20 | 1], c2[1 &lt;&lt; 20 | 1], *it, *e1, *e2, ans;
inline void dfs(int i, ull sum) {
	if (sum &gt; m) return;
	if (i &gt;= ed) {
		*it++ = sum;
		return;
	}
	dfs(i + 1, sum);
	dfs(i + 1, sum + a[i]);
}
int main() {
	scanf(&quot;%d%llu&quot;, &amp;n, &amp;m);
	for (register int i = 0; i &lt; n; ++i) scanf(&quot;%llu&quot;, a + i);
	mid = n &gt;&gt; 1;
	it = c1, ed = mid, dfs(0, 0), e1 = it;
	it = c2, ed = n, dfs(mid, 0), e2 = it;
	std::sort(c1, e1);
	for (it = c2; it &lt; e2; ++it) ans += std::upper_bound(c1, e1, m - *it) - c1;
	printf(&quot;%llu\n&quot;, ans);
	return 0;
}<pre><h2>Problem4802</h2><pre>#include &lt;bits/stdc++.h&gt;
#define ll long long

#define INF 0x3f3f3f3f
#define maxn 10000+10
using namespace std;

const int S=20;//随机算法判定次数，S越大，判错概率越小
//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的
//  a,b,c &lt;2^63
ll mult_mod(ll a,ll b,ll c)
{
	ll r=0;
	for (a %= c, b %= c; b; b &gt;&gt;= 1, (a &lt;&lt;= 1) &gt;= c ? a -= c : 0)
		if (b &amp; 1) (r += a) &gt;= c ? r -= c : 0;
	return r;
}
ll pow_mod(ll x,ll n,ll mod)
{
	if(n==1)return x%mod;
	x%=mod;
	ll tmp=x;
	ll ret=1;
	while(n)
	{
		if(n&amp;1) ret=mult_mod(ret,tmp,mod);
		tmp=mult_mod(tmp,tmp,mod);
		n&gt;&gt;=1;
	}
	return ret;
}
//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数
//一定是合数返回true,不一定返回false
bool check(ll a,ll n,ll x,ll t)
{
	ll ret=pow_mod(a,x,n);
	ll last=ret;
	for(int i=1;i&lt;=t;i++)
	{
		ret=mult_mod(ret,ret,n);
		if(ret==1&amp;&amp;last!=1&amp;&amp;last!=n-1) return true;//合数
		last=ret;
	}
	if(ret!=1) return true;
	return false;
}
// Miller_Rabin()算法素数判定
//是素数返回true.(可能是伪素数，但概率极小)
//合数返回false;
bool Miller_Rabin(ll n)
{
	if(n&lt;2)return false;
	if(n==2)return true;
	if((n&amp;1)==0) return false;//偶数
	ll x=n-1;
	ll t=0;
	while((x&amp;1)==0){x&gt;&gt;=1;t++;}
	for(int i=0;i&lt;S;i++)
	{
		ll a=rand()%(n-1)+1;//rand()需要stdlib.h头文件
		if(check(a,n,x,t))
			return false;//合数
	}
	return true;
}
ll factor[10000000];//质因数分解结果（刚返回时是无序的）
int tol;//质因数的个数。数组小标从0开始
ll gcd(ll a,ll b)
{
	if(a==0)return 1;//???????
	if(a&lt;0) return gcd(-a,b);
	while(b)
	{
		ll t=a%b;
		a=b;
		b=t;
	}
	return a;
}
ll Pollard_rho(ll x,ll c)
{
	ll i=1,k=2;
	ll x0=rand()%x;
	ll y=x0;
	while(1)
	{
		i++;
		x0=(mult_mod(x0,x0,x)+c)%x;
		ll d=gcd(y-x0,x);
		if(d!=1&amp;&amp;d!=x) return d;
		if(y==x0) return x;
		if(i==k){y=x0;k+=k;}
	}
}
//对n进行素因子分解
void findfac(ll n)
{
	if(Miller_Rabin(n))//素数
	{
		factor[tol++]=n;
		return;
	}
	ll p=n;
	while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1);
	findfac(p);
	findfac(n/p);
}
int main()
{
	ll n, phi;
	scanf(&quot;%lld&quot;, &amp;n);
	if (n == 1) {
		puts(&quot;1&quot;);
		return 0;
	}
	tol=0;
	findfac(n);
	std::sort(factor, factor + tol);
	tol = std::unique(factor, factor + tol) - factor;
	phi = n;
	for (register int i = 0; i &lt; tol; ++i)
		phi = phi / factor[i] * (factor[i] - 1);
	printf(&quot;%lld\n&quot;, phi);
	return 0;
}<pre><h2>Problem4804</h2><pre>#include &lt;cstdio&gt;

const int maxn(1e7 + 7);

long long g[maxn];

inline void silver() {
	static int p[maxn], cnt = 0;
	g[1] = 1ll;
	for (int i = 2; i &lt; maxn; ++i) {
		if (!p[i]) {
			p[cnt++] = i;
			g[i] = i - 2;
		}
		for (int j = 0, t; (t = i * p[j]) &lt; maxn; ++j) {
			p[t] = 1;
			if (i % p[j])
				g[t] = g[i] * g[p[j]];
			else {
				if (i / p[j] % p[j] == 0)
					g[t] = g[i] * p[j];
				else
					g[t] = g[i / p[j]] * (p[j] - 1ll) * (p[j] - 1ll);
				break;
			}
		}
	}

	for (int i = 2; i &lt; maxn; ++i) g[i] += g[i - 1];

}

int main() {

	silver();

	int o_o;
	scanf(&quot;%d&quot;, &amp;o_o);

	while (o_o--) {
		static int n, _n, i, j;
		static long long ans;

		ans = 0ll;
		scanf(&quot;%d&quot;, &amp;n);

		for (i = 1; i &lt;= n; i = j + 1) {
			j = n / (_n = n / i);
			ans += 1ll * _n * _n * (g[j] - g[i - 1]);
		}

		printf(&quot;%lld\n&quot;, ans);
	}

}<pre><h2>Problem4805</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
 
const int maxn(2000005), maxp(100005);
 
bool vis[maxn];
long long a1[maxp], phi[maxn];
int p[maxn / 10], a2[maxp], mu[maxn], n;
 
inline void silver() {
    int tot = 0;
    phi[1] = mu[1] = 1;
    for (register int i = 2; i &lt; maxn; ++i) {
        if (!phi[i]) {
            mu[i] = -1;
            phi[i] = i - 1;
            p[tot++] = i;
        }
        for (register int j = 0, t; (t = i * p[j]) &lt; maxn; ++j)
            if (i % p[j]) {
                mu[t] = -mu[i];
                phi[t] = phi[i] * (p[j] - 1);
            } else {
                mu[t] = 0;
                phi[t] = phi[i] * p[j];
                break;
            }
    }
    for (register int i = 1; i &lt; maxn; ++i)
        mu[i] += mu[i - 1], phi[i] += phi[i - 1];
}
 
inline int calc_mu(int x) {
    return (x &lt; maxn) ? mu[x] : a2[n / x];
}
 
inline long long calc_phi(int x) {
    return (x &lt; maxn) ? phi[x] : a1[n / x];
}
 
void solve(int x) {
    if (x &lt; maxn) return;
    int i, j = 1, t = n / x;
    if (vis[t]) return;
    vis[t] = true;
    a1[t] = (x + 1ll) * x &gt;&gt; 1;
    a2[t] = 1;
    while (j &lt; x) {
        i = j + 1;
        j = x / (x / i);
        solve(x / i);
        a1[t] -= calc_phi(x / i) * (j - i + 1);
        a2[t] -= calc_mu(x / i) * (j - i + 1);
    }
}
 
int main() {
    int o_o = 1;
    silver();
    //scanf(&quot;%d&quot;, &amp;o_o);
 
    while (o_o--) {
        scanf(&quot;%d&quot;, &amp;n);
        if (n &lt; maxn)
            printf(&quot;%lld\n&quot;, phi[n]);
        else {
            memset(vis, 0, sizeof vis);
            solve(n);
            printf(&quot;%lld\n&quot;, a1[1]);
        }
    }
 
    return 0;
}<pre><h2>Problem4806</h2><pre>#include &lt;cstdio&gt;
#define mod 999983ll
#define ll long long
#define add(a) (f[i][j][k]=(f[i][j][k]+(a)%mod)%mod)
ll f[105][105][105];
int main() {
	int n,m,i,j,k,ans=0;
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	f[0][0][0]=1;
	for(i=1;i&lt;=n;++i)
	for(j=0;j&lt;=m;++j)
	for(k=0;k&lt;=m-j;++k) {
		f[i][j][k]=f[i-1][j][k];
		(k)?add(f[i-1][j+1][k-1]*(j+1)),add(f[i-1][j][k-1]*j*(m-k-j+1)):1;
		(j)?add(f[i-1][j-1][k]*(m-k-j+1)):1;
		(1&lt;k)?add(f[i-1][j+2][k-2]*(j+2)*(j+1)/2):1;
		(1&lt;j)?add(f[i-1][j-2][k]*(m-j-k+2)*(m-j-k+1)/2):1;
	}
	for(j=0;j&lt;=m;++j) for(k=0;k&lt;=m-j;++k)
	ans=(ans+f[n][j][k])%mod;
	return printf(&quot;%d\n&quot;,ans),0;
}
<pre><h2>Problem4807</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

const int maxn(1e6 + 7);
int p[maxn / 10], e[maxn / 10], tot;
inline void silver() {
	static bool v[maxn];
	for (int i = 2; i &lt; maxn; ++i) {
		if (!v[i])
			p[tot++] = i;
		for (int j = 0, t; (t = i * p[j]) &lt; maxn; ++j) {
			v[t] = true;
			if (i % p[j] == 0) break;
		}
	}
}

inline void fac(const int &amp;n, const int &amp;delta) {
	for (int i = 0; i &lt; tot &amp;&amp; p[i] &lt;= n; ++i) {
		for (long long t = p[i]; t &lt;= n; t *= p[i])
			e[i] += delta * n / t;
	}
}

int ans[55];

int main() {

	int n, m;

	silver();

	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if (n &lt; m)
		std::swap(n, m);

	fac(n, 1);
	fac(m, -1);
	fac(n - m, -1);

	ans[0] = 1;

	for (int i = 0; i &lt; tot; ++i)
		while (e[i]--) {
			for (int j = 0; j &lt; 50; ++j)
				ans[j] *= p[i];
			for (int j = 0; j &lt; 50; ++j) {
				ans[j + 1] += ans[j] / 10;
				ans[j] %= 10;
			}
		}

	for (n = 49; ~n &amp;&amp; !ans[n]; --n);

	if (~n) while (~n) putchar(ans[n--] + '0');
	else putchar('0');

	puts(&quot;&quot;);

	return 0;
}
<pre><h2>Problem4808</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#define num(A,B) ((A)*m-m+B)
#define ok(A,B) (A&gt;=1&amp;&amp;A&lt;=n&amp;&amp;B&gt;=1&amp;&amp;B&lt;=m&amp;&amp;!map[A][B])
using namespace std;
int n,m,cnt,tot,ans;
int dx[]={-1,-1,1,1,-2,-2,2,2},dy[]={2,-2,2,-2,1,-1,1,-1};
int d[40010],next[500010],val[500010],head[40010],to[500010],map[210][210];
queue&lt;int&gt; q;
void add(int a,int b,int c)
{
    to[cnt]=b,val[cnt]=c,next[cnt]=head[a],head[a]=cnt++;
    to[cnt]=a,val[cnt]=0,next[cnt]=head[b],head[b]=cnt++;
}
int dfs(int x,int mf)
{
    if(x==n*m+1)    return mf;
    int i,k,temp=mf;
    for(i=head[x];i!=-1;i=next[i])
    {
        if(d[to[i]]==d[x]+1&amp;&amp;val[i])
        {
            k=dfs(to[i],min(mf,val[i]));
            if(!k)  d[to[i]]=0;
            val[i]-=k,val[i^1]+=k,temp-=k;
            if(!temp)   break;
        }
    }
    return mf-temp;
}
int bfs()
{
    memset(d,0,sizeof(d));
    while(!q.empty())   q.pop();
    int i,u;
    d[0]=1,q.push(0);
    while(!q.empty())
    {
        u=q.front(),q.pop();
        for(i=head[u];i!=-1;i=next[i])
        {
            if(val[i]&amp;&amp;!d[to[i]])
            {
                d[to[i]]=d[u]+1;
                if(to[i]==n*m+1)    return 1;
                q.push(to[i]);
            }
        }
    }
    return 0;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int i,j,k,a;
    memset(head,-1,sizeof(head));
    for(i=1;i&lt;=n;i++)
    {
        for(j=1;j&lt;=m;j++)
        {
            scanf(&quot;%d&quot;,&amp;map[i][j]);
            if(map[i][j])   continue;
            tot++;
            if((i^j)&amp;1)
            {
                add(0,num(i,j),1);
                for(k=0;k&lt;8;k++) if(ok(i+dx[k],j+dy[k])) add(num(i,j),num(i+dx[k],j+dy[k]),1&lt;&lt;30);
            }
            else    add(num(i,j),n*m+1,1);
        }
    }
    while(bfs())    ans+=dfs(0,1&lt;&lt;30);
    printf(&quot;%d&quot;,tot-ans);
    return 0;
}<pre><h2>Problem4809</h2><pre>    #include&lt;cstdio&gt;  
    #include&lt;cstring&gt;  
    const int Q=18;  
    int n,a[Q][Q],ans=0;  
    bool r[Q],x1[Q*2],x2[Q*2];  
    void dfs(int x)  
    {  
        if(x==n+1)  
        {  
            ans++;  
            return;  
        }  
        for(int i=1;i&lt;=n;i++)  
        if(a[x][i]==0 &amp;&amp; r[i]==false &amp;&amp; x1[x-i+n]==false &amp;&amp; x2[x+i]==false)  
        {  
            r[i]=true;x1[x-i+n]=true;x2[x+i]=true;  
            dfs(x+1);  
            r[i]=false;x1[x-i+n]=false;x2[x+i]=false;  
        }  
    }  
    int main()  
    {  
        //memset(r,false,sizeof(r));  
        //memset(x1,false,sizeof(x1));  
        //memset(x2,false,sizeof(x2));  
        scanf(&quot;%d&quot;,&amp;n);  
        for(int i=1;i&lt;=n;i++)  
        for(int j=1;j&lt;=n;j++)  
        scanf(&quot;%d&quot;,&amp;a[i][j]);  
        dfs(1);  
        printf(&quot;%d&quot;,ans);  }  <pre><h2>Problem4825</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#define N 100050

#define MP make_pair
#define x first
#define y second
#define O tr[t]
#define L tr[tr[t].l]
#define R tr[tr[t].r]
#define E return
#define I int

using namespace std;
typedef pair&lt;I,I&gt; pii;
void GP(I &amp;a,I &amp;b,pii p) {a=p.x,b=p.y;}

struct Node{I l,r,siz,key,a,dep,min,ag; }tr[N];
I up(I t) {
    O.siz = L.siz + R.siz + 1;
    O.min = O.dep;
    tr[t].l ? O.min = min(O.min, L.min) :0;
    tr[t].r ? O.min = min(O.min, R.min) :0;
    E t;
}
I T,rt,cnt,n,r1,r2,A,B,k,j,cmd;

I rd() {I r;scanf(&quot;%d&quot;,&amp;r);E r;}

I calc(I t,I x) {
    if (!t) E 0;
    E x &gt; tr[t].a ?
        L.siz + 1 + calc(tr[t].r, x):
        calc(tr[t].l, x);
}

void pd(I t) {
    if (tr[t].l) L.min += O.ag, L.dep += O.ag, L.ag += O.ag;
    if (tr[t].r) R.min += O.ag, R.dep += O.ag, R.ag += O.ag;
    O.ag = 0;
}
void add(I t,I k) { if (!t) E ;O.min += k, O.dep += k, O.ag += k; }

pii spl(I t,I k) {
    if (!k) E MP(0,t);
    if (k == O.siz) E MP(t,0);
    pd(t); int tmp;
    E L.siz + 1 &lt;= k ? 
        ( GP(O.r, tmp, spl(O.r,k-L.siz-1)), up(t), MP(t,tmp) ):
        ( GP(tmp, O.l, spl(O.l,k))        , up(t), MP(tmp,t) );
}

I mer(I x,I y) {
    if (!x || !y) E x+y;
    pd(x), pd(y);
    E tr[x].key &gt; tr[y].key ?
        ( tr[x].r = mer(tr[x].r, y), up(x) ):
        ( tr[y].l = mer(x, tr[y].l), up(y) );
}

I pre(I t,I k) {
    if (!t) E 0; pd(t);
    E min(R.min,O.dep)&gt;k?
        pre(tr[t].l,k)+1+R.siz:pre(tr[t].r,k);
}

I suf(I t,I k) {
    if (!t) E 0; pd(t);
    E min(L.min,O.dep)&gt;k ?
        suf(tr[t].r,k)+1+L.siz:suf(tr[t].l,k);
}

int main() {
    srand(19260817);
    tr[0].min=(1&lt;&lt;30);
    for (T=rd();T;T--){
        cmd=rd();
        if (cmd==1){
            int k=rd(),nd=1,p=calc(rt,k);
            GP(r1,r2,spl(rt,p));
            if (p){
                GP(r1,A,spl(r1,tr[r1].siz-1));
                nd=max(nd, tr[A].dep+1);
                r1=mer(r1,A);
            }
            if (p&lt;n){
                GP(B,r2,spl(r2,1));
                nd=max(nd,tr[B].dep+1);
                r2=mer(B,r2);
            }
            tr[++cnt]=(Node){0,0,1,rand(),k,nd,nd,0};
            printf(&quot;%d\n&quot;,nd);
            rt = mer(mer(r1,cnt),r2);
            ++n;
            continue;
        }

        if (cmd==2||cmd==4){
            GP(j,rt,spl(rt,1));
            printf(&quot;%d\n&quot;,tr[j].dep);
            int p=suf(rt,tr[j].dep);
            GP(k,rt,spl(rt,p));

            add(rt,2-tr[rt].min);
            add(j,1-tr[j].min);

            rt=mer(mer(j,k),rt);
            if (cmd&gt;3) GP(k,rt,spl(rt,1)),add(rt,-1),n--;
        }else{
            GP(rt,j,spl(rt,n-1));
            printf(&quot;%d\n&quot;,tr[j].dep);
            I p=pre(rt, tr[j].dep);
            GP(rt,k,spl(rt,n-p-1));

            add(rt,2-tr[rt].min);
            add(j,1-tr[j].min);

            rt=mer(mer(rt,k),j);
            if (cmd&gt;3) GP(rt,k,spl(rt,n-1)),add(rt,-1),n--;
        }
    }
    return 0;
}<pre><h2>Problem4825</h2><pre>#include &lt;set&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;
inline void read(int &amp;x){
    x=0;char ch;bool flag = false;
    while(ch=getchar(),ch&lt;'!');if(ch == '-') ch=getchar(),flag = true;
    while(x=10*x+ch-'0',ch=getchar(),ch&gt;'!');if(flag) x=-x;
}
#define rg register int
#define rep(i,a,b) for(rg i=(a);i&lt;=(b);++i)
#define per(i,a,b) for(rg i=(a);i&gt;=(b);--i)
const int maxn = 100010;
struct Node{
    Node *ch[2],*fa;
    Node *lson,*rson;
    int siz;
    void update(){
        siz = ch[0]-&gt;siz + ch[1]-&gt;siz + 1;
    }
}*null,mem[maxn],*it;
inline void init(){
    it = mem;null = it++;
    null-&gt;ch[0] = null-&gt;ch[1] = null-&gt;fa = null;
    null-&gt;siz = 0;
    null-&gt;lson = null-&gt;rson = null;
}
inline Node* newNode(){
    Node *p = it++;p-&gt;ch[0] = p-&gt;ch[1] = p-&gt;fa = null;
    p-&gt;siz = 1;p-&gt;lson = p-&gt;rson = null;return p;
}
inline void rotate(Node *p,Node *x){
    int k = p == x-&gt;ch[1];
    Node *y = p-&gt;ch[k^1],*z = x-&gt;fa;
    if(z-&gt;ch[0] == x) z-&gt;ch[0] = p;
    if(z-&gt;ch[1] == x) z-&gt;ch[1] = p;
    if(y != null) y-&gt;fa = x;
    p-&gt;fa = z;p-&gt;ch[k^1] = x;
    x-&gt;fa = p;x-&gt;ch[k] = y;
    x-&gt;update();p-&gt;update();
}
inline bool isroot(Node *p){
    return (p == null) || (p-&gt;fa-&gt;ch[0] != p &amp;&amp; p-&gt;fa-&gt;ch[1] != p);
}
inline void Splay(Node *p){
    while(!isroot(p)){
        Node *x = p-&gt;fa,*y = x-&gt;fa;
        if(isroot(x)) rotate(p,x);
        else if( (p == x-&gt;ch[0])^(x == y-&gt;ch[0]) ) rotate(p,x),rotate(p,y);
        else rotate(x,y),rotate(p,x);
    }p-&gt;update();
}
inline void Access(Node *x){
    for(Node *y = null;x != null;y = x,x = x-&gt;fa){
        Splay(x),x-&gt;ch[1] = y,x-&gt;update();
    }
}
struct data{
    Node *p;
    int key;
    data(Node* a,const int &amp;b){
        p = a;key = b;
    }
    friend bool operator &lt; (const data &amp;a,const data &amp;b){
        return a.key &lt; b.key;
    }
};
set&lt;data&gt;S;
Node *RT;
inline int insert(int val){
    Node *p = newNode();data x(p,val);
    set&lt;data&gt;::iterator it = S.lower_bound(x);
    int dep = 0;
    if(it != S.end()){
        if(it-&gt;p-&gt;lson == null){
            it-&gt;p-&gt;lson = p;
            p-&gt;fa = it-&gt;p;
            Access(it-&gt;p);Splay(it-&gt;p);
            dep = it-&gt;p-&gt;siz;
        }
    }
    if(it != S.begin()){
        -- it;
        if(it-&gt;p-&gt;rson == null){
            it-&gt;p-&gt;rson = p;
            p-&gt;fa = it-&gt;p;
            Access(it-&gt;p);Splay(it-&gt;p);
            dep = it-&gt;p-&gt;siz;
        }
    }
    if(S.empty()) RT = p;
    S.insert(x);
    return dep + 1;
}
inline int find_min(){
    Node *p = S.begin()-&gt;p;
    Access(p);Splay(p);
    int ret = p-&gt;siz;
    if(ret == 1) return ret;
    Node *y = p-&gt;ch[0],*x = p-&gt;rson;
    while(y-&gt;ch[1] != null) y = y-&gt;ch[1];
    y-&gt;lson = x;p-&gt;rson = RT;
    p-&gt;ch[0]-&gt;fa = null;
    p-&gt;ch[0] = null;
    p-&gt;update();
    if(x != null) Splay(x),x-&gt;fa = y;
    Access(RT);Splay(RT);RT-&gt;fa = p;
    RT = p;
    return ret;
}
inline int find_max(){
    Node *p = S.rbegin()-&gt;p;
    Access(p);Splay(p);
    int ret = p-&gt;siz;
    if(ret == 1) return ret;
    Node *y = p-&gt;ch[0],*x = p-&gt;lson;
    while(y-&gt;ch[1] != null) y = y-&gt;ch[1];
    y-&gt;rson = x;p-&gt;lson = RT;
    p-&gt;ch[0]-&gt;fa = null;
    p-&gt;ch[0] = null;
    p-&gt;update();
    if(x != null) Splay(x),x-&gt;fa = y;
    Access(RT);Splay(RT);RT-&gt;fa = p;
    RT = p;
    return ret;
}
inline int del_min(){
    Node *p = S.begin()-&gt;p;
    Access(p);Splay(p);
    int ret = p-&gt;siz;
    if(ret == 1){
        Node *x = p-&gt;rson;
        if(x != null) Splay(x),x-&gt;fa = null;
        RT = x;
        S.erase(S.begin());
        return ret;
    }
    Node *x = p-&gt;rson,*y = p-&gt;ch[0];
    while(y-&gt;ch[1] != null) y = y-&gt;ch[1];
    y-&gt;lson = x;
    p-&gt;ch[0]-&gt;fa =null;
    p-&gt;ch[0] = null;
    if(x != null) Splay(x),x-&gt;fa = y;
    S.erase(S.begin());
    return ret;
}
inline int del_max(){
    Node *p = S.rbegin()-&gt;p;
     Access(p);Splay(p);
    int ret = p-&gt;siz;
    if(ret == 1){
        Node *x = p-&gt;lson;
        if(x != null) Splay(x),x-&gt;fa = null;
        RT = x;
        S.erase(*S.rbegin());
        return ret;
    }
    Node *x = p-&gt;lson,*y = p-&gt;ch[0];
    while(y-&gt;ch[1] != null) y = y-&gt;ch[1];
    y-&gt;rson = x;
    p-&gt;ch[0]-&gt;fa = null;
    p-&gt;ch[0] = null;
    if(x != null) Splay(x),x-&gt;fa = y;
    S.erase(*S.rbegin());
    return ret;
}
int main(){
    init();
    int m;read(m);
    int c,k;
    while(m--){
        read(c);
        if(c == 1){
            read(k);
            printf(&quot;%d\n&quot;,insert(k));
        }else if(c == 2) printf(&quot;%d\n&quot;,find_min());
        else if(c == 3) printf(&quot;%d\n&quot;,find_max());
        else if(c == 4) printf(&quot;%d\n&quot;,del_min());
        else if(c == 5) printf(&quot;%d\n&quot;,del_max());
    }
    return 0;
}<pre><h2>Problem4878</h2><pre>#include &lt;cstdio&gt;

#define MAXN 1005
#define MAXM 10005
#define BUFFER_SIZE 10000555

struct edge {
	int to;
	edge *nxt;
};

static char buf[BUFFER_SIZE], *s(buf);
static int from[MAXN], dep[MAXN], mxdep, mxnode;
static edge edge_mset[MAXM * 2], *cedge, *g[MAXN];

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

void dfs(int u) {
	if (dep[u] &gt; mxdep)
	  mxdep = dep[u], mxnode = u;
	for (edge *it = g[u]; it; it = it-&gt;nxt)
	  if (!dep[it-&gt;to]) {
		  from[it-&gt;to] = u;
		  dep[it-&gt;to] = dep[u] + 1;
		  dfs(it-&gt;to);
	  }
}

int main() {

	fread(buf, 1, BUFFER_SIZE, stdin);

	int o_o, n, m, k, a, b;
	for (get_int(o_o); o_o; --o_o) {
		get_int(n);
		get_int(m);
		get_int(k);
		for (register int i = 1; i &lt;= n; ++i) {
			dep[i] = 0;
			g[i] = NULL;
		}
		cedge = edge_mset;
		while (m--) {
			get_int(a);
			get_int(b);
			*cedge = (edge) {b, g[a]};
			g[a] = cedge++;
			*cedge = (edge) {a, g[b]};
			g[b] = cedge++;
		}
		mxdep = 0;
		for (register int i = n; i; --i)
		  if (!dep[i]) dep[i] = 1, dfs(i);
		if (mxdep &lt;= k) {
			printf(&quot;color&quot;);
			for (register int i = 1; i &lt;= n; ++i)
			  printf(&quot; %d&quot;, dep[i]);
			puts(&quot; &quot;);
		} else {
			printf(&quot;path&quot;);
			for (register int i = 0; i &lt;= k; ++i, mxnode = from[mxnode])
			  printf(&quot; %d&quot;, mxnode);
			puts(&quot; &quot;);
		}
	}

	return 0;
}<pre><h2>Problem4878</h2><pre>#include &lt;cstdio&gt;

#define MAXN 1005
#define MAXM 10005
#define BUFFER_SIZE 10000555

struct edge {
	int to;
	edge *nxt;
};

char buf[BUFFER_SIZE], *s(buf);
int from[MAXN], dep[MAXN], mxdep, mxnode;
edge edge_mset[MAXM * 2], *cedge, *g[MAXN];

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

inline void dfs(int u) {
	if (dep[u] &gt; mxdep) {
	  mxdep = dep[u];
	  mxnode = u;
	}
	for (edge *it = g[u]; it; it = it-&gt;nxt)
	  if (!dep[it-&gt;to]) {
		  from[it-&gt;to] = u;
		  dep[it-&gt;to] = dep[u] + 1;
		  dfs(it-&gt;to);
	  }
}

int main() {
	fread(buf, 1, BUFFER_SIZE, stdin);
	int o_o, n, m, k, a, b;
	for (get_int(o_o); o_o; --o_o) {
		get_int(n);
		get_int(m);
		get_int(k);
		for (register int i = 1; i &lt;= n; ++i) {
			dep[i] = 0;
			g[i] = NULL;
		}
		cedge = edge_mset;
		while (m--) {
			get_int(a);
			get_int(b);
			*cedge = (edge) {b, g[a]};
			g[a] = cedge++;
			*cedge = (edge) {a, g[b]};
			g[b] = cedge++;
		}
		mxdep = 0;
		for (register int i = n; i; --i)
		  if (!dep[i]) dep[i] = 1, dfs(i);
		if (mxdep &lt;= k) {
			printf(&quot;color&quot;);
			for (register int i = 1; i &lt;= n; ++i)
			  printf(&quot; %d&quot;, dep[i]);
			puts(&quot; &quot;);
		} else {
			printf(&quot;path&quot;);
			for (register int i = 0; i &lt;= k; ++i, mxnode = from[mxnode])
			  printf(&quot; %d&quot;, mxnode);
			puts(&quot; &quot;);
		}
	}
	return 0;
}
<pre><h2>Problem4878</h2><pre>#include &lt;cstdio&gt;

#define MAXN 1005
#define MAXM 10005
#define BUFFER_SIZE 10000555

struct edge {
	int to;
	edge *nxt;
};

char buf[BUFFER_SIZE], *s(buf);
int from[MAXN], dep[MAXN], mxdep, mxnode;
edge edge_mset[MAXM * 2], *cedge, *g[MAXN];

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

void dfs(int u) {
	if (dep[u] &gt; mxdep) {
	  mxdep = dep[u];
	  mxnode = u;
	}
	for (edge *it = g[u]; it; it = it-&gt;nxt)
	  if (!dep[it-&gt;to]) {
		  from[it-&gt;to] = u;
		  dep[it-&gt;to] = dep[u] + 1;
		  dfs(it-&gt;to);
	  }
}

int main() {
	fread(buf, 1, BUFFER_SIZE, stdin);
	int o_o, n, m, k, a, b;
	for (get_int(o_o); o_o; --o_o) {
		get_int(n);
		get_int(m);
		get_int(k);
		for (register int i = 1; i &lt;= n; ++i) {
			dep[i] = 0;
			g[i] = NULL;
		}
		cedge = edge_mset;
		while (m--) {
			get_int(a);
			get_int(b);
			*cedge = (edge) {b, g[a]};
			g[a] = cedge++;
			*cedge = (edge) {a, g[b]};
			g[b] = cedge++;
		}
		mxdep = 0;
		for (register int i = n; i; --i)
		  if (!dep[i]) dep[i] = 1, dfs(i);
		if (mxdep &lt;= k) {
			printf(&quot;color&quot;);
			for (register int i = 1; i &lt;= n; ++i)
			  printf(&quot; %d&quot;, dep[i]);
			puts(&quot; &quot;);
		} else {
			printf(&quot;path&quot;);
			for (register int i = 0; i &lt;= k; ++i, mxnode = from[mxnode])
			  printf(&quot; %d&quot;, mxnode);
			puts(&quot; &quot;);
		}
	}
	return 0;
}
<pre><h2>Problem4881</h2><pre>#include &lt;set&gt;
#include &lt;cstdio&gt;

#define MAXN 100005
#define MOD 998244353
#define BUFFER_SIZE 900000

static char buf[BUFFER_SIZE], *s(buf);
inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

static std::set&lt;int&gt;st;
static int c[MAXN], n;

inline int ask(int x) {
	int ret(0);
	for (; x; x ^= x &amp; -x)
	  if (c[x] &gt; ret) ret = c[x];
	return ret;
}

inline void upd(int x, const int &amp;value) {
	for (; x &lt;= n; x += x &amp; -x)
	  if (value &gt; c[x]) c[x] = value;
}

int main() {

	fread(buf, 1, BUFFER_SIZE, stdin);

	get_int(n);
	int x, ans(1), t;
	for (register int i = 1; i &lt;= n; ++i) {
		get_int(x);
		t = ask(n - x);
		if (t == 2) return puts(&quot;0&quot;), 0;
		upd(n - x + 1, t + 1);
		t = x;
		std::set&lt;int&gt;::iterator it = st.upper_bound(x);
		while (it != st.end()) {
			t = *it;
			st.erase(it++);
		}
		st.insert(t);
	}
	for (x = st.size(); x; --x)
	  if ((ans &lt;&lt;= 1) &gt;= MOD) ans -= MOD;
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4881</h2><pre>#include &lt;set&gt;
#include &lt;cstdio&gt;

#define MAXN 100005
#define MOD 998244353
#define BUFFER_SIZE 900000

static char buf[BUFFER_SIZE], *s(buf);
inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

static std::set&lt;int&gt;st;
static int c[MAXN], n;

inline int ask(int x) {
	int ret(0);
	for (; x; x ^= x &amp; -x)
	  if (c[x] &gt; ret) ret = c[x];
	return ret;
}

inline void upd(int x, const int &amp;value) {
	for (; x &lt;= n; x += x &amp; -x)
	  if (value &gt; c[x]) c[x] = value;
}

int main() {

	fread(buf, 1, BUFFER_SIZE, stdin);

	get_int(n);
	int x, ans(1), t;
	for (register int i = 1; i &lt;= n; ++i) {
		get_int(x);
		t = ask(n - x);
		if (t == 2) return puts(&quot;0&quot;), 0;
		upd(n - x + 1, t + 1);
		t = x;
		std::set&lt;int&gt;::iterator it = st.upper_bound(x);
		while (it != st.end()) {
			t = *it;
			st.erase(it++);
		}
		st.insert(t);
	}
	for (x = st.size(), t = 2; x; x &gt;&gt;= 1, t = 1llu * t * t % MOD)
		if (x &amp; 1) ans = 1llu * ans * t % MOD;
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4881</h2><pre>#include &lt;set&gt;
#include &lt;cstdio&gt;
#define MAXN 100005
#define MOD 998244353
#define BUFFER_SIZE 700000
static char buf[BUFFER_SIZE], *s(buf);
inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}
static std::set&lt;int&gt;st;
static int c[MAXN], n;
inline int ask(int x) {
	static int ret;
	for (ret = 0; x; x ^= x &amp; -x)
	  if (c[x] &gt; ret) ret = c[x];
	return ret;
}
inline void upd(int x, const int &amp;value) {
	for (; x &lt;= n; x += x &amp; -x)
	  if (value &gt; c[x]) c[x] = value;
}
int main() {
	fread(buf, 1, BUFFER_SIZE, stdin);
	get_int(n);
	register int x, ans(1), t;
	for (register int i = 1; i &lt;= n; ++i) {
		get_int(x);
		t = ask(n - x);
		if (t == 2) return puts(&quot;0&quot;), 0;
		upd(n - x + 1, t + 1);
		t = x;
		std::set&lt;int&gt;::iterator it = st.upper_bound(x);
		while (it != st.end()) {
			t = *it;
			st.erase(it++);
		}
		st.insert(t);
	}
	for (x = st.size(), t = 2; x; x &gt;&gt;= 1, t = 1llu * t * t % MOD)
		if (x &amp; 1) ans = 1llu * ans * t % MOD;
	printf(&quot;%d\n&quot;, ans);
	return 0;
}<pre><h2>Problem4884</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;


typedef long long arr[100005];

inline long long min(const long long &amp;A, const long long &amp;B) {
	return A &lt; B ? A : B;
}

int main() {
	static int n;
	static arr c, f, up ,down;

	memset(up, 63, sizeof up);
	memset(down, 63, sizeof down);
	
	scanf(&quot;%d&quot;, &amp;n);

	for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, c + i);
	for (register int i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, f + i);
	
	up[1] = c[1] - f[1], down[1] = 0;
	for (register int i = 2; i &lt;= n; ++i) {
		if (c[i] &gt;= c[i - 1] &amp;&amp; f[i] &lt; c[i - 1]) 
		  up[i] = up[i - 1];
		if (f[i] &lt;= f[i - 1] &amp;&amp; c[i] &gt; f[i - 1])
		  down[i] = down[i - 1];
		up[i] = min(up[i], down[i] + c[i] - f[i]);
		down[i] = min(down[i], up[i] + c[i] - f[i]);
		up[i] = min(up[i], down[i] + c[i] - f[i]);
		down[i] = min(down[i], up[i] + c[i] - f[i]);
	}
	
	if (down[n] &gt;= 0x3f3f3f3f3f3f3f3f)
	  puts(&quot;-1&quot;);
	else 
	  printf(&quot;%lld\n&quot;, down[n]);

	return 0;
}<pre><h2>Problem4884</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define BUFFER_SIZE 10000555

typedef long long arr[100005];

static char buf[BUFFER_SIZE], *s(buf);

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

inline void cmin( long long &amp;A, const long long &amp;B) {
	if (B &lt; A) A = B;
}

int main() {
	static int n;
	static arr up ,down;
	static int c[100005], f[100005];
	memset(up, 63, sizeof up);
	memset(down, 63, sizeof down);

	fread(buf, 1, BUFFER_SIZE, stdin);


	get_int(n);

	for (register int i = 1; i &lt;= n; ++i) get_int(c[i]);
	for (register int i = 1; i &lt;= n; ++i) get_int(f[i]);

	up[1] = c[1] - f[1], down[1] = 0;
	for (register int i = 2; i &lt;= n; ++i) {
		if (c[i] &gt;= c[i - 1] &amp;&amp; f[i] &lt; c[i - 1]) 
		  up[i] = up[i - 1];
		if (f[i] &lt;= f[i - 1] &amp;&amp; c[i] &gt; f[i - 1])
		  down[i] = down[i - 1];
		cmin(up[i], down[i] + c[i] - f[i]);
		cmin(down[i], up[i] + c[i] - f[i]);
		cmin(up[i], down[i] + c[i] - f[i]);
		if (down[i] &gt;= 0x3f3f3f3f3f3f3f3f &amp;&amp; up[i] &gt;= 0x3f3f3f3f3f3f3f3f)
		  break;
	}

	if (down[n] &gt;= 0x3f3f3f3f3f3f3f3f)
	  puts(&quot;-1&quot;);
	else
	  printf(&quot;%lld\n&quot;, down[n]);

	return 0;
}<pre><h2>Problem4884</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define BUFFER_SIZE 10000555

typedef long long arr[100005];

static char buf[BUFFER_SIZE], *s(buf);

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

inline void cmin( long long &amp;A, const long long &amp;B) {
	if (B &lt; A) A = B;
}

int main() {
	static int n;
	static arr up ,down;
	static int c[100005], f[100005];
	memset(up, 63, sizeof up);
	memset(down, 63, sizeof down);

	fread(buf, 1, BUFFER_SIZE, stdin);


	get_int(n);

	for (register int i = 1; i &lt;= n; ++i) get_int(c[i]);
	for (register int i = 1; i &lt;= n; ++i) get_int(f[i]);

	up[1] = c[1] - f[1], down[1] = 0;
	for (register int i = 2; i &lt;= n; ++i) {
		if (c[i] &gt;= c[i - 1] &amp;&amp; f[i] &lt; c[i - 1]) 
		  up[i] = up[i - 1];
		if (f[i] &lt;= f[i - 1] &amp;&amp; c[i] &gt; f[i - 1])
		  down[i] = down[i - 1];
		cmin(up[i], down[i] + c[i] - f[i]);
		cmin(down[i], up[i] + c[i] - f[i]);
		cmin(up[i], down[i] + c[i] - f[i]);
		//if (down[i] &gt;= 0x3f3f3f3f3f3f3f3f &amp;&amp; up[i] &gt;= 0x3f3f3f3f3f3f3f3f)
		// break;
	}
	if (down[n] &gt;= 0x3f3f3f3f3f3f3f3f)
	  puts(&quot;-1&quot;);
	else
	  printf(&quot;%lld\n&quot;, down[n]);
	return 0;
}<pre><h2>Problem4884</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define BUFFER_SIZE 5000555

typedef long long arr[100005];

static char buf[BUFFER_SIZE], *s(buf);

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

inline void cmin( long long &amp;A, const long long &amp;B) {
	if (B &lt; A) A = B;
}

int main() {

	static int n;
	static arr up ,down;
	static int c[100005], f[100005];

	memset(up, 63, sizeof up);
	memset(down, 63, sizeof down);

	fread(buf, 1, BUFFER_SIZE, stdin);


	get_int(n);

	for (register int i = 1; i &lt;= n; ++i) get_int(c[i]);
	for (register int i = 1; i &lt;= n; ++i) get_int(f[i]);

	up[1] = c[1] - f[1], down[1] = 0;
	for (register int i = 2; i &lt;= n; ++i) {
		if (c[i] &gt;= c[i - 1] &amp;&amp; f[i] &lt; c[i - 1]) 
		  up[i] = up[i - 1];
		if (f[i] &lt;= f[i - 1] &amp;&amp; c[i] &gt; f[i - 1])
		  down[i] = down[i - 1];
		cmin(up[i], down[i] + c[i] - f[i]);
		cmin(down[i], up[i] + c[i] - f[i]);
		cmin(up[i], down[i] + c[i] - f[i]);
	}
	if (down[n] &gt;= 0x3f3f3f3f3f3f3f3f)
	  puts(&quot;-1&quot;);
	else
	  printf(&quot;%lld\n&quot;, down[n]);
	return 0;
}<pre><h2>Problem4884</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define BUFFER_SIZE 2000000

typedef long long arr[100005];

static char buf[BUFFER_SIZE], *s(buf);

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

inline void cmin( long long &amp;A, const long long &amp;B) {
	if (B &lt; A) A = B;
}

int main() {

	static int n;
	static arr up ,down;
	static int c[100005], f[100005];

	memset(up, 63, sizeof up);
	memset(down, 63, sizeof down);

	fread(buf, 1, BUFFER_SIZE, stdin);


	get_int(n);

	for (register int i = 1; i &lt;= n; ++i) get_int(c[i]);
	for (register int i = 1; i &lt;= n; ++i) get_int(f[i]);

	up[1] = c[1] - f[1], down[1] = 0;
	for (register int i = 2; i &lt;= n; ++i) {
		if (c[i] &gt;= c[i - 1] &amp;&amp; f[i] &lt; c[i - 1]) 
		  up[i] = up[i - 1];
		if (f[i] &lt;= f[i - 1] &amp;&amp; c[i] &gt; f[i - 1])
		  down[i] = down[i - 1];
		cmin(up[i], down[i] + c[i] - f[i]);
		cmin(down[i], up[i] + c[i] - f[i]);
		cmin(up[i], down[i] + c[i] - f[i]);
	}
	if (down[n] &gt;= 0x3f3f3f3f3f3f3f3f)
	  puts(&quot;-1&quot;);
	else
	  printf(&quot;%lld\n&quot;, down[n]);
	return 0;
}
<pre><h2>Problem4884</h2><pre>#include &lt;cstdio&gt;

#define BUFFER_SIZE 2000000

typedef long long arr[100005];

static char buf[BUFFER_SIZE], *s(buf);

inline void get_int(int &amp;a) {
	while (*s &lt; 48) ++s;
	a = *s++ ^ 48;
	while (47 &lt; *s)
	  a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

inline void cmin( long long &amp;A, const long long &amp;B) {
	if (B &lt; A) A = B;
}

int main() {

	static int n;
	static arr up ,down;
	static int c[100005], f[100005];

	//memset(up, 63, sizeof up);
	//memset(down, 63, sizeof down);

	fread(buf, 1, BUFFER_SIZE, stdin);


	get_int(n);

	for (register int i = 1; i &lt;= n; ++i) get_int(c[i]);
	for (register int i = 1; i &lt;= n; ++i) get_int(f[i]);

	up[1] = c[1] - f[1], down[1] = 0;
	for (register int i = 2; i &lt;= n; ++i) {
		up[i] = down[i] = 0x3f3f3f3f3f3f3f3f;
		if (c[i] &gt;= c[i - 1] &amp;&amp; f[i] &lt; c[i - 1]) 
		  up[i] = up[i - 1];
		if (f[i] &lt;= f[i - 1] &amp;&amp; c[i] &gt; f[i - 1])
		  down[i] = down[i - 1];
		cmin(up[i], down[i] + c[i] - f[i]);
		cmin(down[i], up[i] + c[i] - f[i]);
		cmin(up[i], down[i] + c[i] - f[i]);
	}
	if (down[n] &gt;= 0x3f3f3f3f3f3f3f3f)
	  puts(&quot;-1&quot;);
	else
	  printf(&quot;%lld\n&quot;, down[n]);
	return 0;
}
<pre><h2>Problem4900</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

#define MAXN 20000003

short seed;
int n, k, S, mx = -0x3f3f3f3f;
int p[MAXN], q[MAXN], C[MAXN * 2];

inline int getrand() {
	return seed = ((seed * 12321) ^ 9999) &amp; 32767;
}
inline void generateData() {
	scanf(&quot;%d%d%d&quot;, &amp;k, &amp;seed, &amp;S);
	int t = 0;
	n = k &lt;&lt; 1 | 1;
	memset(p, 0, sizeof(p));
	for (register int i = 1; i &lt;= n; ++i) {
		p[i] = getrand() &gt;&gt; 7 &amp; 1;
		t += p[i];
	}
	int i = 1;
	while (t &gt; k) {
		while (p[i] == 0)
			++i;
		p[i] = 0;
		--t;
	}
	while (t &lt; k) {
		while (p[i] == 1)
			++i;
		p[i] = 1;
		++t;
	}
}

inline int Try(int value) {
	int o = mx;
	while (value &gt;= C[o]) value -= C[o--];
	for(register int i = n; i &gt;= 1; --i)
		if(!p[i] &amp;&amp; q[i] == o &amp;&amp; !value--) return i;
}

int main() {
	generateData();
	q[0] = MAXN;
	for (register int i = 1; i &lt;= n; ++i) {
		q[i] = q[i - 1] + 1;
		if (!p[i]) {
			++C[q[i] -= 2];
			if (q[i] &gt; mx) mx = q[i];
		}
	}
	printf(&quot;%d\n&quot;, Try(0));
	printf(&quot;%d\n&quot;, Try(S));
	printf(&quot;%d\n&quot;, Try(k - S));
	return 0;
}<pre><h2>Problem4904</h2><pre>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define S 230
#define N 50003
#define Q 200003

struct Query {
    int indedx, m, k;

    inline bool operator &lt; (const Query &amp;other) const {
        return m &lt; other.m;
    }

} QueryList[Q];

struct YoungTable {

    vector &lt; int &gt; a[S + 1];

    pair &lt; int, int &gt; insert(int x) {
        int xx = 0, yy = 0;
        for (int i = 1; i &lt;= S; ++i)
            if (a[i].empty() || a[i].back() &lt; x) {
                a[i].push_back(x);
                xx = i, yy = a[i].size();
                break;
            } else {
                vector &lt; int &gt; :: iterator k = lower_bound(a[i].begin(), a[i].end(), x);
                swap(*k, x);
            }
        return make_pair(xx, yy);
    }

} u, d;

int n, q, ans[Q], sum[N], a[N], rk[N];

void Add(int o) {
    for (; o &lt;= n; o += o &amp; -o) ++sum[o];
}

int Ask(int o) {
    int res = 0;
    for (; o; o ^= o &amp; -o) res += sum[o];
    return res;
}

void Insert(int o) {
    int k = u.insert(o).first;
    if (k) Add(k);
    k = d.insert(-o).second;
    if (k &gt; S) Add(k);
}

inline bool compareRk(const int &amp;x, const int &amp;y) {
    return a[x] &lt; a[y] || (a[x] == a[y] &amp;&amp; x &gt; y);
}

int main() {

    scanf(&quot;%d %d&quot;, &amp;n, &amp;q);
    for (int i = 1; i &lt;= n; ++i) {
        rk[i] = i;
        scanf(&quot;%d&quot;, a + i);
    }
    sort(rk + 1, rk + n + 1, compareRk);
    //sort(rk + 1, rk + n + 1, [&amp;](const int &amp;x, const int &amp;y) { return a[x] &lt; a[y] || (a[x] == a[y] &amp;&amp; x &gt; y); } );
    for (int i = 1; i &lt;= n; ++i)
        a[rk[i]] = n - i + 1;

    for (int i = 1; i &lt;= q; ++i) {
        QueryList[i].indedx = i;
        scanf(&quot;%d %d&quot;, &amp;QueryList[i].m, &amp;QueryList[i].k);
    }
    sort(QueryList + 1, QueryList + q + 1);

    int now = 1;
    for (int i = 1; i &lt;= n; ++i) {
        Insert(a[i]);
        for (; now &lt;= q &amp;&amp; QueryList[now].m == i; ++now)
            ans[QueryList[now].indedx] = Ask(QueryList[now].k);
    }

    for (int i = 1; i &lt;= q; ++i)
        printf(&quot;%d\n&quot;, ans[i]);

    return 0;
}
<pre><h2>Problem4915</h2><pre>#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
ll l,r;
int main(){
  scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r);
  puts(&quot;4&quot;);
  printf(&quot;%lld\n&quot;,max(r/11ll-l+1,0ll)+max(r/29ll-l+1,0ll));
  return 0;
}<pre><h2>Problem4915</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
  long long l, r;
  scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r);
  printf(&quot;4\n%lld\n&quot;, max(r / 11 - l + 1, 0ll) + max(r / 29 - l + 1, 0ll));
  return 0;
}
<pre><h2>Problem4917</h2><pre>#include &lt;cstdio&gt;

typedef unsigned int ui;

inline ui inv(ui x) {
  ui re = 1;
  for (ui mu = (1u &lt;&lt; 31) - 1; mu; mu &gt;&gt;= 1, x *= x) {
    if (mu &amp; 1) {
      re *= x;
    }
  }
  return re;
}

int main() {
  const ui inv3 = inv((1u &lt;&lt; 3) + 1);
  const ui inv10 = inv((1u &lt;&lt; 10) + 1);
  const ui inv16 = inv((1u &lt;&lt; 16) + 1);
  ui o_o, x;
  scanf(&quot;%u&quot;, &amp;o_o);
  while (o_o--) {
    scanf(&quot;%u&quot;, &amp;x);
    x *= inv16;
    for (int i = 20; ~i; --i) {
      x ^= (x &gt;&gt; (i + 11) &amp; 1) &lt;&lt; i;
    }
    x *= inv3;
    for (int i = 25; ~i; --i) {
      x ^= (x &gt;&gt; (i + 6) &amp; 1) &lt;&lt; i;
    }
    x *= inv10;
    printf(&quot;%u\n&quot;, x);
  }
  return 0;
}<pre><h2>Problem4917</h2><pre>#include &lt;cstdio&gt;

typedef unsigned int ui;

#define BUFFER_SIZE 10000000

char buffer[BUFFER_SIZE], *s = buffer;

inline void get_int(ui &amp;a) {
    while (*s &lt; 48) ++s;
    a = *s++ ^ 48;
    while (47 &lt; *s)
      a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}

inline ui inv(ui x) {
  ui re = 1;
  for (ui mu = (1u &lt;&lt; 31) - 1; mu; mu &gt;&gt;= 1, x *= x) {
    if (mu &amp; 1) {
      re *= x;
    }
  }
  return re;
}

int main() {
  const ui inv3 = inv((1u &lt;&lt; 3) + 1);
  const ui inv10 = inv((1u &lt;&lt; 10) + 1);
  const ui inv16 = inv((1u &lt;&lt; 16) + 1);
  ui o_o, x;
  fread(buffer, 1, BUFFER_SIZE, stdin);
  //scanf(&quot;%u&quot;, &amp;o_o);
  get_int(o_o);
  while (o_o--) {
    //scanf(&quot;%u&quot;, &amp;x);
    get_int(x);
    x *= inv16;
    for (int i = 20; ~i; --i) {
      x ^= (x &gt;&gt; (i + 11) &amp; 1) &lt;&lt; i;
    }
    x *= inv3;
    for (int i = 25; ~i; --i) {
      x ^= (x &gt;&gt; (i + 6) &amp; 1) &lt;&lt; i;
    }
    x *= inv10;
    printf(&quot;%u\n&quot;, x);
  }
  return 0;
}
<pre><h2>Problem4917</h2><pre>#include &lt;cstdio&gt;

typedef unsigned int ui;

#define BUFFER_SIZE 10000000

char buffer[BUFFER_SIZE], *s = buffer;

inline void get_int(ui &amp;a) {
    while (*s &lt; 48) ++s;
    a = *s++ ^ 48;
    while (47 &lt; *s)
      a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
}
int main() {
  
  //const ui inv3 = inv((1u &lt;&lt; 3) + 1);
  //const ui inv10 = inv((1u &lt;&lt; 10) + 1);
  //const ui inv16 = inv((1u &lt;&lt; 16) + 1);
  //printf(&quot;%u\n%u\n%u\n&quot;, inv3, inv10, inv16);
  const ui inv3 = 954437177u;
  const ui inv10 = 3222273025u;
  const ui inv16 = 4294901761u;
  ui o_o, x;
  fread(buffer, 1, BUFFER_SIZE, stdin);
  //scanf(&quot;%u&quot;, &amp;o_o);
  get_int(o_o);
  //o_o = 0;
  while (o_o--) {
    //scanf(&quot;%u&quot;, &amp;x);
    get_int(x);
    x *= inv16;
    for (int i = 20; ~i; --i) {
      x ^= (x &gt;&gt; (i + 11) &amp; 1) &lt;&lt; i;
    }
    x *= inv3;
    for (int i = 25; ~i; --i) {
      x ^= (x &gt;&gt; (i + 6) &amp; 1) &lt;&lt; i;
    }
    x *= inv10;
    printf(&quot;%u\n&quot;, x);
  }
  return 0;
}<pre><h2>Problem4917</h2><pre>#include &lt;cstdio&gt;

typedef unsigned int ui;

#define BUFFER_SIZE 5000000

char buffer[BUFFER_SIZE], *s = buffer;

inline void get_int(ui &amp;a) {
  while (*s &lt; 48) ++s;
  a = *s++ ^ 48;
  while (47 &lt; *s) {
    a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (*s++ ^ 48);
  }
}

int main() {
  const ui inv3 = 954437177u;
  const ui inv10 = 3222273025u;
  const ui inv16 = 4294901761u;
  ui o_o, x;
  fread(buffer, 1, BUFFER_SIZE, stdin);
  get_int(o_o);
  while (o_o--) {
    get_int(x);
    x *= inv16;
    for (int i = 20; ~i; --i) {
      x ^= (x &gt;&gt; (i + 11) &amp; 1) &lt;&lt; i;
    }
    x *= inv3;
    for (int i = 25; ~i; --i) {
      x ^= (x &gt;&gt; (i + 6) &amp; 1) &lt;&lt; i;
    }
    x *= inv10;
    printf(&quot;%u\n&quot;, x);
  }
  return 0;
}<pre><h2>Problem4942</h2><pre>#include &lt;cstdio&gt;

int s[2][30000032];
const int BASE = 33554432;
int tr[BASE * 2 + 5];

int main() {
  int n;
  scanf(&quot;%d %*d %*d %*d&quot;, &amp;n);
  for (int step = 0; step &lt; n; ++step) {
    int operation;
    scanf(&quot;%d&quot;, &amp;operation);
    if (operation == 1) {
      int k, l, poi = 0;
      scanf(&quot;%d %d&quot;, &amp;k, &amp;l);
      if (k &lt; 0) {
        k = -k;
        poi = 1;
      }
      int r = l;
      while (k != 0) {
        s[poi][r] += k &amp; 1;
        k &gt;&gt;= 1;
        ++r;
      }
      for (int i = l; i &lt;= r; ++i) {
        s[poi][i + 1] += (s[poi][i] &amp; 2) &gt;&gt; 1;
        s[poi][i] &amp;= 1;
      }
      ++r;
      while ((s[poi][r] &amp; 2) != 0) {
        s[poi][r++] &amp;= 1;
        s[poi][r] += 1;
      }

      l += BASE;
      r += BASE;
      for (int i = l; i &lt;= r; ++i)
        tr[i] = s[0][i - BASE] ^ s[1][i - BASE];
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
      while (l != 0) {
        for (int i = l; i &lt;= r; ++i)
          tr[i] = tr[i &lt;&lt; 1] | tr[i &lt;&lt; 1 | 1];
        l &gt;&gt;= 1;
        r &gt;&gt;= 1;
      }

    } else {
      int k;
      scanf(&quot;%d&quot;, &amp;k);
      int l = k, fg = 0;
      for (l += BASE; l != 0; l &gt;&gt;= 1) if ((l &amp; tr[l ^ 1] &amp; 1) != 0) {
          fg = 1;
          l ^= 1;
          for (; l &lt; BASE; l = l &lt;&lt; 1 | tr[l &lt;&lt; 1 | 1]);
          break;
        }
      l -= BASE;
      if (fg == 0 || s[0][l] == 1) puts((s[0][k] ^ s[1][k]) != 0 ? &quot;1&quot; : &quot;0&quot;);
      else puts((s[0][k] == s[1][k]) ? &quot;1&quot; : &quot;0&quot;);
    }
  }
  return 0;
}<pre><h2>Problem4942</h2><pre>#include &lt;cstdio&gt;

int s[2][30000032];
const int BASE = 33554432;
int tr[BASE * 2 + 5];

#define getchar_unlocked getchar

inline void get_int(int &amp;a) {
  register char c;
  register char sign = 0;
  do {
    c = getchar_unlocked();
    if (c == '-') sign = 1;
  } while (c &lt; 48);
  a = c ^ 48;
  while (47 &lt; (c = getchar_unlocked()))
    a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (c ^ 48);
  if (sign) a = -a;
}

int main() {
  int n;
  get_int(n);
  scanf(&quot;%*d %*d %*d&quot;);
  for (int step = 0; step &lt; n; ++step) {
    int operation;
    get_int(operation);
    if (operation == 1) {
      int k, l, poi = 0;
      get_int(k);
      get_int(l);
      if (k &lt; 0) {
        k = -k;
        poi = 1;
      }
      int r = l;
      while (k != 0) {
        s[poi][r] += k &amp; 1;
        k &gt;&gt;= 1;
        ++r;
      }
      for (int i = l; i &lt;= r; ++i) {
        s[poi][i + 1] += (s[poi][i] &amp; 2) &gt;&gt; 1;
        s[poi][i] &amp;= 1;
      }
      ++r;
      while ((s[poi][r] &amp; 2) != 0) {
        s[poi][r++] &amp;= 1;
        s[poi][r] += 1;
      }

      l += BASE;
      r += BASE;
      for (int i = l; i &lt;= r; ++i)
        tr[i] = s[0][i - BASE] ^ s[1][i - BASE];
      l &gt;&gt;= 1;
      r &gt;&gt;= 1;
      while (l != 0) {
        for (int i = l; i &lt;= r; ++i)
          tr[i] = tr[i &lt;&lt; 1] | tr[i &lt;&lt; 1 | 1];
        l &gt;&gt;= 1;
        r &gt;&gt;= 1;
      }

    } else {
      int k;
      get_int(k);
      int l = k, fg = 0;
      for (l += BASE; l != 0; l &gt;&gt;= 1) if ((l &amp; tr[l ^ 1] &amp; 1) != 0) {
          fg = 1;
          l ^= 1;
          for (; l &lt; BASE; l = l &lt;&lt; 1 | tr[l &lt;&lt; 1 | 1]);
          break;
        }
      l -= BASE;
      if (fg == 0 || s[0][l] == 1) puts((s[0][k] ^ s[1][k]) != 0 ? &quot;1&quot; : &quot;0&quot;);
      else puts((s[0][k] == s[1][k]) ? &quot;1&quot; : &quot;0&quot;);
    }
  }
  return 0;
}<pre><h2>Problem4949</h2><pre>import java.io.*;
import java.util.*;
import java.lang.*;

class FastReader {
    static BufferedReader reader;
    static StringTokenizer tokenizer;

    static void init(InputStream input) {
        reader = new BufferedReader(new InputStreamReader(input));
        tokenizer = new StringTokenizer(&quot;&quot;);
    }

    static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }

}

public class Main {

    private static int[] who;
    private static int[] kind;
    private static int[] UnknownByKind;
    private static int[] FiveByKind;
    private static int[][] answers;
    private static int[][] suggestions;
    private static int[] remaining;
    private static boolean[] canBe;

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader();
        in.init(System.in);
        int n = in.nextInt();
        who = new int[21];
        kind = new int[21];
        canBe = new boolean[21];
        Arrays.fill(kind, 2);
        for (int i = 0; i &lt; 6; ++i) kind[i] = 0;
        for (int i = 6; i &lt; 12; ++i) kind[i] = 1;
        UnknownByKind = new int[3];
        for (int x : kind) ++UnknownByKind[x];
        FiveByKind = new int[3];
        for (int i = 0; i &lt; 5; ++i) {
            int a = in.next().charAt(0) - 'A';
            who[a] = 1;
            --UnknownByKind[kind[a]];
        }
        answers = new int[n][];
        suggestions = new int[n][3];
        for (int step = 0; step &lt; n; ++step) {
            for (int i = 0; i &lt; 3; ++i)
                suggestions[step][i] = in.next().charAt(0) - 'A';
            int len = 0;
            int[] cur = new int[3];
            for (int i = 0; i &lt; 3; ++i) {
                String a = in.next();
                ++len;
                if (a.equals(&quot;-&quot;)) {
                    cur[i] = -1;
                    continue;
                }
                cur[i] = a.equals(&quot;*&quot;) ? -2 : a.charAt(0) - 'A';
                break;
            }
            answers[step] = Arrays.copyOf(cur, len);
        }
        remaining = new int[]{0, 0, 5, 4, 4, 3};
        rec(0);
        char[] Result = new char[]{findOne(0, 6), findOne(6, 12), findOne(12, 21)};
        System.out.println(Result);
    }

    private static char findOne(int left, int right) {
        int r = -1;
        for (int i = left; i &lt; right; ++i)
            if (canBe[i])
                r = (r == -1) ? i : -2;
        if (r == -1) throw new RuntimeException();
        return (r == -2) ? '?' : (char) ('A' + r);
    }

    private static void rec(int p) {
        if (p &gt;= answers.length) {
            for (int i = 0; i &lt; 21; ++i)
                if (who[i] == 5 || (who[i] == 0 &amp;&amp; FiveByKind[kind[i]] == 0))
                    canBe[i] = true;
        } else {
            for (int i = 0; i &lt; 3; ++i) {
                int x = suggestions[p][i];
                if (who[x] == 0) {
                    for (int u = 2; u &lt; 6; ++u)
                        if (remaining[u] &gt; 0) {
                            who[x] = u;
                            --remaining[u];
                            --UnknownByKind[kind[x]];
                            if (u == 5) ++FiveByKind[kind[x]];
                            if (FiveByKind[kind[x]] == 1 || (FiveByKind[kind[x]] == 0 &amp;&amp; UnknownByKind[kind[x]] &gt; 0))
                                rec(p);
                            who[x] = 0;
                            ++remaining[u];
                            ++UnknownByKind[kind[x]];
                            if (u == 5) --FiveByKind[kind[x]];
                        }
                    return;
                }
            }
            for (int i = 0; i &lt; answers[p].length; ++i) {
                int w = (p + i + 1) % 4 + 1;
                int a = answers[p][i];
                if (a == -1) {
                    for (int x : suggestions[p])
                        if (who[x] == w) return;
                } else if (a == -2) {
                    boolean any = false;
                    for (int x : suggestions[p])
                        if (who[x] == w) {
                            any = true;
                            break;
                        }
                    if (!any) return;
                } else {
                    if (who[a] != w) return;
                }
            }
            rec(p + 1);
        }
    }
}<pre><h2>Problem4950</h2><pre>import java.io.*;
import java.util.*;
import java.lang.*;
import java.math.*;

public class Main {

     private static Reader in;
     private static PrintWriter out;
     public static void main(String[] args) throws Exception {
          in = new Reader( System.in );
          out = new PrintWriter( System.out );

          TaskSolution solver = new TaskSolution();
          solver.solve(in, out);

          out.close();
     }

     static class TaskSolution {

          public void solve(Reader in, PrintWriter out) throws Exception {
               int rows = in.nextInt();
               int cols = in.nextInt();
               int[][] h = new int[rows][cols];
               int[] maxRow = new int[rows];
               int[] maxCol = new int[cols];
               for (int i = 0; i &lt; rows; ++i)
                    for (int j = 0; j &lt; cols; ++j) {
                         h[i][j] = in.nextInt();
                         maxRow[i] = Math.max(maxRow[i], h[i][j]);
                         maxCol[j] = Math.max(maxCol[j], h[i][j]);
                    }
               int usedCells = 0;
               long res = 0;
               for (int i = 0; i &lt; rows; ++i)
                    for (int j = 0; j &lt; cols; ++j) {
                         res += h[i][j];
                         if (h[i][j] &gt; 0) ++usedCells;
                    }
               int[] vals = new int[rows + cols];
               System.arraycopy(maxRow, 0, vals, 0, rows);
               System.arraycopy(maxCol, 0, vals, rows, cols);
               Arrays.sort(vals);
               int[] curR = new int[rows];
               int[] curC = new int[cols];
               for (int i = 0; i &lt; vals.length; ++i) {
                    if (vals[i] == 0 || i &gt; 0 &amp;&amp; vals[i] == vals[i - 1]) continue;
                    int nr = 0;
                    int nc = 0;
                    for (int r = 0; r &lt; rows; ++r)
                         if (maxRow[r] == vals[i])
                              curR[nr++] = r;
                    for (int c = 0; c &lt; cols; ++c)
                         if (maxCol[c] == vals[i])
                              curC[nc++] = c;
                    boolean[][] g = new boolean[nr][nc];
                    for (int a = 0; a &lt; nr; ++a)
                         for (int b = 0; b &lt; nc; ++b)
                              g[a][b] = h[curR[a]][curC[b]] &gt; 0;
                    int use = nr + nc - maxMatching(g, nr, nc);
                    usedCells -= use;
                    res -= use * (long) vals[i];
               }
               res -= usedCells;
               out.println(res);
          }

          private int maxMatching(boolean[][] g, int nr, int nc) {
               int res = 0;
               int[] match = new int[nc];
               Arrays.fill(match, -1);
               boolean[] mark = new boolean[nr];
               for (int i = 0; i &lt; nr; ++i) {
                    if (dfs(i, g, match, mark)) {
                         ++res;
                         Arrays.fill(mark, false);
                    }
               }
               return res;
          }

          private boolean dfs(int at, boolean[][] g, int[] match, boolean[] mark) {
               mark[at] = true;
               for (int i = 0; i &lt; match.length; ++i)
                    if (match[i] &lt; 0 &amp;&amp; g[at][i]) {
                         match[i] = at;
                         return true;
                    }
               for (int i = 0; i &lt; match.length; ++i)
                    if (g[at][i] &amp;&amp; !mark[match[i]]) {
                         if (dfs(match[i], g, match, mark)) {
                              match[i] = at;
                              return true;
                         }
                    }
               return false;
          }

     }

}

class Reader {

     static BufferedReader reader;
     static StringTokenizer tokenizer;

     Reader(InputStream input) {
          reader = new BufferedReader ( new InputStreamReader(input) );
          tokenizer = new StringTokenizer(&quot;&quot;);
     }

     static String next() throws Exception {
          while (!tokenizer.hasMoreTokens())
               tokenizer = new StringTokenizer(reader.readLine());
          return tokenizer.nextToken();
     }

     static int nextInt() throws Exception {
          return Integer.parseInt( next() );
     }

     static double nextDouble() throws Exception {
          return Double.parseDouble( next() );
     }

     static long nextLong() throws Exception {
          return Long.parseLong( next() );
     }

}
<pre><h2>Problem4956</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

bool e[26][26];
char s1[51], s2[51];

int main() {
  int m, n;
  while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) {
    for (int i = 0; i &lt; 26; ++i) {
      for (int j = 0; j &lt; 26; ++j) {
        e[i][j] = i == j;
      }
    }
    while (m--) {
      char a, b;
      scanf(&quot;\n%c %c&quot;, &amp;a, &amp;b);
      e[a - 'a'][b - 'a'] = true;
    }
    for (int k = 0; k &lt; 26; ++k) {
      for (int i = 0; i &lt; 26; ++i) {
        for (int j = 0; j &lt; 26; ++j) {
          if (!e[i][j]) {
            e[i][j] = e[i][k] &amp; e[k][j];
          }
        }
      }
    }
    while (n--) {
      scanf(&quot;%s %s&quot;, s1, s2);
      int l1 = strlen(s1);
      int l2 = strlen(s2);
      if (l1 != l2) {
        puts(&quot;no&quot;);
      } else {
        bool flag = true;
        for (int i = 0; i &lt; l1; ++i) {
          if (!e[s1[i] - 'a'][s2[i] - 'a']) {
            flag = false;
            break;
          }
        }
        puts(flag ? &quot;yes&quot; : &quot;no&quot;);
      }
    }
  }
  return 0;
}

<pre><h2>Problem4956</h2><pre>#include &lt;cstdio&gt;
#define rep(i, a, b) for (int i = a; i &lt; b; ++i)
int main() {
  int n, m;
  scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
  bool e[26][26];
  rep (i, 0, 26) rep (j, 0, 26)
    e[i][j] = i == j;
  while (m--) {
    char a, b;
    scanf(&quot;\n%c %c&quot;, &amp;a, &amp;b);
    e[a - 'a'][b - 'a'] = true;
  }
  rep (k, 0, 26) rep (i, 0, 26) rep (j, 0, 26)
    e[i][j] |= e[i][k] &amp; e[k][j];
  char s1[51], s2[51], *i, *j;
  while (n--) {
    bool flag = true;
    scanf(&quot;%s %s&quot;, s1, s2);
    for (i = s1, j = s2; *i; ++i, ++j)
      if (*j == 0 || !e[*i - 'a'][*j - 'a']) {
        flag = false;
        break;
      }
    if (flag &amp;&amp; *j == 0) puts(&quot;yes&quot;);
    else puts(&quot;no&quot;);
  }
  return 0;
}
<pre><h2>Problem4956</h2><pre>#include&lt;cstdio&gt;
#define rep(i, a, b) for (int i = a; i &lt; b; ++i)
int main(){int n,m;scanf(&quot;%d%d&quot;,&amp;m,&amp;n);bool e[26][26];rep(i, 0, 26) rep(j, 0, 26)e[i][j]=i==j;while(m--){char a,b;scanf(&quot;\n%c %c&quot;,&amp;a,&amp;b);e[a-'a'][b-'a']=1;}
  rep (k, 0, 26) rep (i, 0, 26) rep (j, 0, 26)
    e[i][j] |= e[i][k] &amp; e[k][j];
  char s1[51], s2[51], *i, *j;
  while (n--) {
    bool flag = true;
    scanf(&quot;%s %s&quot;, s1, s2);
    for (i = s1, j = s2; *i; ++i, ++j)
      if (*j == 0 || !e[*i - 'a'][*j - 'a']) {
        flag = false;
        break;
      }
    if (flag &amp;&amp; *j == 0) puts(&quot;yes&quot;);
    else puts(&quot;no&quot;);
  }
  return 0;
}
<pre><h2>Problem4956</h2><pre>#include&lt;cstdio&gt;
#define rep(i, a, b) for (int i = a; i &lt; b; ++i)
int main(){int n,m;scanf(&quot;%d%d&quot;,&amp;m,&amp;n);bool e[26][26];rep(i,0,26)rep(j,0,26)e[i][j]=i==j;while(m--){char a,b;scanf(&quot;\n%c %c&quot;,&amp;a,&amp;b);e[a-'a'][b-'a']=1;}rep(k,0,26)rep(i,0,26)rep(j,0,26)e[i][j]|=e[i][k]&amp;e[k][j];char s1[51],s2[51],*i,*j;while(n--){bool flag=true;scanf(&quot;%s%s&quot;,s1,s2);for(i=s1,j=s2;*i;++i,++j)if (*j == 0 || !e[*i - 'a'][*j - 'a']) {
  flag = false;
        break;
      }
    if (flag &amp;&amp; *j == 0) puts(&quot;yes&quot;);
    else puts(&quot;no&quot;);
  }
  return 0;
}
<pre><h2>Problem4959</h2><pre>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define DEBUG false

inline void syntax_error() {
  puts(&quot;syntax error&quot;);
  exit(0);
}

struct event {
  int x, yi, yj, type;
  event(int x, int yi, int yj, int type) :
    x(x), yi(yi), yj(yj), type(type) {}
  inline bool operator &lt; (const event &amp; another) const {
    if (x != another.x) {
      return x &lt; another.x;
    } else {
      return type &gt; another.type;
    }
  }
};

vector &lt; event &gt; e;

#define MAXN 2000007

int n, ans[MAXN];
int x[MAXN], y[MAXN];
pair &lt; pair &lt; int, int &gt;, int &gt; p[MAXN];
inline void make_rect(int xi, int yi, int xj, int yj) {
  e.push_back(event(xi, yi, yj, 1));
  e.push_back(event(xj, yi, yj, -1));
}

inline void make(int i, int j) {
  ans[i] = j - n + 1;
  if (x[i] == x[j] || y[i] == y[j]) {
    make_rect(x[i], y[i], x[j], y[j]);
  } else {
    make_rect(x[i], y[i], x[j] - 1, y[i]);
    make_rect(x[j], y[i], x[j], y[j] - 1);
    make_rect(x[i] + 1, y[j], x[j], y[j]);
    make_rect(x[i], y[i] + 1, x[i], y[j]);
  }
}

int add[MAXN &lt;&lt; 2], mx[MAXN &lt;&lt; 2];

void push(int u) {
  if (add[u] == 0) {
    return;
  }
  add[u &lt;&lt; 1] += add[u];
  add[u &lt;&lt; 1 | 1] += add[u];
  add[u] = 0;
}

void pull(int u) {
  mx[u] = max(mx[u &lt;&lt; 1] + add[u &lt;&lt; 1], mx[u &lt;&lt; 1 | 1] + add[u &lt;&lt; 1 | 1]);
}

int modify(int u, int l, int r, int x, int y, int delta) {
  if (DEBUG) {
    puts(&quot;segment tree:&quot;);
    printf(&quot;%d %d %d %d %d %d %d\n&quot;, u, l, r, x, y, mx[u], add[u]);
  }
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    int res = mx[u] + add[u];
    add[u] += delta;
    return res;
    if (DEBUG) {
      puts(&quot;segment tree end:&quot;);
      printf(&quot;%d %d %d %d %d %d %d\n&quot;, u, l, r, x, y, mx[u], add[u]);
    }
  }
  push(u);
  int m = (l + r) &gt;&gt; 1;
  int res = 0;
  if (x &lt;= m) {
    res = max(res, modify(u &lt;&lt; 1, l, m, x, y, delta));
  }
  if (y &gt; m) {
    res = max(res, modify(u &lt;&lt; 1 | 1, m + 1, r, x, y, delta));
  }
  pull(u);
  if (DEBUG) {
    puts(&quot;segment tree end:&quot;);
    printf(&quot;%d %d %d %d %d %d %d\n&quot;, u, l, r, x, y, mx[u], add[u]);
  }
  return res;
}

int main() {
  scanf(&quot;%d&quot;, &amp;n);
  for (int i = 0; i &lt; n + n; ++i) {
    scanf(&quot;%d %d&quot;, x + i, y + i);
    p[i] = make_pair(make_pair(x[i], y[i]), i);
  }
  sort(p, p + n + n);
  static set &lt; pair &lt; int, int &gt; &gt; s;
  for (int id = 0; id &lt; n + n; ++id) {
    int i = p[id].second;
    if (i &lt; n) {
      s.insert(make_pair(y[i], i));
    } else {
      set &lt; pair &lt; int, int &gt; &gt;::iterator it = s.lower_bound(make_pair(y[i] + 1, -1));
      if (it == s.begin()) {
        if (DEBUG) {
          puts(&quot;pre-work&quot;);
        }
        syntax_error();
      }
      --it;
      make(it-&gt;second, i);
      s.erase(it);
    }
  }
  vector &lt; pair &lt; int, int &gt; &gt; ys;
  for (size_t i = 0; i &lt; e.size(); ++i) {
    ys.push_back(make_pair(e[i].yi, i));
    ys.push_back(make_pair(e[i].yj + 1, ~i));
  }
  sort(ys.begin(), ys.end());
  int t = 0;
  for (size_t i = 0; i &lt; ys.size(); ++i) {
    if (i == 0 || ys[i].first != ys[i - 1].first) {
      ++t;
    }
    const int id = ys[i].second;
    if (id &gt;= 0) {
      e[id].yi = t;
    } else {
      e[~id].yj = t - 1;
    }
  }
  sort(e.begin(), e.end());
  if (DEBUG) {
    for (size_t i = 0; i &lt; e.size(); ++i) {
      event eve = e[i];
      printf(&quot;%d %d %d %d\n&quot;, eve.x, eve.yi, eve.yj, eve.type);
    }
  }
  for (size_t i = 0; i &lt; e.size(); ++i) {
    int value = modify(1, 1, t, e[i].yi, e[i].yj, e[i].type);
    if (e[i].type == 1 &amp;&amp; value &gt; 0) {
      if (DEBUG) {
        printf(&quot;%d %d\n&quot;, int(i), value);
        printf(&quot;%d %d %d %d\n&quot;, e[i].x, e[i].yi, e[i].yj, e[i].type);
        puts(&quot;oh my segment tree&quot;);
      }
      syntax_error();
    }
    //printf(&quot;%d %d %d %d\n&quot;, e[i].x, e[i].yi, e[i].yj, e[i].type);
  }
  for (int i = 0; i &lt; n; ++i) {
    printf(&quot;%d\n&quot;, ans[i]);
  }
  return 0;
}
</body>
</html>
